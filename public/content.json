[{"title":"前端水印生成方案","date":"2018-07-01T11:30:02.000Z","path":"2018/07/01/watermark/","text":"前端水印生成方案 &nbsp;&nbsp;&nbsp;&nbsp;前段时间做某系统审核后台，出现了审核人员截图把内容外泄露的情况，虽然截图内容不是特别敏感，但是安全问题还是不能忽视。于是便在系统页面上面加上了水印，对于审核人员截图等敏感操作有一定的提示作用。 网页水印生成解决方案通过canvas生成水印 Canvas兼容性 这里我们用canvas来生成base64图片，通过CanIUse网站查询兼容性，如果在移动端以及一些管理系统使用，兼容性问题可以完全忽略。 HTMLCanvasElement.toDataURL 方法返回一个包含图片展示的 data URI 。可以使用 type 参数其类型，默认为 PNG 格式。图片的分辨率为96dpi。 如果画布的高度或宽度是0，那么会返回字符串“data:,”。如果传入的类型非“image/png”，但是返回的值以“data:image/png”开头，那么该传入的类型是不支持的。Chrome支持“image/webp”类型。具体参考HTMLCanvasElement.toDataURL 具体代码实现如下： (function () { // canvas 实现 watermark function __canvasWM({ // 使用 ES6 的函数默认值方式设置参数的默认取值 // 具体参见 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters container = document.body, width = &#39;200px&#39;, height = &#39;150px&#39;, textAlign = &#39;center&#39;, textBaseline = &#39;middle&#39;, font = &quot;20px microsoft yahei&quot;, fillStyle = &#39;rgba(184, 184, 184, 0.8)&#39;, content = &#39;请勿外传&#39;, rotate = &#39;30&#39;, zIndex = 1000 } = {}) { var args = arguments[0]; var canvas = document.createElement(&#39;canvas&#39;); canvas.setAttribute(&#39;width&#39;, width); canvas.setAttribute(&#39;height&#39;, height); var ctx = canvas.getContext(&quot;2d&quot;); ctx.textAlign = textAlign; ctx.textBaseline = textBaseline; ctx.font = font; ctx.fillStyle = fillStyle; ctx.rotate(Math.PI / 180 * rotate); ctx.fillText(content, parseFloat(width) / 2, parseFloat(height) / 2); var base64Url = canvas.toDataURL(); const watermarkDiv = document.createElement(&quot;div&quot;); watermarkDiv.setAttribute(&#39;style&#39;, ` position:absolute; top:0; left:0; width:100%; height:100%; z-index:${zIndex}; pointer-events:none; background-repeat:repeat; background-image:url(&#39;${base64Url}&#39;)`); container.style.position = &#39;relative&#39;; container.insertBefore(watermarkDiv, container.firstChild); }); window.__canvasWM = __canvasWM; })(); // 调用 __canvasWM({ content: &#39;QQMusicFE&#39; }) 效果如下： Canvas实现网页水印效果 为了使这个方法更通用，兼容不同的引用方式，我们还可以加上这段代码： // 为了兼容不同的环境 if (typeof module != &#39;undefined&#39; &amp;&amp; module.exports) { //CMD module.exports = __canvasWM; } else if (typeof define == &#39;function&#39; &amp;&amp; define.amd) { // AMD define(function () { return __canvasWM; }); } else { window.__canvasWM = __canvasWM; } 这样似乎能满足我们的需求了，但是还有一个问题，稍微懂一点浏览器的使用或者网页知识的用户，可以用浏览器的开发者工具来动态更改DOM的属性或者结构就可以去掉了。这个时候有两个解决办法： 监测水印div的变化，记录刚生成的div的innerHTML，每隔几秒就取一次新的值，一旦发生变化，则重新生成水印。但是这种方式可能影响性能； 使用MutationObserver MutationObserver给开发者们提供了一种能在某个范围内的DOM树发生变化时作出适当反应的能力。 MutationObserver兼容性 通过兼容性表可以看出高级浏览器以及移动浏览器支持非常不错。Mutation Observer API 用来监视 DOM 变动。DOM 的任何变动，比如节点的增减、属性的变动、文本内容的变动，这个 API 都可以得到通知。使用MutationObserver构造函数，新建一个观察器实例，实例的有一个回调函数，该回调函数接受两个参数，第一个是变动数组，第二个是观察器实例。MutationObserver 的实例的observe方法用来启动监听，它接受两个参数。第一个参数：所要观察的 DOM 节点，第二个参数：一个配置对象，指定所要观察的特定变动，有以下几种： 属性 描述 childList 如果需要观察目标节点的子节点(新增了某个子节点,或者移除了某个子节点),则设置为true. attributes 如果需要观察目标节点的属性节点(新增或删除了某个属性,以及某个属性的属性值发生了变化),则设置为true. characterData 如果目标节点为characterData节点(一种抽象接口,具体可以为文本节点,注释节点,以及处理指令节点)时,也要观察该节点的文本内容是否发生变化,则设置为true. subtree 除了目标节点,如果还需要观察目标节点的所有后代节点(观察目标节点所包含的整棵DOM树上的上述三种节点变化),则设置为true. attributeOldValue 在attributes属性已经设为true的前提下,如果需要将发生变化的属性节点之前的属性值记录下来(记录到下面MutationRecord对象的oldValue属性中),则设置为true. characterDataOldValue 在characterData属性已经设为true的前提下,如果需要将发生变化的characterData节点之前的文本内容记录下来(记录到下面MutationRecord对象的oldValue属性中),则设置为true. attributeFilter 一个属性名数组(不需要指定命名空间),只有该数组中包含的属性名发生变化时才会被观察到,其他名称的属性发生变化后会被忽略. MutationObserver只能监测到诸如属性改变、增删子结点等，对于自己本身被删除，是没有办法的可以通过监测父结点来达到要求。因此最终改造之后代码为： (function () { // canvas 实现 watermark function __canvasWM({ // 使用 ES6 的函数默认值方式设置参数的默认取值 // 具体参见 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Default_parameters container = document.body, width = &#39;300px&#39;, height = &#39;200px&#39;, textAlign = &#39;center&#39;, textBaseline = &#39;middle&#39;, font = &quot;20px Microsoft Yahei&quot;, fillStyle = &#39;rgba(184, 184, 184, 0.6)&#39;, content = &#39;请勿外传&#39;, rotate = &#39;30&#39;, zIndex = 1000 } = {}) { const args = arguments[0]; const canvas = document.createElement(&#39;canvas&#39;); canvas.setAttribute(&#39;width&#39;, width); canvas.setAttribute(&#39;height&#39;, height); const ctx = canvas.getContext(&quot;2d&quot;); ctx.textAlign = textAlign; ctx.textBaseline = textBaseline; ctx.font = font; ctx.fillStyle = fillStyle; ctx.rotate(Math.PI / 180 * rotate); ctx.fillText(content, parseFloat(width) / 2, parseFloat(height) / 2); const base64Url = canvas.toDataURL(); const __wm = document.querySelector(&#39;.__wm&#39;); const watermarkDiv = __wm || document.createElement(&quot;div&quot;); const styleStr = ` position:absolute; top:0; left:0; width:100%; height:100%; z-index:${zIndex}; pointer-events:none; background-repeat:repeat; background-image:url(&#39;${base64Url}&#39;)`; watermarkDiv.setAttribute(&#39;style&#39;, styleStr); watermarkDiv.classList.add(&#39;__wm&#39;); if (!__wm) { container.style.position = &#39;relative&#39;; container.insertBefore(watermarkDiv, container.firstChild); } const MutationObserver = window.MutationObserver || window.WebKitMutationObserver; if (MutationObserver) { let mo = new MutationObserver(function () { const __wm = document.querySelector(&#39;.__wm&#39;); // 只在__wm元素变动才重新调用 __canvasWM if ((__wm &amp;&amp; __wm.getAttribute(&#39;style&#39;) !== styleStr) || !__wm) { // 避免一直触发 mo.disconnect(); mo = null; __canvasWM(JSON.parse(JSON.stringify(args))); } }); mo.observe(container, { attributes: true, subtree: true, childList: true }) } } if (typeof module != &#39;undefined&#39; &amp;&amp; module.exports) { //CMD module.exports = __canvasWM; } else if (typeof define == &#39;function&#39; &amp;&amp; define.amd) { // AMD define(function () { return __canvasWM; }); } else { window.__canvasWM = __canvasWM; } })(); // 调用 __canvasWM({ content: &#39;QQMusicFE&#39; }); 通过SVG生成水印SVG：可缩放矢量图形（英语：Scalable Vector Graphics，SVG）是一种基于可扩展标记语言（XML），用于描述二维矢量图形的图形格式。 SVG由W3C制定，是一个开放标准。 – 维基百科 SVG浏览器兼容性 相比Canvas，SVG有更好的浏览器兼容性，使用SVG生成水印的方式与Canvas的方式类似，只是base64Url的生成方式换成了SVG。具体如下： (function () { // svg 实现 watermark function __svgWM({ container = document.body, content = &#39;请勿外传&#39;, width = &#39;300px&#39;, height = &#39;200px&#39;, opacity = &#39;0.2&#39;, fontSize = &#39;20px&#39;, zIndex = 1000 } = {}) { const args = arguments[0]; const svgStr = `&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; width=&quot;${width}&quot; height=&quot;${width}&quot;&gt; &lt;text x=&quot;50%&quot; y=&quot;50%&quot; dy=&quot;12px&quot; text-anchor=&quot;middle&quot; stroke=&quot;#000000&quot; stroke-width=&quot;1&quot; stroke-opacity=&quot;${opacity}&quot; fill=&quot;none&quot; transform=&quot;rotate(-45, 120 120)&quot; style=&quot;font-size: ${fontSize};&quot;&gt; ${content} &lt;/text&gt; &lt;/svg&gt;`; const base64Url = `data:image/svg+xml;base64,${window.btoa(unescape(encodeURIComponent(svgStr)))}`; const __wm = document.querySelector(&#39;.__wm&#39;); const watermarkDiv = __wm || document.createElement(&quot;div&quot;); // ... // 与 canvas 的一致 // ... })(); __svgWM({ content: &#39;QQMusicFE&#39; }) 通过NodeJS生成水印身为现代前端开发者，Node.JS也是需要掌握的。我们同样可以通过NodeJS来生成网页水印(出于性能考虑更好的方式是利用用户客户端来生成)。前端发一个请求，参数带上水印内容，后台返回图片内容。具体实现(Koa2环境)： 安装gm以及相关环境，详情看gm文档 ctx.type = &#39;image/png&#39;;设置响应为图片类型 生成图片过程是异步的，所以需要包装一层Promise，这样才能为通过 async/await 方式为 ctx.body 赋值 const fs = require(&#39;fs&#39;) const gm = require(&#39;gm&#39;); const imageMagick = gm.subClass({ imageMagick: true }); const router = require(&#39;koa-router&#39;)(); router.get(&#39;/wm&#39;, async (ctx, next) =&gt; { const { text } = ctx.query; ctx.type = &#39;image/png&#39;; ctx.status = 200; ctx.body = await ((() =&gt; { return new Promise((resolve, reject) =&gt; { imageMagick(200, 100, &quot;rgba(255,255,255,0)&quot;) .fontSize(40) .drawText(10, 50, text) .write(require(&#39;path&#39;).join(__dirname, `./${text}.png`), function (err) { if (err) { reject(err); } else { resolve(fs.readFileSync(require(&#39;path&#39;).join(__dirname, `./${text}.png`))) } }); }) })()); }); 如果只是简单的水印展示，建议在浏览器生成，性能更好 图片水印生成解决方案除了给网页加上水印之外，有时候我们需要给图片也加上水印，这样在用户保存图片后，带上了水印来源信息，既可以保护版权，水印的其他信息也可以防止泄密。 通过canvas给图片加水印实现如下： (function() { function __picWM({ url = &#39;&#39;, textAlign = &#39;center&#39;, textBaseline = &#39;middle&#39;, font = &quot;20px Microsoft Yahei&quot;, fillStyle = &#39;rgba(184, 184, 184, 0.8)&#39;, content = &#39;请勿外传&#39;, cb = null, textX = 100, textY = 30 } = {}) { const img = new Image(); img.src = url; img.crossOrigin = &#39;anonymous&#39;; img.onload = function() { const canvas = document.createElement(&#39;canvas&#39;); canvas.width = img.width; canvas.height = img.height; const ctx = canvas.getContext(&#39;2d&#39;); ctx.drawImage(img, 0, 0); ctx.textAlign = textAlign; ctx.textBaseline = textBaseline; ctx.font = font; ctx.fillStyle = fillStyle; ctx.fillText(content, img.width - textX, img.height - textY); const base64Url = canvas.toDataURL(); cb &amp;&amp; cb(base64Url); } } if (typeof module != &#39;undefined&#39; &amp;&amp; module.exports) { //CMD module.exports = __picWM; } else if (typeof define == &#39;function&#39; &amp;&amp; define.amd) { // AMD define(function () { return __picWM; }); } else { window.__picWM = __picWM; } })(); // 调用 __picWM({ url: &#39;http://localhost:3000/imgs/google.png&#39;, content: &#39;QQMusicFE&#39;, cb: (base64Url) =&gt; { document.querySelector(&#39;img&#39;).src = base64Url }, }); 效果如下： Canvas给图片生成水印 通过NodeJS批量为图片加水印我们同样可以通过gm这个库来给图片加上水印 function picWM(path, text) { imageMagick(path) .drawText(10, 50, text) .write(require(&#39;path&#39;).join(__dirname, `./${text}.png`), function (err) { if (err) { console.log(err); } }); } 如果需要批处理图片，只需要遍历相关文件即可。 如果只是简单的水印展示，建议在浏览器生成，性能更好 拓展隐水印前段时间阿里凭截图查到了月饼事件的泄密者，其实就是用了隐水印。这其实很大程度不是前端的范畴了，但是我们也应该了解。AlloyTeam团队写过一篇 不能说的秘密——前端也能玩的图片隐写术 ，通过Canvas给图片加上了“隐水印”，针对用户保存的图片，是可以轻松还原里面隐含的内容，但是对于截图或者处理过的照片却无能为力，不过对于一些机密图片文件展示，是可以偷偷用上该技术的。 使用加密后的水印内容前端生成的水印也可以，别人也可以用同样的方式生成，可能会有“嫁祸于人”（可能这是多虑的），我们还是要有更安全的解决方法。水印内容可以包含多种编码后的信息，包括用户名、用户ID、时间等。比如我们只是想保存用户唯一的用户ID，需要把用户ID传入下面的md5方法，就可以生成唯一标识。编码后的信息是不可逆的，但可以通过全局遍历所有用户的方式进行追溯。这样就可以防止水印造假也可以追溯真正水印的信息。 // MD5加密库 utility const utils = require(&#39;utility&#39;) // 加盐MD5 exports.md5 = function (content) { const salt = &#39;microzz_asd!@#IdSDAS~~&#39;; return utils.md5(utils.md5(content + salt)); } 总结安全问题不能大意，对于一些比较敏感的内容，我们可以通过组合使用上述的水印方案，这样才能最大程度给浏览者警示的作用，减少泄密的情况。 参考链接 不能说的秘密——前端也能玩的图片隐写术 阮一峰-Mutation Observer API lucifer-基于KM水印的图片网页水印实现方案 damon-网页水印明水印前端SVG实现方案","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"Canvas","slug":"Canvas","permalink":"https://microzz.com/tags/Canvas/"},{"name":"SVG","slug":"SVG","permalink":"https://microzz.com/tags/SVG/"},{"name":"隐水印","slug":"隐水印","permalink":"https://microzz.com/tags/隐水印/"},{"name":"NodeJS","slug":"NodeJS","permalink":"https://microzz.com/tags/NodeJS/"}]},{"title":"Linux/Mac下SSH无密码登录服务器配置","date":"2018-03-27T09:57:24.000Z","path":"2018/03/27/ssh-login/","text":"Linux/Mac下实现SSH无密码登录服务器在可信设备上每次连接服务器都比较繁琐，现在通过配置公私钥就可以实现无密码登录。 步骤首先我们在自己的Linux系统（客户端，这里是Mac）上生成一对SSH Key：SSH密钥和SSH公钥。密钥保存在自己的Linux系统上。然后公钥上传到Linux服务器。之后我们就能无密码SSH登录了。SSH密钥就好比是你的身份证明 客户端这里用Mac的终端环境做演示 切换到用户名下面的.ssh路径下:cd ~/.ssh ls查看目录下面有没有id_rsa、id_rsa.pub文件，如果有，则可以跳过3操作 打开终端，使用下面的ssh-keygen来生成RSA密钥和公钥．-t表示type，就是说要生成RSA加密的钥匙．默认的RSA长度是2048位。如果你非常注重安全，那么可以指定4096位的长度ssh-keygen -t rsa -b 4096 -C &quot;Your Email&quot;生成SSH Key的过程中会要求你指定一个文件来保存密钥，按Enter键使用默认的文件就行了。然后需要输入一个密码来加密你的SSH Key。SSH私钥会保存在目录下的～/.ssh/id_rsa文件中。SSH公钥保存在～/.ssh/id_rsa.pub文件中 服务器 在用户～/目录下，同样生成私钥和公钥ssh-keygen -t rsa -b 4096 -C &quot;Your Email&quot; 开启ssh代理eval &quot;$(ssh-agent -s)&quot; 把key加入代理中ssh-add ~/.ssh/id_rsa 粘贴本地的公钥到服务器 vi ~/.ssh/authorized_keys 也可以使用ssh-copy-id命令来完成。ssh-copy-id username@remote-server输入远程用户的密码后，SSH公钥就会自动上传了。SSH公钥保存在远程Linux服务器的～/.ssh/authorized_keys文件中． 授权文件chmod 600 authorized_keys 重启服务sudo service sshd restart 到这里你就可以直接在你本地ssh username@remote-server实现无密码登录服务器了，非常方便。 alias 别名登录上面我们要登录服务器时还是要ssh username@remote-server服务器地址一般不好记，这个时候我们就可以在Mac终端里面设置别名，简写很多操作。这里以zsh为例修改alias别名快捷方式，实现快速登录服务器 打开配置文件vi ~/.zshrc 添加别名配置 alias cvm=&quot;ssh root@your_server_address&quot; alias codes=&quot;cd ~/codes&quot; alias down=&quot;cd ~/Downloads&quot; alias desk=&quot;cd ~/Desktop&quot; alias ~=&quot;cd ~&quot; 3.使配置生效 source ~/.zshrc 现在我们在终端输入 cvm 就可以无密码快速登录自己的服务器了输入codes就可以快捷进入~/codes文件夹，还有很多其他的快捷方式你可以根据需要添加","tags":[{"name":"Linux","slug":"Linux","permalink":"https://microzz.com/tags/Linux/"},{"name":"ssh","slug":"ssh","permalink":"https://microzz.com/tags/ssh/"},{"name":"服务器","slug":"服务器","permalink":"https://microzz.com/tags/服务器/"}]},{"title":"几行代码了解JS中的柯里化和反柯里化","date":"2018-01-01T03:29:36.000Z","path":"2018/01/01/curryanduncurry/","text":"几行代码了解JavaScript中的curring和uncurringcurry 柯里化在计算机科学中，柯里化（英语：Currying），又译为卡瑞化或加里化，是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 – 维基百科 下面几行代码说明一下： var curry = function(fn) { var _args = []; return function _f() { if (arguments.length) { Array.prototype.push.apply(_args, arguments); return _f; } return fn.apply(this, _args); } } // 累加方法 var add = curry(function() { return Array.prototype.reduce.call(arguments, function(acc, cur) { return acc + cur; }, 0); }); add(1)(2)(3)(); // 6 add(4)(); // 10 我们可以看到当参数为空时候就可以求出对应的值，也起到了一个惰性求值(延迟求值)的目的，在某些场景对性能提升有一定的帮助。这个例子可能大家不太熟悉，下面这个例子大家应该都不陌生： function add(a) { return function (b) { return a + b; } } var add5 = add(5); add5(10); // 15 add5(20); // 25 uncurry 反柯里化反curring就是把原来已经固定的参数或者this上下文等当作参数延迟到未来传递。 Function.prototype.uncurry = function() { var _this = this; return function() { return Function.prototype.call.apply(_this, arguments); } } var obj = {}; var arr = []; var push = Array.prototype.push.uncurry(); push(obj, &#39;hello&#39;, &#39;world&#39;); // obj {0: &quot;hello&quot;, 1: &quot;world&quot;, length: 2} push(arr, &#39;hello&#39;, &#39;world&#39;); // arr [&quot;hello&quot;, &quot;world&quot;] About个人网站：🔗microzz-IT技术分享 GitHub：🔗microzz","tags":[{"name":"curring","slug":"curring","permalink":"https://microzz.com/tags/curring/"},{"name":"uncurring","slug":"uncurring","permalink":"https://microzz.com/tags/uncurring/"},{"name":"柯里化","slug":"柯里化","permalink":"https://microzz.com/tags/柯里化/"},{"name":"反柯里化","slug":"反柯里化","permalink":"https://microzz.com/tags/反柯里化/"}]},{"title":"腾讯AlloyTeam前端大会AC2017","date":"2017-10-30T05:51:31.000Z","path":"2017/10/30/ac2017/","text":"腾讯AlloyTeam前端大会AC2017介绍 本次大会干货比较多，内容值得每一个前端er好好吸收（后面有大会的PPT资料） 开场舞蹈腾讯专属舞团SOS女子组合舞蹈表演 腾讯专属舞团SOS女子组合舞蹈 面向亿万级用户的Web同构直出李强 AlloyTeam-李强 直出技术作为提升页面首屏性能的终极手段，早已运用到腾讯的各个业务中，利用直出技术，Web首屏页面的加载速度能得到极大提升。而有了Nodejs的支持，使得同构直出也成为了可能，利用同构直出，前后端不必再为需要同时维护两套代码而烦恼。兴趣部落作为手Q内日均访问量高达5亿+的大型web业务，在同构直出方面也有非常多的实战经验来保证服务在高并发量下的可用性。李强将为你揭晓这一切。 大型Web项目可用性提升 - 零脚本错误的实战郭林烁 AlloyTeam-郭林烁 脚本错误对于前端开发者一点都不陌生，一旦发生脚本错误，轻则影响页面的一些功能，重则直接导致页面白屏。虽然我们在开发中竭力避免页面出现脚本错误，但因为用户处在各异的网络情况、不同的浏览器类型等复杂场景中，脚本错误每天仍然大量发生在用户的页面上。AlloyTeam团队在903036377群等亿级pv的项目中积累了大量脚本错误监控和优化的相关经验。Joeyguo将通过此次分享，由浅入深来讲解如何设计和搭建一个完善的脚本错误监控上报、高效定位以及调优的实战方案。 如何构建后现代前端工程化开发体系李成熙 AlloyTeam-李成熙 AlloyTeam一直是腾讯前端的业界标杆。在业务上，团队负责903036377群、兴趣部落、互动直播等几大业务的众多需求。在公司内，团队创造并维护了许多工具平台。在公司外，团队办大会，做开源，写文章，做分享。到底是AlloyTeam是凭借什么成为如此高效的开发团队呢？李成熙的此次分享将会为你揭开神秘面纱，介绍AlloyTeam成员如何利用前端现代化开发体系来提高自己的工作效率。如果你希望自己成为一个高效率的前端开发者，此次分享不容错过。 Javascript与机器学习的前世今生张磊 AlloyTeam-张磊 人工智能、机器学习是目前最火热的技术，Google DeepMind的AlphaGo在万众瞩目下打败了围棋大师李世乭九段和柯杰九段，更是让人们对人工智能的期待到达了顶点。作为对人工智能感兴趣的前端开发者，机器学习和JavaScript结合能帮助我们做些什么事情呢？前端开发者有没有可能在人工智能领域进行深耕？JavaScript程序员能够以何种方式进入人工智能研究的领域？AlloyTeam团队的张磊将为你一一解密。 高效H5动画设计与性能优化廖泽恺 AlloyTeam-廖泽恺 在移动设备性能越来越好的今天，基本的web图文展示早已不能满足广大用户的需求，而随着flash正式退出历史舞台，h5动画必将迎来又一次的飞跃发展。廖泽恺的本次分享将向大家介绍H5动画的各种实现原理、在不同场景下如何选择最合适的动画实现方式、如何在不同机型下进行适配，以及对动画性能和可配置性上进行深入探索，帮助你轻松在项目中实现各种各样的动画。 ES2017时代的后函数式编程王斌 AlloyTeam-王斌 函数式编程至今已有60年历史，但时至今日仍然有许多开发者被函数式编程的魅力所折服。如果我们关注过jquery、react、redux等框架的源代码，会发现这些框架作者都加入了非常多的函数式编程技巧。函数式编程究竟有什么优点？对我们前端开发者编写代码究竟有什么帮助呢？王斌将为你从浅入深介绍函数式编程的原理和实战技巧，让你像jquery、react、redux作者一样写出优雅的代码。 如何把自己构建成大型互联网公司需要的前端人才潘佳韩 Alloyteam-潘佳韩 作为一个前端新人，也许你有类似这样的问题：“我现在大三，怎么才能进入腾讯实习？”“我现在毕业1年，如何学习前端”“感觉我现在的工作没什么技术含量，腾讯的前端工程师是怎么样工作的？”老教授12年进入腾讯AlloyTeam工作，从前端小白成长为高级工程师和面试官。此次分享将结合老教授自己的成长经历，讲述如何在学校和工作时如何更高效地学习前端知识、校招和社招面试我们到底需要什么样的前端人才、以及前端新人如何规划职业发展。不论是前端新人还是有一定工作经验的开发者，此次分享都可以让你少走弯路，早日成为前端大牛。 AC2017大会PPT资料下载链接：AlloyTeam Conf 2017大会PPT(密码：LcSQjy)","tags":[{"name":"AlloyTeam","slug":"AlloyTeam","permalink":"https://microzz.com/tags/AlloyTeam/"},{"name":"前端","slug":"前端","permalink":"https://microzz.com/tags/前端/"},{"name":"分享","slug":"分享","permalink":"https://microzz.com/tags/分享/"},{"name":"附件","slug":"附件","permalink":"https://microzz.com/tags/附件/"}]},{"title":"JS中的属性描述对象","date":"2017-09-10T00:49:28.000Z","path":"2017/09/10/js-attributes/","text":"JavaScript中的属性描述对象概述JavaScript提供了一个内部数据结构，用来描述一个对象的属性的行为，控制它的行为。这被称为“属性描述对象”（attributes object）。每个属性都有自己对应的属性描述对象，保存该属性的一些元信息。 下面是属性描述对象的一个实例。 { value: 123, writable: false, enumerable: true, configurable: false, get: undefined, set: undefined } 属性描述对象提供6个元属性。 （1）value value存放该属性的属性值，默认为undefined。 （2）writable writable存放一个布尔值，表示属性值（value）是否可改变，默认为true。 （3）enumerable enumerable存放一个布尔值，表示该属性是否可枚举，默认为true。如果设为false，会使得某些操作（比如for...in循环、Object.keys()）跳过该属性。 （4）configurable configurable存放一个布尔值，表示“可配置性”，默认为true。如果设为false，将阻止某些操作改写该属性，比如，无法删除该属性，也不得改变该属性的属性描述对象（value属性除外）。也就是说，configurable属性控制了属性描述对象的可写性。 （5）get get存放一个函数，表示该属性的取值函数（getter），默认为undefined。 （6）set set存放一个函数，表示该属性的存值函数（setter），默认为undefined。 Object.getOwnPropertyDescriptor()Object.getOwnPropertyDescriptor方法可以读出对象自身属性的属性描述对象。 var o = { p: &#39;a&#39; }; Object.getOwnPropertyDescriptor(o, &#39;p&#39;) // Object { value: &quot;a&quot;, // writable: true, // enumerable: true, // configurable: true // } 上面代码表示，使用Object.getOwnPropertyDescriptor方法，读取o对象的p属性的属性描述对象。 Object.defineProperty()，Object.defineProperties()Object.defineProperty方法允许通过定义属性描述对象，来定义或修改一个属性，然后返回修改后的对象。它的格式如下。 Object.defineProperty(object, propertyName, attributesObject) 上面代码中，Object.defineProperty方法接受三个参数，第一个是属性所在的对象，第二个是属性名（它应该是一个字符串），第三个是属性的描述对象。比如，新建一个o对象，并定义它的p属性，写法如下。 var o = Object.defineProperty({}, &#39;p&#39;, { value: 123, writable: false, enumerable: true, configurable: false }); o.p // 123 o.p = 246; o.p // 123 // 因为writable为false，所以无法改变该属性的值 如果属性已经存在，Object.defineProperty方法相当于更新该属性的属性描述对象。 需要注意的是，Object.defineProperty方法和后面的Object.defineProperties方法，都有性能损耗，会拖慢执行速度，不宜大量使用。 如果一次性定义或修改多个属性，可以使用Object.defineProperties方法。 var o = Object.defineProperties({}, { p1: { value: 123, enumerable: true }, p2: { value: &#39;abc&#39;, enumerable: true }, p3: { get: function () { return this.p1 + this.p2 }, enumerable:true, configurable:true } }); o.p1 // 123 o.p2 // &quot;abc&quot; o.p3 // &quot;123abc&quot; 上面代码中的p3属性，定义了取值函数get。这时需要注意的是，一旦定义了取值函数get（或存值函数set），就不能将writable设为true，或者同时定义value属性，会报错。 var o = {}; Object.defineProperty(o, &#39;p&#39;, { value: 123, get: function() { return 456; } }); // TypeError: Invalid property. // A property cannot both have accessors and be writable or have a value, 上面代码同时定义了get属性和value属性，结果就报错。 Object.defineProperty()和Object.defineProperties()的第三个参数，是一个属性对象。它的writable、configurable、enumerable这三个属性的默认值都为false。 var obj = {}; Object.defineProperty(obj, &#39;foo&#39;, { configurable: true }); Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;) // { // value: undefined, // writable: false, // enumerable: false, // configurable: true // } 上面代码中，定义obj对象的foo属性时，只定义了可配置性configurable为true。结果，其他元属性都是默认值。 writable属性为false，表示对应的属性的值将不得改写。 var o = {}; Object.defineProperty(o, &#39;p&#39;, { value: &quot;bar&quot; }); o.p // bar o.p = &#39;foobar&#39;; o.p // bar Object.defineProperty(o, &#39;p&#39;, { value: &#39;foobar&#39;, }); // TypeError: Cannot redefine property: p 上面代码由于writable属性默认为false，导致无法对p属性重新赋值，但是不会报错（严格模式下会报错）。不过，如果再一次使用Object.defineProperty方法对value属性赋值，就会报错。 configurable属性为false，将无法删除该属性，也无法修改attributes对象（value属性除外）。 var o = {}; Object.defineProperty(o, &#39;p&#39;, { value: &#39;bar&#39;, }); delete o.p o.p // &quot;bar&quot; 上面代码中，由于configurable属性默认为false，导致无法删除某个属性。 enumerable属性为false，表示对应的属性不会出现在for...in循环和Object.keys方法中。 var o = { p1: 10, p2: 13, }; Object.defineProperty(o, &#39;p3&#39;, { value: 3, }); for (var i in o) { console.log(i, o[i]); } // p1 10 // p2 13 上面代码中，p3属性是用Object.defineProperty方法定义的，由于enumerable属性默认为false，所以不出现在for...in循环中。 元属性属性描述对象的属性，被称为“元属性”，因为它可以看作是控制属性的属性。 可枚举性（enumerable）JavaScript的最初版本，in 运算符和基于它的for...in循环，会遍历对象实例的所有属性，包括继承的属性。 var obj = {}; &#39;toString&#39; in obj // true 上面代码中，toString不是obj对象自身的属性，但是in运算符也返回true，导致被for...in循环遍历，这显然不太合理。后来就引入了“可枚举性”这个概念，只有可枚举的属性，才会被for...in循环遍历，同时还规定原生继承的属性都是不可枚举的，这样就保证了for...in循环的可用性。 可枚举性（enumerable）用来控制所描述的属性，是否将被包括在for...in循环之中。具体来说，如果一个属性的enumerable为false，下面三个操作不会取到该属性。 for..in循环 Object.keys方法 JSON.stringify方法 因此，enumerable可以用来设置“秘密”属性。 var o = {a: 1, b: 2}; o.c = 3; Object.defineProperty(o, &#39;d&#39;, { value: 4, enumerable: false }); o.d // 4 for (var key in o) { console.log(o[key]); } // 1 // 2 // 3 Object.keys(o) // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] JSON.stringify(o) // &quot;{a:1, b:2, c:3}&quot; 上面代码中，d属性的enumerable为false，所以一般的遍历操作都无法获取该属性，使得它有点像“秘密”属性，但不是真正的私有属性，还是可以直接获取它的值。 基本上，JavaScript原生提供的属性都是不可枚举的，用户自定义的属性都是可枚举的。 与枚举性相关的几个操作的区别的是，for...in循环包括继承自原型对象的属性，Object.keys方法只返回对象本身的属性。如果需要获取对象自身的所有属性，不管是否可枚举，可以使用Object.getOwnPropertyNames方法，详见下文。 考虑到JSON.stringify方法会排除enumerable为false的值，有时可以利用这一点，为对象添加注释信息。 var car = { id: 123, color: &#39;red&#39;, ownerId: 12 }; var owner = { id: 12, name: &#39;Jack&#39; }; Object.defineProperty(car, &#39;ownerInfo&#39;, { value: owner, enumerable: false }); car.ownerInfo // {id: 12, name: &quot;Jack&quot;} JSON.stringify(car) // &quot;{&quot;id&quot;: 123,&quot;color&quot;: &quot;red&quot;,&quot;ownerId&quot;: 12}&quot; 上面代码中，owner对象作为注释部分，加入car对象。由于ownerInfo属性不可枚举，所以JSON.stringify方法最后输出car对象时，会忽略ownerInfo属性。 这提示我们，如果你不愿意某些属性出现在JSON输出之中，可以把它的enumerable属性设为false。 可配置性（configurable）可配置性（configurable）决定了是否可以修改属性描述对象。也就是说，当configurable为false的时候，value、writable、enumerable和configurable都不能被修改了。 var o = Object.defineProperty({}, &#39;p&#39;, { value: 1, writable: false, enumerable: false, configurable: false }); Object.defineProperty(o,&#39;p&#39;, {value: 2}) // TypeError: Cannot redefine property: p Object.defineProperty(o,&#39;p&#39;, {writable: true}) // TypeError: Cannot redefine property: p Object.defineProperty(o,&#39;p&#39;, {enumerable: true}) // TypeError: Cannot redefine property: p Object.defineProperties(o,&#39;p&#39;,{configurable: true}) // TypeError: Cannot redefine property: p 上面代码首先定义对象o，并且定义o的属性p的configurable为false。然后，逐一改动value、writable、enumerable、configurable，结果都报错。 需要注意的是，writable只有在从false改为true会报错，从true改为false则是允许的。 var o = Object.defineProperty({}, &#39;p&#39;, { writable: true, configurable: false }); Object.defineProperty(o,&#39;p&#39;, {writable: false}) // 修改成功 至于value，只要writable和configurable有一个为true，就允许改动。 var o1 = Object.defineProperty({}, &#39;p&#39;, { value: 1, writable: true, configurable: false }); Object.defineProperty(o1,&#39;p&#39;, {value: 2}) // 修改成功 var o2 = Object.defineProperty({}, &#39;p&#39;, { value: 1, writable: false, configurable: true }); Object.defineProperty(o2,&#39;p&#39;, {value: 2}) // 修改成功 另外，configurable为false时，直接对该属性赋值，不报错，但不会成功。 var o = Object.defineProperty({}, &#39;p&#39;, { value: 1, configurable: false }); o.p = 2; o.p // 1 上面代码中，o对象的p属性是不可配置的，对它赋值是不会生效的。 可配置性决定了一个变量是否可以被删除（delete）。 var o = Object.defineProperties({}, { p1: { value: 1, configurable: true }, p2: { value: 2, configurable: false } }); delete o.p1 // true delete o.p2 // false o.p1 // undefined o.p2 // 2 上面代码中的对象o有两个属性，p1是可配置的，p2是不可配置的。结果，p2就无法删除。 需要注意的是，当使用var命令声明变量时，变量的configurable为false。 var a1 = 1; Object.getOwnPropertyDescriptor(this,&#39;a1&#39;) // Object { // value: 1, // writable: true, // enumerable: true, // configurable: false // } 而不使用var命令声明变量时（或者使用属性赋值的方式声明变量），变量的可配置性为true。 a2 = 1; Object.getOwnPropertyDescriptor(this,&#39;a2&#39;) // Object { // value: 1, // writable: true, // enumerable: true, // configurable: true // } // 或者写成 window.a3 = 1; Object.getOwnPropertyDescriptor(window, &#39;a3&#39;) // Object { // value: 1, // writable: true, // enumerable: true, // configurable: true // } 上面代码中的this.a3 = 1与a3 = 1是等价的写法。window指的是浏览器的顶层对象。 这种差异意味着，如果一个变量是使用var命令生成的，就无法用delete命令删除。也就是说，delete只能删除对象的属性。 var a1 = 1; a2 = 1; delete a1 // false delete a2 // true a1 // 1 a2 // ReferenceError: a2 is not defined 可写性（writable）可写性（writable）决定了属性的值（value）是否可以被改变。 var o = {}; Object.defineProperty(o, &#39;a&#39;, { value: 37, writable: false }); o.a // 37 o.a = 25; o.a // 37 上面代码将o对象的a属性可写性设为false，然后改变这个属性的值，就不会有任何效果。 注意，正常模式下，对可写性为false的属性赋值不会报错，只会默默失败。但是，严格模式下会报错，即使是对a属性重新赋予一个同样的值。 关于可写性，还有一种特殊情况。就是如果原型对象的某个属性的可写性为false，那么派生对象将无法自定义这个属性。 var proto = Object.defineProperty({}, &#39;foo&#39;, { value: &#39;a&#39;, writable: false }); var o = Object.create(proto); o.foo = &#39;b&#39;; o.foo // &#39;a&#39; 上面代码中，对象proto的foo属性不可写，结果proto的派生对象o，也不可以再自定义这个属性了。在严格模式下，这样做还会抛出一个错误。但是，有一个规避方法，就是通过覆盖属性描述对象，绕过这个限制，原因是这种情况下，原型链会被完全忽视。 Object.defineProperty(o, &#39;foo&#39;, { value: &#39;b&#39; }); o.foo // &#39;b&#39; Object.getOwnPropertyNames()Object.getOwnPropertyNames方法返回直接定义在某个对象上面的全部属性的名称，而不管该属性是否可枚举。 var o = Object.defineProperties({}, { p1: { value: 1, enumerable: true }, p2: { value: 2, enumerable: false } }); Object.getOwnPropertyNames(o) // [&quot;p1&quot;, &quot;p2&quot;] 一般来说，系统原生的属性（即非用户自定义的属性）都是不可枚举的。 // 比如，数组实例自带length属性是不可枚举的 Object.keys([]) // [] Object.getOwnPropertyNames([]) // [ &#39;length&#39; ] // Object.prototype对象的自带属性也都是不可枚举的 Object.keys(Object.prototype) // [] Object.getOwnPropertyNames(Object.prototype) // [&#39;hasOwnProperty&#39;, // &#39;valueOf&#39;, // &#39;constructor&#39;, // &#39;toLocaleString&#39;, // &#39;isPrototypeOf&#39;, // &#39;propertyIsEnumerable&#39;, // &#39;toString&#39;] 上面代码可以看到，数组的实例对象（[]）没有可枚举属性，不可枚举属性有length；Object.prototype对象也没有可枚举属性，但是有不少不可枚举属性。 Object.prototype.propertyIsEnumerable()对象实例的propertyIsEnumerable方法用来判断一个属性是否可枚举。 var o = {}; o.p = 123; o.propertyIsEnumerable(&#39;p&#39;) // true o.propertyIsEnumerable(&#39;toString&#39;) // false 上面代码中，用户自定义的p属性是可枚举的，而继承自原型对象的toString属性是不可枚举的。 存取器（accessor）除了直接定义以外，属性还可以用存取器（accessor）定义。其中，存值函数称为setter，使用set命令；取值函数称为getter，使用get命令。 存取器提供的是虚拟属性，即该属性的值不是实际存在的，而是每次读取时计算生成的。利用这个功能，可以实现许多高级特性，比如每个属性禁止赋值。 var o = { get p() { return &#39;getter&#39;; }, set p(value) { console.log(&#39;setter: &#39; + value); } }; 上面代码中，o对象内部的get和set命令，分别定义了p属性的取值函数和存值函数。定义了这两个函数之后，对p属性取值时，取值函数会自动调用；对p属性赋值时，存值函数会自动调用。 o.p // &quot;getter&quot; o.p = 123 // &quot;setter: 123&quot; 注意，取值函数Getter不能接受参数，存值函数Setter只能接受一个参数（即属性的值）。另外，对象也不能有与取值函数同名的属性。比如，上面的对象o设置了取值函数p以后，就不能再另外定义一个p属性。 存取器往往用于，属性的值需要依赖对象内部数据的场合。 var o ={ $n : 5, get next() { return this.$n++ }, set next(n) { if (n &gt;= this.$n) this.$n = n; else throw &#39;新的值必须大于当前值&#39;; } }; o.next // 5 o.next = 10; o.next // 10 上面代码中，next属性的存值函数和取值函数，都依赖于对内部属性$n的操作。 存取器也可以通过Object.defineProperty定义。 var d = new Date(); Object.defineProperty(d, &#39;month&#39;, { get: function () { return d.getMonth(); }, set: function (v) { d.setMonth(v); } }); 上面代码为Date的实例对象d，定义了一个可读写的month属性。 存取器也可以使用Object.create方法定义。 var o = Object.create(Object.prototype, { foo: { get: function () { return &#39;getter&#39;; }, set: function (value) { console.log(&#39;setter: &#39;+value); } } }); 如果使用上面这种写法，属性foo必须定义一个属性描述对象。该对象的get和set属性，分别是foo的取值函数和存值函数。 利用存取器，可以实现数据对象与DOM对象的双向绑定。 Object.defineProperty(user, &#39;name&#39;, { get: function () { return document.getElementById(&#39;foo&#39;).value; }, set: function (newValue) { document.getElementById(&#39;foo&#39;).value = newValue; }, configurable: true }); 上面代码使用存取函数，将DOM对象foo与数据对象user的name属性，实现了绑定。两者之中只要有一个对象发生变化，就能在另一个对象上实时反映出来。 对象的拷贝有时，我们需要将一个对象的所有属性，拷贝到另一个对象。ES5没有提供这个方法，必须自己实现。 var extend = function (to, from) { for (var property in from) { to[property] = from[property]; } return to; } extend({}, { a: 1 }) // {a: 1} 上面这个方法的问题在于，如果遇到存取器定义的属性，会只拷贝值。 extend({}, { get a() { return 1 } }) // {a: 1} 为了解决这个问题，我们可以通过Object.defineProperty方法来拷贝属性。 var extend = function (to, from) { for (var property in from) { Object.defineProperty( to, property, Object.getOwnPropertyDescriptor(from, property) ); } return to; } extend({}, { get a(){ return 1 } }) // { get a(){ return 1 } }) 这段代码还是有问题，拷贝某些属性时会失效。 extend(document.body.style, { backgroundColor: &quot;red&quot; }); 上面代码的目的是，设置document.body.style.backgroundColor属性为red，但是实际上网页的背景色并不会变红。但是，如果用第一种简单拷贝的方法，反而能够达到目的。这提示我们，可以把两种方法结合起来，对于简单属性，就直接拷贝，对于那些通过属性描述对象设置的属性，则使用Object.defineProperty方法拷贝。 var extend = function (to, from) { for (var property in from) { var descriptor = Object.getOwnPropertyDescriptor(from, property); if (descriptor &amp;&amp; ( !descriptor.writable || !descriptor.configurable || !descriptor.enumerable || descriptor.get || descriptor.set)) { Object.defineProperty(to, property, descriptor); } else { to[property] = from[property]; } } } 上面的这段代码，可以很好地拷贝对象所有可遍历（enumerable）的属性。 控制对象状态JavaScript提供了三种方法，精确控制一个对象的读写状态，防止对象被改变。最弱一层的保护是Object.preventExtensions，其次是Object.seal，最强的Object.freeze。 Object.preventExtensions()Object.preventExtensions方法可以使得一个对象无法再添加新的属性。 var o = new Object(); Object.preventExtensions(o); Object.defineProperty(o, &#39;p&#39;, { value: &#39;hello&#39; }); // TypeError: Cannot define property:p, object is not extensible. o.p = 1; o.p // undefined 如果是在严格模式下，则会抛出一个错误。 (function () { &#39;use strict&#39;; o.p = &#39;1&#39; }()); // TypeError: Can&#39;t add property bar, object is not extensible 不过，对于使用了preventExtensions方法的对象，可以用delete命令删除它的现有属性。 var o = new Object(); o.p = 1; Object.preventExtensions(o); delete o.p; o.p // undefined Object.isExtensible()Object.isExtensible方法用于检查一个对象是否使用了Object.preventExtensions方法。也就是说，检查是否可以为一个对象添加属性。 var o = new Object(); Object.isExtensible(o) // true Object.preventExtensions(o); Object.isExtensible(o) // false 上面代码新生成了一个o对象，对该对象使用Object.isExtensible方法，返回true，表示可以添加新属性。对该对象使用Object.preventExtensions方法以后，再使用Object.isExtensible方法，返回false，表示已经不能添加新属性了。 Object.seal()Object.seal方法使得一个对象既无法添加新属性，也无法删除旧属性。 var o = { p: &#39;hello&#39; }; Object.seal(o); delete o.p; o.p // &quot;hello&quot; o.x = &#39;world&#39;; o.x // undefined 上面代码中，一个对象执行Object.seal方法以后，就无法添加新属性和删除旧属性了。 Object.seal实质是把属性描述对象的configurable属性设为false，因此属性描述对象不再能改变了。 var o = { p: &#39;a&#39; }; // seal方法之前 Object.getOwnPropertyDescriptor(o, &#39;p&#39;) // Object { // value: &quot;a&quot;, // writable: true, // enumerable: true, // configurable: true // } Object.seal(o); // seal方法之后 Object.getOwnPropertyDescriptor(o, &#39;p&#39;) // Object { // value: &quot;a&quot;, // writable: true, // enumerable: true, // configurable: false // } Object.defineProperty(o, &#39;p&#39;, { enumerable: false }) // TypeError: Cannot redefine property: p 上面代码中，使用Object.seal方法之后，属性描述对象的configurable属性就变成了false，然后改变enumerable属性就会报错。 可写性（writable）有点特别。如果writable为false，使用Object.seal方法以后，将无法将其变成true；但是，如果writable为true，依然可以将其变成false。 var o1 = Object.defineProperty({}, &#39;p&#39;, { writable: false }); Object.seal(o1); Object.defineProperty(o1, &#39;p&#39;, { writable:true }) // Uncaught TypeError: Cannot redefine property: p var o2 = Object.defineProperty({}, &#39;p&#39;, { writable: true }); Object.seal(o2); Object.defineProperty(o2, &#39;p&#39;, { writable:false }); Object.getOwnPropertyDescriptor(o2, &#39;p&#39;) // { // value: &#39;&#39;, // writable: false, // enumerable: true, // configurable: false // } 上面代码中，同样是使用了Object.seal方法，如果writable原为false，改变这个设置将报错；如果原为true，则不会有问题。 至于属性对象的value是否可改变，是由writable决定的。 var o = { p: &#39;a&#39; }; Object.seal(o); o.p = &#39;b&#39;; o.p // &#39;b&#39; 上面代码中，Object.seal方法对p属性的value无效，是因为此时p属性的writable为true。 Object.isSealed()Object.isSealed方法用于检查一个对象是否使用了Object.seal方法。 var o = { p: &#39;a&#39; }; Object.seal(o); Object.isSealed(o) // true 这时，Object.isExtensible方法也返回false。 var o = { p: &#39;a&#39; }; Object.seal(o); Object.isExtensible(o) // false Object.freeze()Object.freeze方法可以使得一个对象无法添加新属性、无法删除旧属性、也无法改变属性的值，使得这个对象实际上变成了常量。 var o = { p: &#39;hello&#39; }; Object.freeze(o); o.p = &#39;world&#39;; o.p // hello o.t = &#39;hello&#39;; o.t // undefined 上面代码中，对现有属性重新赋值（o.p = &#39;world&#39;）或者添加一个新属性，并不会报错，只是默默地失败。但是，如果是在严格模式下，就会报错。 var o = { p: &#39;hello&#39; }; Object.freeze(o); // 对现有属性重新赋值 (function () { &#39;use strict&#39;; o.p = &#39;world&#39;; }()) // TypeError: Cannot assign to read only property &#39;p&#39; of #&lt;Object&gt; // 添加不存在的属性 (function () { &#39;use strict&#39;; o.t = 123; }()) // TypeError: Can&#39;t add property t, object is not extensible Object.isFrozen()Object.isFrozen方法用于检查一个对象是否使用了Object.freeze()方法。 var obj = { p: &#39;hello&#39; }; Object.freeze(obj); Object.isFrozen(obj) // true 前面说过，如果一个对象被冻结，再对它的属性赋值，在严格模式下会报错。Object.isFrozen方法可以防止发生这样的错误。 var obj = { p: &#39;hello&#39; }; Object.freeze(obj); if (!Object.isFrozen(obj)) { obj.p = &#39;world&#39;; } 上面代码中，确认obj没有被冻结后，再对它的属性赋值，就不会报错了。 局限性上面的方法锁定对象的可写性有一个漏洞，依然可以通过改变原型对象，来为对象增加属性。 var obj = new Object(); Object.preventExtensions(obj); var proto = Object.getPrototypeOf(obj); proto.t = &#39;hello&#39;; obj.t // hello 一种解决方案是，把原型也冻结住。 var obj = Object.seal( Object.create( Object.freeze({x: 1}), { y: { value: 2, writable: true } } ) ); Object.getPrototypeOf(obj).hello = &quot;hello&quot;; obj.hello // undefined 另外一个局限是，如果属性值是对象，上面这些方法只能冻结属性指向的对象，而不能冻结对象本身的内容。 var obj = { foo: 1, bar: [&#39;a&#39;, &#39;b&#39;] }; Object.freeze(obj); obj.bar.push(&#39;c&#39;); obj.bar // [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;] 上面代码中，obj.bar属性指向一个数组，obj对象被冻结以后，这个指向无法改变，即无法指向其他值，但是所指向的数组是可以改变的。 关于本文仅供学习交流分享，原文链接 属性描述对象，感谢阮一峰老师","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"Descriptor","slug":"Descriptor","permalink":"https://microzz.com/tags/Descriptor/"},{"name":"属性描述对象","slug":"属性描述对象","permalink":"https://microzz.com/tags/属性描述对象/"}]},{"title":"JavaScript中的RegExp对象","date":"2017-08-26T02:04:05.000Z","path":"2017/08/26/js-regexp/","text":"JS中的正则对象概述正则表达式（regular expression）是一种表达文本模式（即字符串结构）的方法，有点像字符串的模板，常常用作按照“给定模式”匹配文本的工具。比如，正则表达式给出一个 Email 地址的模式，然后用它来确定一个字符串是否为 Email 地址。JavaScript 的正则表达式体系是参照 Perl 5 建立的。 新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。 var regex = /xyz/; 另一种是使用 RegExp 构造函数。 var regex = new RegExp(&#39;xyz&#39;); 上面两种写法是等价的，都新建了一个内容为xyz的正则表达式对象。它们的主要区别是，第一种方法在编译时新建正则表达式，第二种方法在运行时新建正则表达式。 RegExp 构造函数还可以接受第二个参数，表示修饰符（详细解释见下文）。 var regex = new RegExp(&#39;xyz&#39;, &quot;i&quot;); // 等价于 var regex = /xyz/i; 上面代码中，正则表达式/xyz/有一个修饰符i。 这两种写法——字面量和构造函数——在运行时有一个细微的区别。采用字面量的写法，正则对象在代码载入时（即编译时）生成；采用构造函数的方法，正则对象在代码运行时生成。考虑到书写的便利和直观，实际应用中，基本上都采用字面量的写法。 正则对象生成以后，有两种使用方式： 正则对象的方法：将字符串作为参数，比如regex.test(string)。 字符串对象的方法：将正则对象作为参数，比如string.match(regex)。 这两种使用方式下面都会介绍。 正则对象的属性和方法属性正则对象的属性分成两类。 一类是修饰符相关，返回一个布尔值，表示对应的修饰符是否设置。 ignoreCase：返回一个布尔值，表示是否设置了i修饰符，该属性只读。 global：返回一个布尔值，表示是否设置了g修饰符，该属性只读。 multiline：返回一个布尔值，表示是否设置了m修饰符，该属性只读。 var r = /abc/igm; r.ignoreCase // true r.global // true r.multiline // true 另一类是与修饰符无关的属性，主要是下面两个。 lastIndex：返回下一次开始搜索的位置。该属性可读写，但是只在设置了g修饰符时有意义。 source：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。 var r = /abc/igm; r.lastIndex // 0 r.source // &quot;abc&quot; test()正则对象的test方法返回一个布尔值，表示当前模式是否能匹配参数字符串。 /cat/.test(&#39;cats and dogs&#39;) // true 上面代码验证参数字符串之中是否包含cat，结果返回true。 如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。 var r = /x/g; var s = &#39;_x_x&#39;; r.lastIndex // 0 r.test(s) // true r.lastIndex // 2 r.test(s) // true r.lastIndex // 4 r.test(s) // false 上面代码的正则对象使用了g修饰符，表示要记录搜索位置。接着，三次使用test方法，每一次开始搜索的位置都是上一次匹配的后一个位置。 带有g修饰符时，可以通过正则对象的lastIndex属性指定开始搜索的位置。 var r = /x/g; var s = &#39;_x_x&#39;; r.lastIndex = 4; r.test(s) // false 上面代码指定从字符串的第五个位置开始搜索，这个位置是没有字符的，所以返回false。 lastIndex属性只对同一个正则表达式有效，所以下面这样写是错误的。 var count = 0; while (/a/g.test(&#39;babaa&#39;)) count++; 上面代码会导致无限循环，因为while循环的每次匹配条件都是一个新的正则表达式，导致lastIndex属性总是等于0。 如果正则模式是一个空字符串，则匹配所有字符串。 new RegExp(&#39;&#39;).test(&#39;abc&#39;) // true exec()正则对象的exec方法，可以返回匹配结果。如果发现匹配，就返回一个数组，成员是每一个匹配成功的子字符串，否则返回null。 var s = &#39;_x_x&#39;; var r1 = /x/; var r2 = /y/; r1.exec(s) // [&quot;x&quot;] r2.exec(s) // null 上面代码中，正则对象r1匹配成功，返回一个数组，成员是匹配结果；正则对象r2匹配失败，返回null。 如果正则表示式包含圆括号（即含有“组匹配”），则返回的数组会包括多个成员。第一个成员是整个匹配成功的结果，后面的成员就是圆括号对应的匹配成功的组。也就是说，第二个成员对应第一个括号，第三个成员对应第二个括号，以此类推。整个数组的length属性等于组匹配的数量再加1。 var s = &#39;_x_x&#39;; var r = /_(x)/; r.exec(s) // [&quot;_x&quot;, &quot;x&quot;] 上面代码的exec方法，返回一个数组。第一个成员是整个匹配的结果，第二个成员是圆括号匹配的结果。 exec方法的返回数组还包含以下两个属性： input：整个原字符串。 index：整个模式匹配成功的开始位置（从0开始计数）。 var r = /a(b+)a/; var arr = r.exec(&#39;_abbba_aba_&#39;); arr // [&quot;abbba&quot;, &quot;bbb&quot;] arr.index // 1 arr.input // &quot;_abbba_aba_&quot; 上面代码中的index属性等于1，是因为从原字符串的第二个位置开始匹配成功。 如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。 var r = /a(b+)a/g; var a1 = r.exec(&#39;_abbba_aba_&#39;); a1 // [&#39;abbba&#39;, &#39;bbb&#39;] a1.index // 1 r.lastIndex // 6 var a2 = r.exec(&#39;_abbba_aba_&#39;); a2 // [&#39;aba&#39;, &#39;b&#39;] a2.index // 7 r.lastIndex // 10 var a3 = r.exec(&#39;_abbba_aba_&#39;); a3 // null a3.index // TypeError: Cannot read property &#39;index&#39; of null r.lastIndex // 0 var a4 = r.exec(&#39;_abbba_aba_&#39;); a4 // [&#39;abbba&#39;, &#39;bbb&#39;] a4.index // 1 r.lastIndex // 6 上面代码连续用了四次exec方法，前三次都是从上一次匹配结束的位置向后匹配。当第三次匹配结束以后，整个字符串已经到达尾部，正则对象的lastIndex属性重置为0，意味着第四次匹配将从头开始。 利用g修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。 var r = /a(b+)a/g; var s = &#39;_abbba_aba_&#39;; while(true) { var match = r.exec(s); if (!match) break; console.log(match[1]); } // bbb // b 正则对象的lastIndex属性不仅可读，还可写。一旦手动设置了lastIndex的值，就会从指定位置开始匹配。但是，这只在设置了g修饰符的情况下，才会有效。 var r = /a/; r.lastIndex = 7; // 无效 var match = r.exec(&#39;xaxa&#39;); match.index // 1 r.lastIndex // 7 上面代码设置了lastIndex属性，但是因为正则表达式没有g修饰符，所以是无效的。每次匹配都是从字符串的头部开始。 如果有g修饰符，lastIndex属性就会生效。 var r = /a/g; r.lastIndex = 2; var match = r.exec(&#39;xaxa&#39;); match.index // 3 r.lastIndex // 4 上面代码中，lastIndex属性指定从字符的第三个位置开始匹配。成功后，下一次匹配就是从第五个位置开始。 如果正则对象是一个空字符串，则exec方法会匹配成功，但返回的也是空字符串。 var r1 = new RegExp(&#39;&#39;); var a1 = r1.exec(&#39;abc&#39;); a1 // [&#39;&#39;] a1.index // 0 r1.lastIndex // 0 var r2 = new RegExp(&#39;()&#39;); var a2 = r2.exec(&#39;abc&#39;); a2 // [&#39;&#39;, &#39;&#39;] a2.index // 0 r2.lastIndex // 0 字符串对象的方法字符串对象的方法之中，有4种与正则对象有关。 match()：返回一个数组，成员是所有匹配的子字符串。 search()：按照给定的正则表达式进行搜索，返回一个整数，表示匹配开始的位置。 replace()：按照给定的正则表达式进行替换，返回替换后的字符串。 split()：按照给定规则进行字符串分割，返回一个数组，包含分割后的各个成员。 下面逐一介绍。 String.prototype.match()字符串对象的match方法对字符串进行正则匹配，返回匹配结果。 var s = &#39;_x_x&#39;; var r1 = /x/; var r2 = /y/; s.match(r1) // [&quot;x&quot;] s.match(r2) // null 从上面代码可以看到，字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回null。 如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会一次性返回所有匹配成功的结果。 var s = &#39;abba&#39;; var r = /a/g; s.match(r) // [&quot;a&quot;, &quot;a&quot;] r.exec(s) // [&quot;a&quot;] 设置正则表达式的lastIndex属性，对match方法无效，匹配总是从字符串的第一个字符开始。 var r = /a|b/g; r.lastIndex = 7; &#39;xaxb&#39;.match(r) // [&#39;a&#39;, &#39;b&#39;] r.lastIndex // 0 上面代码表示，设置lastIndex属性是无效的。 String.prototype.search()字符串对象的search方法，返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。 &#39;_x_x&#39;.search(/x/) // 1 上面代码中，第一个匹配结果出现在字符串的1号位置。 该方法会忽略g修饰符。 var r = /x/g; r.lastIndex = 2; // 无效 &#39;_x_x&#39;.search(r) // 1 上面代码中，正则表达式使用g修饰符之后，使用lastIndex属性指定开始匹配的位置，结果无效，还是从字符串的第一个字符开始匹配。 String.prototype.replace()字符串对象的replace方法可以替换匹配的值。它接受两个参数，第一个是搜索模式，第二个是替换的内容。 str.replace(search, replacement) 搜索模式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。 &#39;aaa&#39;.replace(&#39;a&#39;, &#39;b&#39;) // &quot;baa&quot; &#39;aaa&#39;.replace(/a/, &#39;b&#39;) // &quot;baa&quot; &#39;aaa&#39;.replace(/a/g, &#39;b&#39;) // &quot;bbb&quot; 上面代码中，最后一个正则表达式使用了g修饰符，导致所有的b都被替换掉了。 replace方法的一个应用，就是消除字符串首尾两端的空格。 var str = &#39; #id div.class &#39;; str.replace(/^\\s+|\\s+$/g, &#39;&#39;) // &quot;#id div.class&quot; replace方法的第二个参数可以使用美元符号$，用来指代所替换的内容。 $&amp; 指代匹配的子字符串。 $` 指代匹配结果前面的文本。 $&#39; 指代匹配结果后面的文本。 $n 指代匹配成功的第n组内容，n是从1开始的自然数。 $$ 指代美元符号$。 &#39;hello world&#39;.replace(/(\\w+)\\s(\\w+)/, &#39;$2 $1&#39;) // &quot;world hello&quot; &#39;abc&#39;.replace(&#39;b&#39;, &#39;[$`-$&amp;-$\\&#39;]&#39;) // &quot;a[a-b-c]c&quot; replace方法的第二个参数还可以是一个函数，将每一个匹配内容替换为函数返回值。 &#39;3 and 5&#39;.replace(/[0-9]+/g, function(match){ return 2 * match; }) // &quot;6 and 10&quot; var a = &#39;The quick brown fox jumped over the lazy dog.&#39;; var pattern = /quick|brown|lazy/ig; a.replace(pattern, function replacer(match) { return match.toUpperCase(); }); // The QUICK BROWN fox jumped over the LAZY dog. 作为replace方法第二个参数的替换函数，可以接受多个参数。第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子。 var prices = { &#39;pr_1&#39;: &#39;$1.99&#39;, &#39;pr_2&#39;: &#39;$9.99&#39;, &#39;pr_3&#39;: &#39;$5.00&#39; }; var template = &#39;/* ... */&#39;; // 这里可以放网页模块字符串 template.replace( /(&lt;span id=&quot;)(.*?)(&quot;&gt;)(&lt;\\/span&gt;)/g, function(match, $1, $2, $3, $4){ return $1 + $2 + $3 + prices[$2] + $4; } ); 上面代码的捕捉模式中，有四个括号，所以会产生四个组匹配，在匹配函数中用$1到$4表示。匹配函数的作用是将价格插入模板中。 String.prototype.split()字符串对象的split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。 str.split(separator, [limit]) 该方法接受两个参数，第一个参数是分隔规则，第二个参数是返回数组的最大成员数。 // 非正则分隔 &#39;a, b,c, d&#39;.split(&#39;,&#39;) // [ &#39;a&#39;, &#39; b&#39;, &#39;c&#39;, &#39; d&#39; ] // 正则分隔，去除多余的空格 &#39;a, b,c, d&#39;.split(/, */) // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39; ] // 指定返回数组的最大成员 &#39;a, b,c, d&#39;.split(/, */, 2) [ &#39;a&#39;, &#39;b&#39; ] 上面代码使用正则表达式，去除了子字符串的逗号后面的空格。 // 例一 &#39;aaa*a*&#39;.split(/a*/) // [ &#39;&#39;, &#39;*&#39;, &#39;*&#39; ] // 例二 &#39;aaa**a*&#39;.split(/a*/) // [&quot;&quot;, &quot;*&quot;, &quot;*&quot;, &quot;*&quot;] 上面代码的分割规则是0次或多次的a，由于正则默认是贪婪匹配，所以例一的第一个分隔符是aaa，第二个分割符是a，将字符串分成三个部分，包含开始处的空字符串。例二的第一个分隔符是aaa，第二个分隔符是0个a（即空字符），第三个分隔符是a，所以将字符串分成四个部分。 如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。 &#39;aaa*a*&#39;.split(/(a*)/) // [ &#39;&#39;, &#39;aaa&#39;, &#39;*&#39;, &#39;a&#39;, &#39;*&#39; ] 上面代码的正则表达式使用了括号，第一个组匹配是“aaa”，第二个组匹配是“a”，它们都作为数组成员返回。 匹配规则正则表达式对字符串的匹配有很复杂的规则。下面一一介绍这些规则。 字面量字符和元字符大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b。如果在正则表达式之中，某个字符只表示它字面的含义（就像前面的a和b），那么它们就叫做“字面量字符”（literal characters）。 /dog/.test(&quot;old dog&quot;) // true 上面代码中正则表达式的dog，就是字面量字符，所以/dog/匹配“old dog”，因为它就表示“d”、“o”、“g”三个字母连在一起。 除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。 （1）点字符（.) 点字符（.）匹配除回车（\\r）、换行(\\n) 、行分隔符（\\u2028）和段分隔符（\\u2029）以外的所有字符。 /c.t/ 上面代码中，c.t匹配c和t之间包含任意一个字符的情况，只要这三个字符在同一行，比如cat、c2t、c-t等等，但是不匹配coot。 （2）位置字符 位置字符用来提示字符所处的位置，主要有两个字符。 ^ 表示字符串的开始位置 $ 表示字符串的结束位置 // test必须出现在开始位置 /^test/.test(&#39;test123&#39;) // true // test必须出现在结束位置 /test$/.test(&#39;new test&#39;) // true // 从开始位置到结束位置只有test /^test$/.test(&#39;test&#39;) // true /^test$/.test(&#39;test test&#39;) // false （3）选择符（|） 竖线符号（|）在正则表达式中表示“或关系”（OR），即cat|dog表示匹配cat或dog。 /11|22/.test(&#39;911&#39;) // true 上面代码中，正则表达式指定必须匹配11或22。 多个选择符可以联合使用。 // 匹配fred、barney、betty之中的一个 /fred|barney|betty/ 选择符会包括它前后的多个字符，比如/ab|cd/指的是匹配ab或者cd，而不是指匹配b或者c。如果想修改这个行为，可以使用圆括号。 /a( |\\t)b/.test(&#39;a\\tb&#39;) // true 上面代码指的是，a和b之间有一个空格或者一个制表符。 其他的元字符还包括\\\\、\\*、+、?、()、[]、{}等，将在下文解释。 转义符正则表达式中那些有特殊含义的字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配加号，就要写成\\+。 /1+1/.test(&#39;1+1&#39;) // false /1\\+1/.test(&#39;1+1&#39;) // true 上面代码中，第一个正则表达式直接用加号匹配，结果加号解释成量词，导致不匹配。第二个正则表达式使用反斜杠对加号转义，就能匹配成功。 正则模式中，需要用斜杠转义的，一共有12个字符：^、.、[、$、(、)、|、*、+、?、{和\\\\。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。 (new RegExp(&#39;1\\+1&#39;)).test(&#39;1+1&#39;) // false (new RegExp(&#39;1\\\\+1&#39;)).test(&#39;1+1&#39;) // true 上面代码中，RegExp作为构造函数，参数是一个字符串。但是，在字符串内部，反斜杠也是转义字符，所以它会先被反斜杠转义一次，然后再被正则表达式转义一次，因此需要两个反斜杠转义。 特殊字符正则表达式对一些不能打印的特殊字符，提供了表达方法。 \\cX 表示Ctrl-[X]，其中的X是A-Z之中任一个英文字母，用来匹配控制字符。 [\\b] 匹配退格键(U+0008)，不要与\\b混淆。 \\n 匹配换行键。 \\r 匹配回车键。 \\t 匹配制表符tab（U+0009）。 \\v 匹配垂直制表符（U+000B）。 \\f 匹配换页符（U+000C）。 \\0 匹配null字符（U+0000）。 \\xhh 匹配一个以两位十六进制数（\\x00-\\xFF）表示的字符。 \\uhhhh 匹配一个以四位十六进制数（\\u0000-\\uFFFF）表示的unicode字符。 字符类字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。 /[abc]/.test(&#39;hello world&#39;) // false /[abc]/.test(&#39;&#39;) // true 上面代码表示，字符串“hello world”不包含a、b、c这三个字母中的任一个，而字符串“”包含字母a。 有两个字符在字符类中有特殊含义。 （1）脱字符（&#94;） 如果方括号内的第一个字符是[^]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[^xyz]表示除了x、y、z之外都可以匹配。 /[^abc]/.test(&#39;hello world&#39;) // true /[^abc]/.test(&#39;bbc&#39;) // false 上面代码表示，字符串“hello world”不包含字母a、b、c中的任一个，所以返回true；字符串“bbc”不包含a、b、c以外的字母，所以返回false。 如果方括号内没有其他字符，即只有[^]，就表示匹配一切字符，其中包括换行符，而点号（.）是不包括换行符的。 var s = &#39;Please yes\\nmake my day!&#39;; s.match(/yes.*day/) // null s.match(/yes[^]*day/) // [ &#39;yes\\nmake my day&#39;] 上面代码中，字符串s含有一个换行符，点号不包括换行符，所以第一个正则表达式匹配失败；第二个正则表达式[^]包含一切字符，所以匹配成功。 注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。 （2）连字符（-） 某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。 /a-z/.test(&#39;b&#39;) // false /[a-z]/.test(&#39;b&#39;) // true 上面代码中，当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义，所以不匹配字符b。只有当连字号用在方括号之中，才表示连续的字符序列。 以下都是合法的字符类简写形式。 [0-9.,] [0-9a-fA-F] [a-zA-Z0-9-] [1-31] 上面代码中最后一个字符类[1-31]，不代表1到31，只代表1到3。 注意，字符类的连字符必须在头尾两个字符中间，才有特殊含义，否则就是字面含义。比如，[-9]就表示匹配连字符和9，而不是匹配0到9。 连字符还可以用来指定Unicode字符的范围。 var str = &quot;\\u0130\\u0131\\u0132&quot;; /[\\u0128-\\uFFFF]/.test(str) // true 另外，不要过分使用连字符，设定一个很大的范围，否则很可能选中意料之外的字符。最典型的例子就是[A-z]，表面上它是选中从大写的A到小写的z之间52个字母，但是由于在ASCII编码之中，大写字母与小写字母之间还有其他字符，结果就会出现意料之外的结果。 /[A-z]/.test(&#39;\\\\&#39;) // true 上面代码中，由于反斜杠（\\\\）的ASCII码在大写字母与小写字母之间，结果会被选中。 预定义模式预定义模式指的是某些常见模式的简写方式。 \\d 匹配0-9之间的任一数字，相当于[0-9]。 \\D 匹配所有0-9以外的字符，相当于[^0-9]。 \\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。 \\W 除所有字母、数字和下划线以外的字符，相当于[^A-Za-z0-9_]。 \\s 匹配空格（包括制表符、空格符、断行符等），相等于[\\t\\r\\n\\v\\f]。 \\S 匹配非空格的字符，相当于[^\\t\\r\\n\\v\\f]。 \\b 匹配词的边界。 \\B 匹配非词边界，即在词的内部。 下面是一些例子。 // \\s的例子 /\\s\\w*/.exec(&#39;hello world&#39;) // [&quot; world&quot;] // \\b的例子 /\\bworld/.test(&#39;hello world&#39;) // true /\\bworld/.test(&#39;hello-world&#39;) // true /\\bworld/.test(&#39;helloworld&#39;) // false // \\B的例子 /\\Bworld/.test(&#39;hello-world&#39;) // false /\\Bworld/.test(&#39;helloworld&#39;) // true 上面代码中，\\s表示空格，所以匹配结果会包括空格。\\b表示词的边界，所以“world”的词首必须独立（词尾是否独立未指定），才会匹配。同理，\\B表示非词的边界，只有“world”的词首不独立，才会匹配。 通常，正则表达式遇到换行符（\\n）就会停止匹配。 var html = &quot;&lt;b&gt;Hello&lt;/b&gt;\\n&lt;i&gt;world!&lt;/i&gt;&quot;; /.*/.exec(html)[0] // &quot;&lt;b&gt;Hello&lt;/b&gt;&quot; 上面代码中，字符串html包含一个换行符，结果点字符（.）不匹配换行符，导致匹配结果可能不符合原意。这时使用\\s字符类，就能包括换行符。 var html = &quot;&lt;b&gt;Hello&lt;/b&gt;\\n&lt;i&gt;world!&lt;/i&gt;&quot;; /[\\S\\s]*/.exec(html)[0] // &quot;&lt;b&gt;Hello&lt;/b&gt;\\n&lt;i&gt;world!&lt;/i&gt;&quot; // 另一种写法（用到了非捕获组） /(?:.|\\s)*/.exec(html)[0] // &quot;&lt;b&gt;Hello&lt;/b&gt;\\n&lt;i&gt;world!&lt;/i&gt;&quot; 上面代码中，[\\S\\s]指代一切字符。 重复类模式的精确匹配次数，使用大括号（{}）表示。{n}表示恰好重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。 /lo{2}k/.test(&#39;look&#39;) // true /lo{2,5}k/.test(&#39;looook&#39;) // true 上面代码中，第一个模式指定o连续出现2次，第二个模式指定o连续出现2次到5次之间。 量词符量词符用来设定某个模式出现的次数。 ? 问号表示某个模式出现0次或1次，等同于{0, 1}。 * 星号表示某个模式出现0次或多次，等同于{0,}。 + 加号表示某个模式出现1次或多次，等同于{1,}。 // t出现0次或1次 /t?est/.test(&#39;test&#39;) // true /t?est/.test(&#39;est&#39;) // true // t出现1次或多次 /t+est/.test(&#39;test&quot;) // true /t+est/.test(&#39;ttest&#39;) // true /t+est/.test(&#39;est&#39;) // false // t出现0次或多次 /t*est/.test(&#39;test&#39;) // true /t*est/.test(&#39;ttest&#39;) // true /t*est/.test(&#39;tttest&#39;) // true /t*est/.test(&#39;est&#39;) // true 贪婪模式上一小节的三个量词符，默认情况下都是最大可能匹配，即匹配直到下一个字符不满足匹配规则为止。这被称为贪婪模式。 var s = &#39;aaa&#39;; s.match(/a+/) // [&quot;aaa&quot;] 上面代码中，模式是/a+/，表示匹配1个a或多个a，那么到底会匹配几个a呢？因为默认是贪婪模式，会一直匹配到字符a不出现为止，所以匹配结果是3个a。 如果想将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号。 var s = &#39;aaa&#39;; s.match(/a+?/) // [&quot;a&quot;] 上面代码中，模式结尾添加了一个问号/a+?/，这时就改为非贪婪模式，一旦条件满足，就不再往下匹配。 除了非贪婪模式的加号，还有非贪婪模式的星号（*）。 *?：表示某个模式出现0次或多次，匹配时采用非贪婪模式。 +?：表示某个模式出现1次或多次，匹配时采用非贪婪模式。 修饰符修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。 修饰符可以单个使用，也可以多个一起使用。 // 单个修饰符 var regex = /test/i; // 多个修饰符 var regex = /test/ig; （1）g修饰符 默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。 var regex = /b/; var str = &#39;abba&#39;; regex.test(str); // true regex.test(str); // true regex.test(str); // true 上面代码中，正则模式不含g修饰符，每次都是从字符串头部开始匹配。所以，连续做了三次匹配，都返回true。 var regex = /b/g; var str = &#39;abba&#39;; regex.test(str); // true regex.test(str); // true regex.test(str); // false 上面代码中，正则模式含有g修饰符，每次都是从上一次匹配成功处，开始向后匹配。因为字符串“abba”只有两个“b”，所以前两次匹配结果为true，第三次匹配结果为false。 （2）i修饰符 默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。 /abc/.test(&#39;ABC&#39;) // false /abc/i.test(&#39;ABC&#39;) // true 上面代码表示，加了i修饰符以后，不考虑大小写，所以模式abc匹配字符串ABC。 （3）m修饰符 m修饰符表示多行模式（multiline），会修改^和$的行为。默认情况下（即不加m修饰符时），^和$匹配字符串的开始处和结尾处，加上m修饰符以后，^和$还会匹配行首和行尾，即^和$会识别换行符（\\n）。 /world$/.test(&#39;hello world\\n&#39;) // false /world$/m.test(&#39;hello world\\n&#39;) // true 上面的代码中，字符串结尾处有一个换行符。如果不加m修饰符，匹配不成功，因为字符串的结尾不是“world”；加上以后，$可以匹配行尾。 /^b/m.test(&#39;a\\nb&#39;) // true 上面代码要求匹配行首的b，如果不加m修饰符，就相当于b只能处在字符串的开始处。 组匹配（1）概述 正则表达式的括号表示分组匹配，括号中的模式可以用来匹配分组的内容。 /fred+/.test(&#39;fredd&#39;) // true /(fred)+/.test(&#39;fredfred&#39;) // true 上面代码中，第一个模式没有括号，结果+只表示重复字母d，第二个模式有括号，结果+就表示匹配“fred”这个词。 下面是另外一个分组捕获的例子。 var m = &#39;abcabc&#39;.match(/(.)b(.)/); m // [&#39;abc&#39;, &#39;a&#39;, &#39;c&#39;] 上面代码中，正则表达式/(.)b(.)/一共使用两个括号，第一个括号捕获a，第二个括号捕获c。 注意，使用组匹配时，不宜同时使用g修饰符，否则match方法不会捕获分组的内容。 var m = &#39;abcabc&#39;.match(/(.)b(.)/g); m // [&#39;abc&#39;, &#39;abc&#39;] 上面代码使用带g修饰符的正则表达式，结果match方法只捕获了匹配整个表达式的部分。 在正则表达式内部，可以用\\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。 /(.)b(.)\\1b\\2/.test(&quot;abcabc&quot;) // true 上面的代码中，\\1表示前一个括号匹配的内容（即“a”），\\2表示第二个括号匹配的内容（即“b”）。 下面是另外一个例子。 /y(..)(.)\\2\\1/.test(&#39;yabccab&#39;) // true 括号还可以嵌套。 /y((..)\\2)\\1/.test(&#39;yabababab&#39;) // true 上面代码中，\\1指向外层括号，\\2指向内层括号。 组匹配非常有用，下面是一个匹配网页标签的例子。 var tagName = /&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\\/\\1&gt;/; tagName.exec(&quot;&lt;b&gt;bold&lt;/b&gt;&quot;)[1] // &#39;b&#39; 上面代码中，圆括号匹配尖括号之中的标签，而\\1就表示对应的闭合标签。 上面代码略加修改，就能捕获带有属性的标签。 var html = &#39;&lt;b class=&quot;hello&quot;&gt;Hello&lt;/b&gt;&lt;i&gt;world&lt;/i&gt;&#39;; var tag = /&lt;(\\w+)([^&gt;]*)&gt;(.*?)&lt;\\/\\1&gt;/g; var match = tag.exec(html); match[1] // &quot;b&quot; match[2] // &quot;class=&quot;hello&quot;&quot; match[3] // &quot;Hello&quot; match = tag.exec(html); match[1] // &quot;i&quot; match[2] // &quot;&quot; match[3] // &quot;world&quot; （2）非捕获组 (?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。 非捕获组的作用请考虑这样一个场景，假定需要匹配foo或者foofoo，正则表达式就应该写成/(foo){1, 2}/，但是这样会占用一个组匹配。这时，就可以使用非捕获组，将正则表达式改为/(?:foo){1, 2}/，它的作用与前一个正则是一样的，但是不会单独输出括号内部的内容。 请看下面的例子。 var m = &#39;abc&#39;.match(/(?:.)b(.)/); m // [&quot;abc&quot;, &quot;c&quot;] 上面代码中的模式，一共使用了两个括号。其中第一个括号是非捕获组，所以最后返回的结果中没有第一个括号，只有第二个括号匹配的内容。 下面是用来分解网址的正则表达式。 // 正常匹配 var url = /(http|ftp):\\/\\/([^/\\r\\n]+)(\\/[^\\r\\n]*)?/; url.exec(&#39;http://google.com/&#39;); // [&quot;http://google.com/&quot;, &quot;http&quot;, &quot;google.com&quot;, &quot;/&quot;] // 非捕获组匹配 var url = /(?:http|ftp):\\/\\/([^/\\r\\n]+)(\\/[^\\r\\n]*)?/; url.exec(&#39;http://google.com/&#39;); // [&quot;http://google.com/&quot;, &quot;google.com&quot;, &quot;/&quot;] 上面的代码中，前一个正则表达式是正常匹配，第一个括号返回网络协议；后一个正则表达式是非捕获匹配，返回结果中不包括网络协议。 （3）先行断言 x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟着百分号的数字，可以写成/\\d+(?=%)/。 “先行断言”中，括号里的部分是不会返回的。 var m = &#39;abc&#39;.match(/b(?=c)/); m // [&quot;b&quot;] 上面的代码使用了先行断言，b在c前面所以被匹配，但是括号对应的c不会被返回。 再看一个例子。 /Jack (?=Sprat|Frost)/.test(&#39;Jack Frost&#39;) // true （4）先行否定断言 x(?!y)称为先行否定断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。比如，要匹配后面跟的不是百分号的数字，就要写成/\\d+(?!%)/。 /\\d+(?!\\.)/.exec(&#39;3.14&#39;) // [&quot;14&quot;] 上面代码中，正则表达式指定，只有不在小数点前面的数字才会被匹配，因此返回的结果就是14。 “先行否定断言”中，括号里的部分是不会返回的。 var m = &#39;abd&#39;.match(/b(?!c)/); m // [&#39;b&#39;] 上面的代码使用了先行否定断言，b不在c前面所以被匹配，而且括号对应的d不会被返回。 参考链接 Axel Rauschmayer, JavaScript: an overview of the regular expression API Mozilla Developer Network, Regular Expressions Axel Rauschmayer, The flag /g of JavaScript’s regular expressions Sam Hughes, Learn regular expressions in about 55 minutes 关于本文仅供学习交流分享，原文链接 RegExp对象，感谢阮一峰老师","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"RegExp","slug":"RegExp","permalink":"https://microzz.com/tags/RegExp/"}]},{"title":"JavaScript实现二叉树算法","date":"2017-08-22T14:03:04.000Z","path":"2017/08/22/js-binarytree/","text":"JavaScript实现二叉树算法什么是二叉树 &nbsp;&nbsp;&nbsp;在计算机科学中，二叉树（英语：Binary tree）是每个节点最多只有两个分支(不存在分支度大于2的节点)的树结构。通常分支被称作“左子树”和“右子树”。二叉树的分支具有左右次序，不能颠倒。 以上是维基百科对二叉树的简单介绍，我们可以用图片形象表示： 二叉树结构 JS来实现二叉树下面我们通过JavaScript来模拟二叉树的数据结构 /** * JavaScript实现二叉树算法 */ function BinaryTree() { // 二叉树根节点 this.root = null; // 生成二叉树节点 const Node = function(key) { this.key = key; this.left = null; this.right = null; } // 插入节点 const insertNode = function(node, newNode) { if (newNode.key &lt; node.key) { if (node.left === null) { node.left = newNode; } else { insertNode(node.left, newNode); } } else { if (node.right === null) { node.right = newNode; } else { insertNode(node.right, newNode); } } } // 实例调用的插入节点方法 this.insert = function(key) { let newNode = new Node(key); if (this.root === null) { this.root = newNode; } else { insertNode(this.root, newNode); } } } // 模拟数据 const data = [8, 3, 10, 1, 6, 14, 4, 7, 13]; // 实例化二叉树的数据结构 const binaryTree = new BinaryTree(); // 遍历数据并插入 data.forEach(item =&gt; binaryTree.insert(item)); // 打印结果 console.log(binaryTree.root); 结果 binaryTree.root 也即对应图像： 二叉树结构 以上就是用JavaScript对二叉树的简单描述。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"二叉树","slug":"二叉树","permalink":"https://microzz.com/tags/二叉树/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://microzz.com/tags/数据结构与算法/"}]},{"title":"Web安全之CSRF","date":"2017-08-19T09:02:10.000Z","path":"2017/08/19/csrf/","text":"Web安全之CSRF什么是CSRF &nbsp;&nbsp;跨站请求伪造（英语：Cross-site request forgery），也被称为 one-click attack 或者 session riding，通常缩写为 CSRF 或者 XSRF， 是一种挟制用户在当前已登录的Web应用程序上执行非本意的操作的攻击方法。跟跨网站脚本（XSS）相比，XSS 利用的是用户对指定网站的信任，CSRF 利用的是网站对用户网页浏览器的信任。简单地说，是攻击者通过一些技术手段欺骗用户的浏览器去访问一个自己曾经认证过的网站并执行一些操作（如发邮件，发消息，甚至财产操作如转账和购买商品）。由于浏览器曾经认证过，所以被访问的网站会认为是真正的用户操作而去执行。这利用了web中用户身份验证的一个漏洞：简单的身份验证只能保证请求发自某个用户的浏览器，却不能保证请求本身是用户自愿发出的。 以上是维基百科对CSRF的解释，我画一幅思维导图更好理解： CSRF攻击原理 用户通过源站点页面可以正常访问源站点服务器接口，但是也有可能被钓鱼进入伪站点来访问源服务器，如果伪站点通过第三方或用户信息拼接等方式获取到了用户的信息，直接访问源站点的服务器接口进行关键性操作（例如支付扣款或返回用户隐私信息等操作），此时如果源站点服务器未做校验防护，伪站点的请求操作就可以被成功执行。另一种情况则可能是盗刷源站点的登录等接口来暴力破解用户密码的情况，如果源站点不添加防护措施，用户信息就极可能被盗取 例子假如一家银行用以执行转账操作的URL地址如下： http://www.examplebank.com/withdraw?account=AccoutName&amp;amount=1000&amp;for=PayeeName 那么，一个恶意攻击者可以在另一个网站上放置如下代码： &lt;img src=&quot;http://www.examplebank.com/withdraw?account=Alice&amp;amount=1000&amp;for=Badman&quot;&gt; 如果有账户名为Alice的用户访问了恶意站点，而她之前刚访问过银行不久，登录信息尚未过期，那么她就会损失1000资金。这种恶意的网址可以有很多种形式，藏身于网页中的许多地方。此外，攻击者也不需要控制放置恶意网址的网站。例如他可以将这种地址藏在论坛，博客等任何用户生成内容的网站中。这意味着如果服务器端没有合适的防御措施的话，用户即使访问熟悉的可信网站也有受攻击的危险。透过例子能够看出，攻击者并不能通过CSRF攻击来直接获取用户的账户控制权，也不能直接窃取用户的任何信息。他们能做到的，是欺骗用户浏览器，让其以用户的名义执行操作。 防御措施检查Referer字段HTTP头中有一个Referer字段，这个字段用以标明请求来源于哪个地址。在处理敏感数据请求时，通常来说，Referer字段应和请求的地址位于同一域名下。以上文银行操作为例，Referer字段地址通常应该是转账按钮所在的网页地址，应该也位于www.examplebank.com之下。而如果是CSRF攻击传来的请求，Referer字段会是包含恶意网址的地址，不会位于www.examplebank.com之下，这时候服务器就能识别出恶意的访问。这种办法简单易行，工作量低，仅需要在关键访问处增加一步校验。但这种办法也有其局限性，因其完全依赖浏览器发送正确的Referer字段。虽然http协议对此字段的内容有明确的规定，但并无法保证来访的浏览器的具体实现，亦无法保证浏览器没有安全漏洞影响到此字段。并且也存在攻击者攻击某些浏览器，篡改其Referer字段的可能。 添加校验token由于CSRF的本质在于攻击者欺骗用户去访问自己设置的地址，所以如果要求在访问敏感数据请求时，要求用户浏览器提供不保存在cookie中，并且攻击者无法伪造的数据作为校验，那么攻击者就无法再执行CSRF攻击。这种数据通常是表单中的一个数据项。服务器将其生成并附加在表单中，其内容是一个伪乱数。当客户端通过表单提交请求时，这个伪乱数也一并提交上去以供校验。正常的访问时，客户端浏览器能够正确得到并传回这个伪乱数，而通过CSRF传来的欺骗性攻击中，攻击者无从事先得知这个伪乱数的值，服务器端就会因为校验token的值为空或者错误，拒绝这个可疑请求。 我们在源站点服务请求调用时添加了对源站点的验证，使用服务器端实时返回加密的验证 Token给源站点页面，在源站点页面提交时将 Token一起带给服务器验证，而Token是不会被其他伪站点利用的。而非法的伪站点和盗刷的行为就可以被直接拒绝掉，这样就大大降低了CSRF发生的概率。所以在Web后端，我们常常会进行 Token的验证，其中一种形式是将页面提交到后台的验证 Token与 session临时保存的 Token进行比较就可以来实现了。 //生成随机的csrf验证 Token，并返回给前端页面 this.session.csrf = md5(math.random(0, 1).tostring().slice(5, 15); this.body = yield render(&#39;user/login&#39;, { csrf: ctx.session.csrf }); //提交时验证 Token是否与源站的 Token相同 let csrf = this.request.body[&#39;csrf&#39;]; if (csrf !== this.session.csrf) { res = { code: 403, msg: &#39;不明网站来源提交&#39; } } else { // 正常提交后的逻辑 } 再用思维导图表示一下： CSRF 目前解决CSRF的最佳方式就是通过加密计算的 Token验证，而 Token除了通过 session也可以使用HTTP请求头中 Authorization的特定认证字段来传递。当然并不是说使用了Token，网站调用服务就安全了，单纯的 Token验证防止CSRF的方式理论上也是可以被破解的，例如可以通过域名伪造和拉取源站实时 Token信息的方式来进行提交。另外，任何所谓的安全都是相对的，只是说理论的破解时间变长了，而不容易被攻击。很多时候要使用多种方法结合的方式来一起增加网站的安全性，可以结合验证码等手段大大减少盗刷网站用尸信息的频率等，进一步增强网站内容的安全性。 参考资料跨站请求伪造《现代前端技术解析》","tags":[{"name":"CSRF","slug":"CSRF","permalink":"https://microzz.com/tags/CSRF/"},{"name":"XSS","slug":"XSS","permalink":"https://microzz.com/tags/XSS/"},{"name":"Web安全","slug":"Web安全","permalink":"https://microzz.com/tags/Web安全/"}]},{"title":"Web安全之XSS","date":"2017-08-17T14:27:41.000Z","path":"2017/08/17/xss/","text":"XSS跨站脚本攻击概念 &nbsp;&nbsp;&nbsp;&nbsp;跨站脚本（Cross-site scripting，通常简称为：XSS）是一种网站应用程序的安全漏洞攻击，是代码注入的一种。它允许恶意用户将代码注入到网页上，其他用户在观看网页时就会受到影响。这类攻击通常包含了HTML以及用户端脚本语言。XSS攻击通常指的是通过利用网页开发时留下的漏洞，通过巧妙的方法注入恶意指令代码到网页，使用户加载并执行攻击者恶意制造的网页程序。这些恶意网页程序通常是JavaScript，但实际上也可以包括Java，VBScript，ActiveX，Flash或者甚至是普通的HTML。攻击成功后，攻击者可能得到更高的权限（如执行一些操作）、私密网页内容、会话和cookie等各种内容。 以上是维基百科对XSS的解释，XSS在Web安全中非常常见，也是我们应该引起重视的。下面就详细进行一下介绍。 分类XSS通常可以分为两大类： 反射型XSS发出请求时，XSS代码出现在URL中，作为输入提交到服务端，服务端解析后响应，XSS代码随响应内容一起传回浏览器，最后浏览器解析执行XSS代码。这个过程像一次反射，故叫反射性XSS。 代码演示反射型XSS为了方便实验，我选用了Koa2做后端，模版使用Ejs。 我们对一个路由做如下处理： router.get(&#39;/&#39;, async (ctx, next) =&gt; { ctx.set(&#39;X-XSS-Protection&#39;, 0); await ctx.render(&#39;index&#39;, { title: &#39;XSS攻击示例&#39;, xss: ctx.request.query.xss }) }) 我们需要注意代码中还额外设置了一个headerctx.set(&#39;X-XSS-Protection&#39;, 0);因为很多现在很多现代浏览器都有xss的拦截措施进行保护。如果没有设置的话会有如下结果： XSS 打开控制台就会有报错信息： XSS &lt;!-- index.ejs 首页模版页 --&gt; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel=&#39;stylesheet&#39; href=&#39;/stylesheets/style.css&#39; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;div&gt;&lt;%- xss %&gt;&lt;/div&gt; &lt;/body&gt; &lt;/html&gt; (注意：写成&lt;%= xss %&gt;就不会有效果了，为了演示需要写成&lt;%- xss %&gt;) 正常的显示是这样的： XSS 用户输入一些恶意代码的时候就会出现下面的情况,比如通过img标签的onerror事件获取cookie XSS获取cookie 加载一些非同源js： XSS 打开网络面板和控制台，发现成功加载了jQuery，如果是其他恶意的脚本后果很严重。 XSS 嵌入一个iframe插入各种广告或者其他恶意站点 XSS 存储型XSS存储型XSS和反射型XSS差别仅在于提交的代码会存储在服务器端(数据库，内存，文件系统等)，下次请求目标页面时不用再提交XSS代码 下面通过一个图说明 XSS 代码演示存储型XSS 前端 前端展示是一个多行文本框，然后支持评论和获取评论的输入框，如下图： XSS 代码部分(为了使演示更方便，有些地方没有考虑兼容性) &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;&lt;%= title %&gt;&lt;/title&gt; &lt;link rel=&#39;stylesheet&#39; href=&#39;/stylesheets/style.css&#39; /&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;&lt;%= title %&gt;&lt;/h1&gt; &lt;div&gt; &lt;textarea name=&quot;name&quot; rows=&quot;8&quot; cols=&quot;80&quot;&gt; &lt;p&gt;microzz.com&lt;/p&gt; &lt;img src=&quot;null&quot; alt=&quot;无法正常显示图片&quot; onerror=&quot;alert(&#39;onerror&#39;)&quot;&gt; &lt;button onclick=&quot;alert(&#39;中奖啦&#39;)&quot;&gt;去抽奖&lt;/button&gt; &lt;/textarea&gt; &lt;button id=&quot;comment&quot;&gt;评论&lt;/button&gt; &lt;button id=&quot;get&quot;&gt;获取评论&lt;/button&gt; &lt;div&gt; &lt;script&gt; const oTextArea = document.querySelector(&#39;textarea&#39;); const oCommentBtn = document.querySelector(&#39;#comment&#39;); const oGetBtn = document.querySelector(&#39;#get&#39;); oGetBtn.addEventListener(&#39;click&#39;, () =&gt; { fetch(&#39;/get&#39;) .then(result =&gt; result.json()) .then(data =&gt; { let oP = document.createElement(&#39;p&#39;); oP.innerHTML = data.comment; document.body.appendChild(oP); }) }); oCommentBtn.addEventListener(&#39;click&#39;, () =&gt; { fetch(`/comment?comment=${oTextArea.value}`) }) &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 服务端 为了使演示方便并没有使用数据库，这里使用Object来模拟代替，路由部分如下： const router = require(&#39;koa-router&#39;)() const db = { comment: &#39;&#39; }; router.get(&#39;/get&#39;, async (ctx, next) =&gt; { ctx.body = { comment: db.comment } }) router.get(&#39;/comment&#39;, async (ctx, next) =&gt; { db.comment = ctx.request.query.comment; ctx.body = { msg: &#39;ok&#39; } }) 我们看一下评论后获取评论的效果： XSS 诱导是用户点击： XSS 不同分类XSS攻击从攻击的方式可以分为 反射型 存储型 文档型(MXSS, 也叫DOM XSS) 这种分类方式有些过时，长久以来，人们认为XSS分类有以上三种，但实际情况中经常无法区分，所以更明确的分类方式可以分为以下两类： client(客户端型) server(服务端型) 当一端xss代码是在服务端被插入的，那么这就是服务端型xss，同理，如果代码在客户端插入，就是客户端型xss。 防御措施 编码 过滤 校正 CSP 编码对用户输入的数据进行HTML Entity编码 HTML 具体可以查阅 👉 https://dev.w3.org/html5/html-author/charref 比如我们可以写一个简单的方法： // 对用户的提交进行编码 function htmlEncode(str) { return str .replace(/&amp;/g, &#39;&amp;amp;&#39;) .replace(/&lt;/g, &#39;&amp;lt;&#39;) .replace(/&gt;/g, &#39;&amp;gt;&#39;) .replace(/ /g, &#39;&amp;nbsp;&#39;) .replace(/\\&#39;/g, &#39;&amp;#39;&#39;) .replace(/\\&quot;/g, &#39;&amp;quot;&#39;) .replace(/\\n/g, &#39;&lt;br&gt;&#39;); } 我们对上面的路由进行一下改造： router.get(&#39;/comment&#39;, async (ctx, next) =&gt; { db.comment = htmlEncode(ctx.request.query.comment); ctx.body = { msg: &#39;ok&#39; } }) 此时页面就显示正常的内容了 XSS 过滤 移除用户上传的DOM属性，如onerror(onerror事件可以执行js代码)、click等事件 移除用户上传的Link、Style节点(可以利用!important重置页面样式，比如: body{display: none)}、Script节点(执行js代码，加载非同源js)、Iframe节点(插入恶意页面或者广告)等 校正 避免直接对HTML Entity解码，否则编码意义不大了 使用DOM Parse转换，校正不配对的DOM标签 CSP内容安全策略(CSP)是一个额外的安全层，有助于检测和减轻某些类型的攻击，包括跨站脚本 (XSS) 和数据注入攻击。这些攻击用于从数据窃取到现场污染或恶意软件分发的一切。 CSP 的实质就是白名单制度，开发者明确告诉客户端，哪些外部资源可以加载和执行，等同于提供白名单。它的实现和执行全部由浏览器完成，开发者只需提供配置。CSP 大大增强了网页的安全性。攻击者即使发现了漏洞，也没法注入脚本，除非还控制了一台列入了白名单的可信主机。 启用方法 HTTP 头信息Content-Security-Policy 我们改造一下前面加载非同源的jQuery脚本的代码，后端路由进行这样的改造： router.get(&#39;/&#39;, async (ctx, next) =&gt; { ctx.set(&#39;X-XSS-Protection&#39;, 0); ctx.set(&#39;Content-Security-Policy&#39;, `default-src &#39;self&#39;`) await ctx.render(&#39;index&#39;, { title: &#39;XSS攻击示例&#39;, xss: ctx.request.query.xss }) }) 此时默认只允许加载本站的脚本，看一下网络请求，响应头上多了Content-Security-Policy: default-src &#39;self&#39;表示一个网站管理者想要所有内容均来自站点自己 (这排除子域名.) XSS 此时控制台也会报错 XSS 通过网页的标签也可以开启&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;script-src &#39;self&#39;; object-src &#39;none&#39;; style-src cdn.example.org third-party.org; child-src https:&quot;&gt; 上面代码中，CSP 做了如下配置： &lt;object&gt;标签：不信任任何URL，即不加载任何资源 样式表：只信任cdn.example.org和third-party.org 框架（frame）：必须使用HTTPS协议加载 其他资源：没有限制 启用后，不符合 CSP 的外部资源就会被阻止加载。 资源加载限制default-src 指令定义了那些没有被更精确指令指定的（默认）安全策略。该指令包含了以下指令： script-src：外部脚本 style-src：样式表 img-src：图像 media-src：媒体文件（音频和视频） font-src：字体文件 object-src：插件（比如 Flash） child-src：框架 frame-ancestors：嵌入的外部资源（比如&lt;frame&gt;、&lt;iframe&gt;、&lt;embed&gt;和&lt;applet&gt;） connect-src：HTTP 连接（通过 XHR、WebSockets、EventSource等） worker-src：worker脚本 manifest-src：manifest 文件 详细可以参考MDN 👉 https://developer.mozilla.org/zh-CN/docs/Web/Security/CSP/CSP_policy_directives 注意点（1）script-src和object-src是必设的，除非设置了default-src。因为攻击者只要能注入脚本，其他限制都可以规避。而object-src必设是因为 Flash 里面可以执行外部脚本。（2）script-src不能使用unsafe-inline关键字（除非伴随一个nonce值），也不能允许设置data:URL。下面是两个恶意攻击的例子。 ``` （3）必须特别注意 JSONP 的回调函数。 上面的代码中，虽然加载的脚本来自当前域名，但是通过改写回调函数，攻击者依然可以执行恶意代码。 #### 缺陷 * 日志不详细：上报的只有违规的站点名没有具体路径 * 规则不灵活：CSP 目前只支持白名单列表 * 无法和页面交互 * 上报方式不可控：只能使用 POST + JSON 的方式提交，无法设定一个缓存时间，控制重复上报的间隔 * 浪费带宽 * 维护繁琐 * 兼容性不高 ### X-Frame-Options 这是response头个现在正在使用，但以后可以被CSP的 frame-ancestors取代。目前支持的状态比起 CSP frame-ancestors要好 使用的方式: X-Frame-Options:DENY//这个页面不允许被以frame的方式加载X-Frame-Options:SAMEORIGIN//这个页面只允许同源页面加载X-Frame-Options: //这个页面只能被特定的域加载``` 谷歌在这点就做的比较好： XSS Http-Only使用http-only 保护cookie，可以保证即使发生了xss，用户的cookie也是安全的。使用http-only 保护的cookie是不会被javascript读写的。 其他我们还可以使用一些成熟流行的开源库来对数据进行处理，增强安全性，防范XSS攻击。 未完待续防范XSS攻击是一个持久艰巨的任务，即使是一线互联网公司也会遭遇此类攻击。只有在每一个步骤都时刻注意，才能很好避免此类事件。 参考链接CSP 策略指令Content Security Policy 入门教程【XSS】利用 onload 事件监控流量劫持","tags":[{"name":"CSRF","slug":"CSRF","permalink":"https://microzz.com/tags/CSRF/"},{"name":"XSS","slug":"XSS","permalink":"https://microzz.com/tags/XSS/"},{"name":"Web安全","slug":"Web安全","permalink":"https://microzz.com/tags/Web安全/"},{"name":"跨站脚本攻击","slug":"跨站脚本攻击","permalink":"https://microzz.com/tags/跨站脚本攻击/"}]},{"title":"用JS实现链表的数据结构","date":"2017-08-01T11:04:29.000Z","path":"2017/08/01/js-link/","text":"用JavaScript实现链表的数据结构 &nbsp;&nbsp;&nbsp;&nbsp;链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer) &nbsp;&nbsp;— 维基百科 上面是维基百科对链表的解读。下面我们用JavaScript代码对链表的数据结构进行实现 实现Node类表示节点/** * Node 类用来表示节点 * element 用来保存节点上的数据 * next 用来保存指向下一个节点的链接 */ function Node(element) { this.element = element; this.next = null; } LList类提供对链表操作的方法/** * LList 类提供了对链表进行操作的方法 * 链表只有一个属性， * 使用一个 Node 对象来保存该链表的头节点。 */ class LList { constructor() { this.head = new Node(&#39;head&#39;); } // 查找节点 find(item) { let currNode = this.head; while(currNode.element !== item) { currNode = currNode.next; } return currNode; } // 查找前一个节点 findPre(item) { if(item === &#39;head&#39;) throw new Error(&#39;now is head!&#39;); let currNode = this.head; while (currNode.next &amp;&amp; currNode.next.element !== item) { currNode = currNode.next; } return currNode; } // 插入新节点 insert(newElement, item) { let newNode = new Node(newElement); let currNode = this.find(item); newNode.next = currNode.next; currNode.next = newNode; } // 删除一个节点 remove(item) { let preNode = this.findPre(item); if(preNode.next !== null) { preNode.next = preNode.next.next; } } // 显示链表中的元素 display() { let currNode = this.head; while(currNode.next !== null) { console.log(currNode.next.element); currNode = currNode.next; } } } 测试代码const list = new LList(); // LList { head: Node { element: &#39;head&#39;, next: null } } list.insert(&#39;0&#39;, &#39;head&#39;); list.insert(&#39;1&#39;, &#39;0&#39;); list.insert(&#39;2&#39;, &#39;1&#39;); list.insert(&#39;3&#39;, &#39;2&#39;); list.remove(&#39;1&#39;); console.log(list); // LList { head: Node { element: &#39;head&#39;, next: Node { element: &#39;0&#39;, next: [Object] } } } console.log(list.display()); // 0 2 3 console.log(list.findPre(&#39;1&#39;)); // Node { element: &#39;0&#39;, next: Node { element: &#39;1&#39;, next: Node { element: &#39;2&#39;, next: [Object] } } } 上面就是用JavaScript对简单链表的数据结构的简单实现😄","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://microzz.com/tags/数据结构与算法/"},{"name":"链表","slug":"链表","permalink":"https://microzz.com/tags/链表/"}]},{"title":"用JS实现栈的数据结构","date":"2017-07-31T11:04:29.000Z","path":"2017/07/31/js-stack/","text":"用JavaScript实现栈的数据结构 &nbsp;&nbsp;&nbsp;&nbsp;堆栈（英语：stack），也可直接称栈，在计算机科学中，是一种特殊的串列形式的数据结构，它的特殊之处在于只能允许在链接串列或阵列的一端（称为堆叠顶端指标，英语：top）进行加入数据（push）和输出数据（pop）的运算。另外栈也可以用一维数组或连结串列的形式来完成。&nbsp;&nbsp;&nbsp;&nbsp;由于堆叠数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作。 – 维基百科 上面是维基百科对栈的解读。下面我们用JavaScript(ES6)代码对栈的数据结构进行实现 实现一个Stack类/** * Stack 类 */ class Stack { constructor() { this.data = []; // 对数据初始化 this.top = 0; // 初始化栈顶位置 } // 入栈方法 push() { const args = [...arguments]; args.forEach(arg =&gt; this.data[this.top++] = arg); return this.top; } // 出栈方法 pop() { if (this.top === 0) throw new Error(&#39;The stack is already empty!&#39;); const peek = this.data[--this.top]; this.data = this.data.slice(0, -1); return peek; } // 返回栈顶元素 peek() { return this.data[this.top - 1]; } // 返回栈内元素个数 length() { return this.top; } // 清除栈内所有元素 clear() { this.top = 0; return this.data = []; } // 判断栈是否为空 isEmpty() { return this.top === 0; } } // 实例化 const stack = new Stack(); stack.push(1); stack.push(2, 3); console.log(stack.data); // [1, 2, 3] console.log(stack.peek()); // 3 console.log(stack.pop()); // 3, now data is [1, 2] stack.push(3); console.log(stack.length()); // 3 stack.clear(); // now data is [] 用栈的思想将数字转换为二进制和八进制/** * 将数字转换为二进制和八进制 */ const numConvert = (num, base) =&gt; { const stack = new Stack(); let converted = &#39;&#39;; while(num &gt; 0) { stack.push(num % base); num = Math.floor(num / base); } while(stack.length() &gt; 0) { converted += stack.pop(); } return +converted; } console.log(numConvert(10, 2)); // 1010 用栈的思想判断给定字符串或者数字是否是回文/** * 判断给定字符串或者数字是否是回文 */ const isPalindrome = words =&gt; { const stack = new Stack(); let wordsCopy = &#39;&#39;; words = words.toString(); Array.prototype.forEach.call(words, word =&gt; stack.push(word)); while(stack.length() &gt; 0) { wordsCopy += stack.pop(); } return words === wordsCopy; } console.log(isPalindrome(&#39;1a121a1&#39;)); // true console.log(isPalindrome(2121)); // false 上面就是用JavaScript对栈的数据结构的实现，有些算法可能欠妥，但是仅仅是为了演示JS对栈的实现😄","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://microzz.com/tags/数据结构与算法/"},{"name":"栈","slug":"栈","permalink":"https://microzz.com/tags/栈/"}]},{"title":"JavaScript 内存泄露教程","date":"2017-05-25T13:26:23.000Z","path":"2017/05/25/memory-leak/","text":"JavaScript 内存泄露教程一、什么是内存泄露？程序的运行需要内存。只要程序提出要求，操作系统或者运行时（runtime）就必须供给内存。 对于持续运行的服务进程（daemon），必须及时释放不再用到的内存。否则，内存占用越来越高，轻则影响系统性能，重则导致进程崩溃。 不再用到的内存，没有及时释放，就叫做内存泄露（memory leak）。 有些语言（比如 C 语言）必须手动释放内存，程序员负责内存管理。 char * buffer; buffer = (char*) malloc(42); // Do something with buffer free(buffer); 上面是 C 语言代码，malloc方法用来申请内存，使用完毕之后，必须自己用free方法释放内存。 这很麻烦，所以大多数语言提供自动内存管理，减轻程序员的负担，这被称为“垃圾回收机制”（garbage collector）。 二、垃圾回收机制垃圾回收机制怎么知道，哪些内存不再需要呢？ 最常使用的方法叫做“引用计数”（reference counting）：语言引擎有一张“引用表”，保存了内存里面所有的资源（通常是各种值）的引用次数。如果一个值的引用次数是0，就表示这个值不再用到了，因此可以将这块内存释放。 上图中，左下角的两个值，没有任何引用，所以可以释放。 如果一个值不再需要了，引用数却不为0，垃圾回收机制无法释放这块内存，从而导致内存泄露。 const arr = [1, 2, 3, 4]; console.log(&#39;hello world&#39;); 上面代码中，数组[1, 2, 3, 4]是一个值，会占用内存。变量arr是仅有的对这个值的引用，因此引用次数为1。尽管后面的代码没有用到arr，它还是会持续占用内存。 如果增加一行代码，解除arr对[1, 2, 3, 4]引用，这块内存就可以被垃圾回收机制释放了。 const arr = [1, 2, 3, 4]; console.log(&#39;hello world&#39;); arr = null; 上面代码中，arr重置为null，就解除了对[1, 2, 3, 4]的引用，引用次数变成了0，内存就可以释放出来了。 因此，并不是说有了垃圾回收机制，程序员就轻松了。你还是需要关注内存占用：那些很占空间的值，一旦不再用到，你必须检查是否还存在对它们的引用。如果是的话，就必须手动解除引用。 三、内存泄露的识别方法怎样可以观察到内存泄露呢？ 经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄露。这就要求实时查看内存占用。 3.1 浏览器Chrome 浏览器查看内存占用，按照以下步骤操作。 打开开发者工具，选择 Timeline 面板 在顶部的Capture字段里面勾选 Memory 点击左上角的录制按钮。 在页面上进行各种操作，模拟用户的使用情况。 一段时间后，点击对话框的 stop 按钮，面板上就会显示这段时间的内存占用情况。 如果内存占用基本平稳，接近水平，就说明不存在内存泄露。 反之，就是内存泄露了。 3.2 命令行命令行可以使用 Node 提供的process.memoryUsage方法。 console.log(process.memoryUsage()); // { rss: 27709440, // heapTotal: 5685248, // heapUsed: 3449392, // external: 8772 } process.memoryUsage返回一个对象，包含了 Node 进程的内存占用信息。该对象包含四个字段，单位是字节，含义如下。 rss（resident set size）：所有内存占用，包括指令区和堆栈。 heapTotal：“堆”占用的内存，包括用到的和没用到的。 heapUsed：用到的堆的部分。 external： V8 引擎内部的 C++ 对象占用的内存。 判断内存泄露，以heapUsed字段为准。 四、WeakMap前面说过，及时清除引用非常重要。但是，你不可能记得那么多，有时候一疏忽就忘了，所以才有那么多内存泄露。 最好能有一种方法，在新建引用的时候就声明，哪些引用必须手动清除，哪些引用可以忽略不计，当其他引用消失以后，垃圾回收机制就可以释放内存。这样就能大大减轻程序员的负担，你只要清除主要引用就可以了。 ES6 考虑到了这一点，推出了两种新的数据结构：WeakSet 和 WeakMap。它们对于值的引用都是不计入垃圾回收机制的，所以名字里面才会有一个“Weak”，表示这是弱引用。 下面以 WeakMap 为例，看看它是怎么解决内存泄露的。 const wm = new WeakMap(); const element = document.getElementById(&#39;example&#39;); wm.set(element, &#39;some information&#39;); wm.get(element) // &quot;some information&quot; 上面代码中，先新建一个 Weakmap 实例。然后，将一个 DOM 节点作为键名存入该实例，并将一些附加信息作为键值，一起存放在 WeakMap 里面。这时，WeakMap 里面对element的引用就是弱引用，不会被计入垃圾回收机制。 也就是说，DOM 节点对象的引用计数是1，而不是2。这时，一旦消除对该节点的引用，它占用的内存就会被垃圾回收机制释放。Weakmap 保存的这个键值对，也会自动消失。 基本上，如果你要往对象上添加数据，又不想干扰垃圾回收机制，就可以使用 WeakMap。 五、WeakMap 示例WeakMap 的例子很难演示，因为无法观察它里面的引用会自动消失。此时，其他引用都解除了，已经没有引用指向 WeakMap 的键名了，导致无法证实那个键名是不是存在。 我一直想不出办法，直到有一天贺师俊老师提示，如果引用所指向的值占用特别多的内存，就可以通过process.memoryUsage方法看出来。 根据这个思路，网友 vtxf 补充了下面的例子。 首先，打开 Node 命令行。 $ node --expose-gc 上面代码中，--expose-gc参数表示允许手动执行垃圾回收机制。 然后，执行下面的代码。 // 手动执行一次垃圾回收，保证获取的内存使用状态准确 &gt; global.gc(); undefined // 查看内存占用的初始状态，heapUsed 为 4M 左右 &gt; process.memoryUsage(); { rss: 21106688, heapTotal: 7376896, heapUsed: 4153936, external: 9059 } &gt; const wm = new WeakMap(); undefined &gt; const b = new Object(); undefined &gt; global.gc(); undefined // 此时，heapUsed 仍然为 4M 左右 &gt; process.memoryUsage(); { rss: 20537344, heapTotal: 9474048, heapUsed: 3967272, external: 8993 } // 在 WeakMap 中添加一个键值对， // 键名为对象 b，键值为一个 5*1024*1024 的数组 &gt; wm.set(b, new Array(5*1024*1024)); WeakMap {} // 手动执行一次垃圾回收 &gt; global.gc(); undefined // 此时，heapUsed 为 45M 左右 &gt; process.memoryUsage(); { rss: 62652416, heapTotal: 51437568, heapUsed: 45911664, external: 8951 } // 解除对象 b 的引用 &gt; b = null; null // 再次执行垃圾回收 &gt; global.gc(); undefined // 解除 b 的引用以后，heapUsed 变回 4M 左右 // 说明 WeakMap 中的那个长度为 5*1024*1024 的数组被销毁了 &gt; process.memoryUsage(); { rss: 20639744, heapTotal: 8425472, heapUsed: 3979792, external: 8956 } 上面代码中，只要外部的引用消失，WeakMap 内部的引用，就会自动被垃圾回收清除。由此可见，有了它的帮助，解决内存泄露就会简单很多。 六、参考链接 Simple Guide to Finding a JavaScript Memory Leak in Node.js Understanding Garbage Collection and hunting Memory Leaks in Node.js Debugging Memory Leaks in Node.js Applications （完） 关于本文仅供学习交流分享，原文链接 JavaScript 内存泄漏教程，感谢阮一峰老师","tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://microzz.com/tags/性能优化/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"}]},{"title":"JS正则表达式之前瞻","date":"2017-05-22T14:08:21.000Z","path":"2017/05/22/reg-lookahead/","text":"JavaScript正则表达式之前瞻概念&nbsp;&nbsp;&nbsp;&nbsp;正则表达式从文本头部向尾部开始解析，文本尾部称为“前”。&nbsp;&nbsp;&nbsp;&nbsp;前瞻就是在正则表达式匹配到规则的时候，向前检查是否符合断言。后顾/后瞻方向相反。 exp(?=assert)：正向前瞻exp(?!assert)：负向前瞻exp(?&lt;=assert)：正向后顾 exp(?&lt;!assert)：负向后顾 *JS不支持后顾。 示例// 判断一个单词字符之后是否是数字（正向前瞻）， // 是的话，则符合匹配，进行替换 var str = &quot;a2*3&quot;; var reg = /\\w(?=\\d)/g; str.replace(reg,&quot;X&quot;); //&#39;X2*3&#39; //判断一个单词字符之后是否是非数字（负向前瞻）， // 是的话，则符合匹配，进行替换 var str = &quot;a2*3&quot;; var reg = /\\w(?!\\d)/g; str.replace(reg,&quot;X&quot;); // &#39;aX*X&#39; AboutGitHub: 👉https://github.com/microzz个人网站: 👉https://microzz.com/","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"RegExp","slug":"RegExp","permalink":"https://microzz.com/tags/RegExp/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://microzz.com/tags/正则表达式/"}]},{"title":"Redis命令大全","date":"2017-05-20T12:47:52.000Z","path":"2017/05/20/redis/","text":"Redis命令大全Redis介绍&nbsp;&nbsp;&nbsp;&nbsp;Redis是一个key-value存储系统。和Memcached类似，它支持存储的value类型相对更多，包括string(字符串)、list(链表)、set(集合)、zset(sorted set –有序集合)和hash（哈希类型）。这些数据类型都支持push/pop、add/remove及取交集并集和差集及更丰富的操作，而且这些操作都是原子性的。在此基础上，redis支持各种不同方式的排序。与memcached一样，为了保证效率，数据都是缓存在内存中。区别的是redis会周期性的把更新的数据写入磁盘或者把修改操作写入追加的记录文件，并且在此基础上实现了master-slave(主从)同步。&nbsp;&nbsp;&nbsp;&nbsp;Redis 是一个高性能的key-value数据库。 redis的出现，很大程度补偿了memcached这类key/value存储的不足，在部 分场合可以对关系数据库起到很好的补充作用。它提供了Java，C/C++，C#，PHP，JavaScript，Perl，Object-C，Python，Ruby，Erlang等客户端，使用很方便。 导航Strings get | set | del Lists rpush | lrange | lindex | lpop Sets sadd | smembers | sismember | srem Hashes hset | hget | hgetall | hdel Sorted sets zadd | zrange | zrangebyscore | szrem | zrevrank | zrevrange Other Commandssort publish/subscribesubscribe | unsubscribe | publish |psubscribe | punsubscribe expiring keyspersist | ttl | expire | expireat |pttl | pexpire | pexpireat 字符串(Strings) Get key-name - 获取存储在给定键中的值 Set key-name - 获取存储在给定键中的值 Del key-name - 删除存储在给定键中的值（适用于所有类型） 列表(Lists) RPush list-key item - 将给定值推入列表的右端 LRange list-key start stop - 获取列表在给定范围上的所有值 LIndex list-key index - 获取列表在给定位置上的单个元素 LPop list-key - 从列表的左端pop出一个值，并返回该值 集合(Sets) sadd set-key item - 将给定元素item添加到集合（返回0表示元素已存在于集合中，1表示添加成功） smembers set-key - 返回集合中的所有元素 sismember set-key item - 检查给定元素item是否存在于集合中 srem set-key item - 如果item存在于集合中，移除该元素（返回移除元素的数量） 散列(Hashes) hset hash-key sub-key value - 在散列中设置给定的键值对 hget hash-key sub-key - 在散列中获取指定键的值 hgetall hash-key - 获取散列中所有的键值对 hdel hash-key sub-key - 移除散列中的给定键（存在返回1，不存在返回0） 有序集合(Sorted Sets) zadd zset-key score member - 将一个带有给定分值的成员添加到有序集合中 zrange zset-key start stop [withscores] - 根据元素在有序集合中所处的位置，从有序集合里面获取多个元素 zrangebyscore zset-key start stop [withscores] - 获取有序集合在给定分值范围内的所有元素 zrem zset-key member - 在有序集合中移除给定成员（存在返回1，不存在返回0） zrevrank zset-key member - 返回有序集合成员 member的排名，成员按照分值从大到小排列 zrevrange zset-key start stop [withscores] - 返回有序集合给定排名范围内的成员，成员按照分值从大到小排列 其他命令(Other Commands) sort source-key [BY pattern] [Limit offset count] [Get pattern [Get pattern ...]] [Asc|Desc] [Alpha] [Store dest-key] - 根据给定的选项，对输入的列表、集合或者有序集合进行排序，返回或存储排序的结果发布/订阅(publish/subscribe) subscribe channel [channel ...] - 订阅给定的频道（一个或多个） unsubscribe [channel [channel ...]] - 退订给定的频道，如果没有给定频道，将退订所有频道 publish channel message - 向给定频道发送消息 psubscribe pattern [pattern ...] - 订阅给定模式匹配的频道 punsubscribe [pattern [pattern ...]] - 退订给定pattern匹配的所有模式，如果没有给定模式，将退订所有模式过期时间(expiring keys) persist key-name - 移除键的过期时间 ttl key-name - 查看给定键距离过期还有多少秒 expire key-name seconds - 让指定键在给定秒数后过期 expireat key-name timestamp - 将给定的过期时间设置为给定的Unix时间戳 pttl key-name - 查看给定键距离过期还有多少毫秒(version &gt;= 2.6) pexpire key-name milliseconds - 让指定键在给定毫秒数后过期(version &gt;= 2.6) pexpireat key-name timestamp-milliseconds - 将给定的过期时间设置为给定的毫秒级精度的Unix时间戳(version &gt;= 2.6) AboutGitHub: 👉https://github.com/microzz个人网站: 👉https://microzz.com/","tags":[{"name":"Redis","slug":"Redis","permalink":"https://microzz.com/tags/Redis/"},{"name":"数据库","slug":"数据库","permalink":"https://microzz.com/tags/数据库/"},{"name":"命令","slug":"命令","permalink":"https://microzz.com/tags/命令/"}]},{"title":"JS中的函数节流和函数防抖","date":"2017-05-18T14:35:44.000Z","path":"2017/05/18/throttle-debounce/","text":"JavaScript中的函数节流和函数防抖函数节流指让函数有规律的进行调用，应用场景：window.resize，游戏中子弹发射(1s只能发射一颗子弹)等； 函数防抖让函数在”调用’’之后的一段时间后生效，应用场景:输入框(例：在用户停止输入的500ms后再处理用户数据)。 //函数节流 /* * @params {Function} fun 调用函数 * @params {delay} number 延迟时间 */ const throttle = (fun, delay, ...rest) =&gt; { let last = null; return () =&gt; { const now = + new Date(); if (now - last &gt; delay) { fun(rest); last = now; } } } //实例 const throttleExample = throttle(() =&gt; console.log(1), 1000); //调用 throttleExample(); throttleExample(); throttleExample(); //函数防抖 const debouce = (fun, delay, ...rest) =&gt; { let timer = null; return () =&gt; { clearTimeout(timer); timer = setTimeout(() =&gt; { fun(rest); }, delay); } } //实例 const debouceExample = debouce(() =&gt; console.log(1), 1000); //调用 debouceExample(); debouceExample(); debouceExample(); AboutGitHub: 👉https://github.com/microzz","tags":[{"name":"throttle","slug":"throttle","permalink":"https://microzz.com/tags/throttle/"},{"name":"debounce","slug":"debounce","permalink":"https://microzz.com/tags/debounce/"},{"name":"函数节流","slug":"函数节流","permalink":"https://microzz.com/tags/函数节流/"},{"name":"函数防抖","slug":"函数防抖","permalink":"https://microzz.com/tags/函数防抖/"}]},{"title":"Redis配置认证密码","date":"2017-05-15T14:32:28.000Z","path":"2017/05/15/redispass/","text":"Redis配置认证密码通过配置文件进行配置yum方式安装的redis配置文件通常在/etc/redis.conf中，打开配置文件找到 #requirepass foobared去掉行前的注释，并修改密码为所需的密码,保存文件requirepass myRedis重启redis sudo service redis restart sudo service redis stop sudo redis-server /etc/redis.conf 这个时候尝试登录redis，发现可以登上，但是执行具体命令是提示操作不允许 redis-cli -h 127.0.0.1 -p 6379 redis 127.0.0.1:6379&gt; redis 127.0.0.1:6379&gt; keys * (error) ERR operation not permitted redis 127.0.0.1:6379&gt; select 1 (error) ERR operation not permitted redis 127.0.0.1:6379[1]&gt; 尝试用密码登录并执行具体的命令看到可以成功执行 redis-cli -h 127.0.0.1 -p 6379 -a myRedis redis 127.0.0.1:6379&gt; keys * 1) &quot;myset&quot; 2) &quot;mysortset&quot; redis 127.0.0.1:6379&gt; select 1 OK redis 127.0.0.1:6379[1]&gt; config get requirepass 1) &quot;requirepass&quot; 2) &quot;myRedis&quot; 通过命令行进行配置redis 127.0.0.1:6379[1]&gt; config set requirepass my_redis OK redis 127.0.0.1:6379[1]&gt; config get requirepass 1) &quot;requirepass&quot; 2) &quot;my_redis&quot; 无需重启redis使用第一步中配置文件中配置的老密码登录redis，会发现原来的密码已不可用，操作被拒绝 redis-cli -h 127.0.0.1 -p 6379 -a myRedis redis 127.0.0.1:6379&gt; config get requirepass (error) ERR operation not permitted 使用修改后的密码登录redis，可以执行相应操作 redis-cli -h 127.0.0.1 -p 6379 -a my_redis redis 127.0.0.1:6379&gt; config get requirepass 1) &quot;requirepass&quot; 2) &quot;my_redis 尝试重启一下redis，用新配置的密码登录redis执行操作，发现新的密码失效，redis重新使用了配置文件中的密码 sudo service redis restart Stopping redis-server: [ OK ] Starting redis-server: [ OK ] redis-cli -h 127.0.0.1 -p 6379 -a my_redis redis 127.0.0.1:6379&gt; config get requirepass (error) ERR operation not permitted redis-cli -h 127.0.0.1 -p 6379 -a myRedis redis 127.0.0.1:6379&gt; config get requirepass 1) &quot;requirepass&quot; 2) &quot;myRedis&quot; 除了在登录时通过 -a 参数制定密码外，还可以登录时不指定密码，而在执行操作前进行认证。 redis-cli -h 127.0.0.1 -p 6379 redis 127.0.0.1:6379&gt; config get requirepass (error) ERR operation not permitted redis 127.0.0.1:6379&gt; auth myRedis OK redis 127.0.0.1:6379&gt; config get requirepass 1) &quot;requirepass&quot; 2) &quot;myRedis&quot; master配置了密码，slave如何配置若master配置了密码则slave也要配置相应的密码参数否则无法进行正常复制的。slave中配置文件内找到如下行，移除注释，修改密码即可 #masterauth mstpassword AboutGitHub: 👉https://github.com/microzz个人网站: 👉https://microzz.com/","tags":[{"name":"Redis","slug":"Redis","permalink":"https://microzz.com/tags/Redis/"},{"name":"安全","slug":"安全","permalink":"https://microzz.com/tags/安全/"}]},{"title":"Web前端性能优化","date":"2017-05-13T14:37:32.000Z","path":"2017/05/13/Performance/","text":"Web性能优化：Performance，数据搜集方法浏览器新提供的performance接口精确的告诉我们当访问一个网站页面时当前网页每个处理阶段的精确时间(timestamp)，以方便我们进行前端分析。它是浏览器的直接实现，比之前在网页中用js设置Date.time或者cookie来分析网页时间上要精确很多。 readyStart = timing.fetchStart - timing.navigationStart; // 准备新页面时间耗时 redirectTime = timing.redirectEnd - timing.redirectStart; // 重定向耗时 appcacheTime = timing.domainLookupStart - timing.fetchStart; // Appcache 耗时 unloadEventTime = timing.unloadEventEnd - timing.unloadEventStart; // unload 前文档耗时 lookupDomainTime = timing.domainLookupEnd - timing.domainLookupStart; // DNS 查询耗时 connectTime = timing.connectEnd - timing.connectStart; // TCP连接耗时 requestTime = timing.responseEnd - timing.requestStart; // request请求耗时 initDomTreeTime = timing.domInteractive - timing.responseEnd; // 请求完毕至DOM加载: domReadyTime = timing.domComplete - timing.domInteractive; // 解释dom树耗时: loadTime = timing.loadEventEnd - timing.navigationStart // 从开始至load总耗时: performanceNavigation(performance.navigation)对象的成员performanceNavigation.type返回值应该是0,1,2 中的一个.分别对应三个枚举值: 0. : TYPE_NAVIGATE (用户通过常规导航方式访问页面,比如点一个链接，或者一般的get方式.) 1. : TYPE_RELOAD (用户通过刷新,包括JS调用刷新接口等方式访问页面) 2. : TYPE_BACK_FORWARD (用户通过后退按钮访问本页面) 3. ps:草案中其实还有 TYPE_RESERVED (保留,其他非前三种方式访问.) performanceNavigation.redirectCount一个只读属性,返回当前页面是几次重定向才过来的.但是这个接口有同源策略限制,即仅能检测同源的重定向. bugs: 1. IE9,当一个同源的页面a连接到地址b(是否于a,c同源都如此),后被重定向到同源页面c时.navigation.redirectCount居然会是1.而不是0,此bug已被IE10 PP2修复.** performanceTiming(performance.timing)对象的成员:.navigationStart浏览器完成卸载前一个文档的时间(也就是准备加载新页面的那个起始时间).如果没有前一个文档，那么就返回 timing.fetchStart的值. 似乎只有Chrome 非常严格遵守了此草案. 即不把刷新页面 ，以及一个标签页输入地址到指定页面，视为发生文档的卸载 bugs: 1. IE9,当发生重定向时,.navigationStart 会是0. IE10 PP2 已修复此问题. 2. IE9-IE10 PP2,的一个问题是刷新当前页面,或在某个标签页输入地址为非相同页面时, 会被视为存在前一个文档，也就是说,其navigationStart会早于fetchStart.(除非在当前页再次输入地址按回车.再次进入该页面，则被视为无前一个文档被卸载.).而实际上这时候navigationStart,是unloadEventEnd的时间. 3. Firefox7-Firefox10,一个新标签页也会被视为一个有效的文档. 所以这时候,会有值，且不是fetchStart的值. .unloadEventStart如果前一个文档，和当前文档同源,返回前一个文档发生unload事件前的时间.如果没有前一个文档，或不同源,则返回0. bugs: 1. IE9-IE10 pp2,Chrome17-,在前一个文档与当前文档中间发生重定向时, 且前后两个文档同源时, unloadEventStart,也会返回0 .unloadEventEnd如果前一个文档和当前文档同源.返回前一个文档发生unload事件的时间. 如果没有前一个文档，或不同源,则返回0. 如果,发生了HTTP重定向,或者类似的事情.并且,从导航开始中间的每次重定向，并不都和当前文档同域的话,.则返回0 bugs: 1. IE9-IE10 pp2,Chrome17-,在前一个文档与当前文档中间发生重定向时, 且前后两个文档同源时, unloadEventEnd,也会返回0 .redirectStart如果,发生了HTTP重定向,或者类似的事情.并且,从导航开始,中间的每次重定向，都和当前文档同域的话,就返回开始重定向的,timing.fetchStart的值.其他情况，则返回0. bugs: 1. IE9-IE10 pp2,在页面a,链接到地址b,并重定向到与b同源的页面c时. redirectStart,将为0.即同源策略，居然会考虑导航页. .redirectEnd如果,发生了HTTP重定向,或者类似的事情.并且,从导航开始,中间的每次重定向，都和当前文档同域的话,就返回最后一次重定向，接收到最后一个字节数据后的那个时间.其他情况则返回0. bugs: 1. IE9-IE10 pp2,在页面a,链接到地址b,并重定向到与b同源的页面c时. redirectSEnd,将为0.即同源策略，居然会考虑导航页. .fetchStart如果一个新的资源(这里是指当前文档)获取被发起,或类似的事情发生,则 fetchStart必须返回用户代理开始检查其相关缓存的那个时间,其他情况则返回开始获取该资源的时间. .domainLookupStart返回用户代理对当前文档所属域进行DNS查询开始的时间. 如果此请求没有DNS查询过程,如长连接，资源cache,甚至是本地资源等. 那么就返回 fetchStart的值. bugs: 1. Firefox7-Firefox10,的实现有错误. 因为其值,并没有遵守标准所描述的对应时间节点.而是默认以navigationStart作为时间起点,并以中间的重定向时间做累加.而得到domainLookupStart的时间.即使这个重定向是非同源的重定向.所消耗的时间都会被计算进去. 那么，这也就解释了，为什么当没有重定向发生时, domainLookupStart - fetchStart, 我们往往会得到一个负值的原因,因为navigationStart,是要早于 fetchStart的. .domainLookupEnd返回用户代理对结束对当前文档所属域进行DNS查询的时间.如果此请求没有DNS查询过程,如长连接，资源cache,甚至是本地资源等. 那么就返回 fetchStart的值. bugs: 1.参考domainLookupStart的bug. End具备相同的问题. .connectStart返回用户代理向服务器服务器请求文档，开始建立连接的那个时间,如果此连接是一个长连接,又或者直接从缓存中获取资源（即没有与服务器建立连接）.则返回domainLookupEnd的值. bugs: 1. Firefox7 当资源走cache,即并未创建连接时. connentStart 的值为0. 2. Firefox8-Firefox10,当并未创建连接时,connetStart的值是fetchStart的值，而不是domainLookEnd的值. 但这里涉及到一个惯性问题，因为domainLookupEnd的累积时间就已经背离了标准了，所以即使connectStart遵守标准.也是一个有问题的值. .connectEnd返回用户代理向服务器服务器请求文档，建立连接成功后(注意，不是断开连接的时间.)的那个时间.如果此连接是一个长连接，又或直接从缓存中获取资源 （即没有与服务器建立连接）,则返回domainLookupEnd的值. bugs: 参考connectStart的问题.connectEnd具备同样的问题. 如果连接建立失败,而用户代理进行重连,则connectStart和connectEnd则应该是这次重连的相关的值.其中connectEnd必须包括建立连接的时间以及,SSH握手协议和SOCKS认证等时间. .secureConnectionStart可选特性.用户代理如果没有对应的东东,就要把这个设置为undefined.如果有这个东东,并且是HTTPS协议,那么就要返回开始SSL握手的那个时间. 如果不是HTTPS, 那么就返回0. 补充:Firefox7-10,IE9-IE10 PP2,都木有实现这个api.所以始终是undefined. .requestStart返回从服务器、缓存、本地资源等,开始请求文档的时间. 如果请求中途,连接断开了,并且用户代理进行了重连，并重新请求了资源,那么requestStart就必须为这个新请求所对应的时间. performance.timing 并不包含一个 单表请求结束的”requestEnd”接口. 原因有两点: 1. 用户代理所能确定的请求的结束,并不能代表正确的网络栓书中的结束时间. 所以设计这个属性并没什么用处. 2. 一些用户代理，如果要封装一个代表HTTP层面的，请求结束时间的接口,成本会非常高昂. bugs: 1. Firefox7,直接走本地缓存时,.requestStart的值将为0. (Firefox8已修复此问题) .responseStart返回用户代理从服务器、缓存、本地资源中，接收到第一个字节数据的时间. .responseEnd返回用户代理接收到最后一个字符的时间，和当前连接被关闭的时间中，更早的那个. 同样,文档可能来自服务器、缓存、或本地资源. 补充: 此值的读取应该是在我们可以确保真的是Response结束以后. 比如window.onload. 因为考虑到chunked输出的情况. 那么我们脚本执行，并获取该值时，响应还没有结束. 这就会导致获取时间不准确. bugs : 1. IE10 PP2, 以及Chrome17- ，走本地缓存时.在文档中间的脚本执行时去读取此值, 将为0. IE9本来没有问题,结果IE10 PP2,反倒有了问题. 2. Chrome16-,(Chrome17,已修复此问题.)在地址栏输入相同地址,走本地缓存时. responseEnd的时间，居然早于responseStart的时间. （不得不承认，这简直就是奇葩啊!） 3. Chrome17-,从页面a,到地址b,再重定向到地址c, 此时如果地址c是走缓存.则. ResponseEnd的时间，会遭遇ResponseStart的时间.(好吧,我们把希望寄予Chrome18好了.) 实现差异:(由于草案中，并未提及,当文档被分段输出后.在中间文档数据，接受过程中,responseEnd应如何处理,导致浏览器实现存在差异.) IE9 - IE10 PP2 , Firefox8-Firefox10,在不走存在Response阶段（非走cache的情况下.）.以接收第一个chunked包结束的时间作为.responseEnd的时间.(这将导致后续的一系列问题.) Chrome17-,Firefox7,则在分段数据的接受过程中，不会更新.responseEnd的时间,其值,始终为0.* .domLoading返回用户代理把其文档的 “current document readiness” 设置为 “loading”的时候. (current document readiness 其实就是document.readyState API对应的状态.) 参考:http://dev.w3.org/html5/spec/dom.html#current-document-readiness bugs : 1. IE9. 在分段输出文档的情况下，该值总是要晚于最终responseEnd的值. 基于responseEnd的IE实现的bug.这也合情合理. 实现差异: iE9 - IE10 PP2 , 当文档是chunked方式输出的时候.总是要等最后一个chunked被浏览器接收后,domLoading才会有有效值. 也就是说,IE中目前的状况是.domLoading.无论如何，都要晚于responseEnd.其他浏览器则无此问题. 但是这个问题导致我们计算IE下DOM Parse不准确. 即 domInteractive - domLoading 甚至会经常得到0. .domInteractive返回用户代理把其文档的 “current document readiness” 设置为 “interactive”的时候. 从标准来说,domReady的状态为”interactive”时,意味着,文档解析结束了. 因为标准中描述, DOM树创建结束后第一件事，就是把 “current document readiness” 设置为”interactive” 参考:http://dev.w3.org/html5/spec/the-end.html#the-end 中第一步. bugs : 1. IE9,IE10 PP2 . 在分段输出文档的情况下，该值并不是全部文档解析完成后的时间,而是第一个数据块被解析完成的时间,基于responseEnd的IE实现的bug.经过向后推定这也合情合理. 实现差异:(由于草案中，并未提及,文档解析并未结束时,其默认值的应该是多少.导致浏览器实现有差异.) 按我个人理解，并未解析结束，应该为0. 但是IE似乎对这个东西理解不太一样. 其他浏览器会是0. 但是. IE9-IE10 PP2,则会比较有趣.即使是分段输出,我取到的值.也和onload以后去到的,domInteractive的值是一致的. 导致这一神奇现象的原因是,正式IE系的bug所导. 该时间是错误的引用了,DOM解析完成第一个数据块的时间.而不是整个文档的. 但是纠结起来就要挖掘更深层次的原因了. 因为草案只说该值体现的是,用户代理把”current document readiness” 设置为 “interactive”的时间.如果IE系处理分段输出的html文档，向来都是这样做的。那么该值与其他浏览器的差异。也是可以理解的. .domContentLoadedEventStart返回文档发生 DOMContentLoaded事件的时间. 参考:http://dev.w3.org/html5/spec/the-end.html#the-end 中第4步.DOMContentLoad和 DOMInteractive 之间差了两个步骤. 其中之一是, 所有open elements出栈 ，然后去看看 待运行的script list中是否有需要运行的脚本,如果有则执行，一直到这个列表为空了.再触发DOMContentLoad. 需要主的是这个待运行脚本列表.有些可能在不同浏览器中，被加入进去的行为可能不同. 比如 document.write写入文档流的脚本，以及script deferr 的脚本.. 所以我们应该知道deferr的脚本也是要他推迟domContentLoaded的，也就是我们最常用的所谓domReady.(至少html5的规范是如此.) .domContentLoadedEventEnd文档的DOMContentLoaded 事件的结束时间. 补充:所谓事件结束的时间，是指，如果DOMContentLoaded事件被开发者注册了回调事件.那么这个时间的End时间减去Start的时间.就会是这个回调执行的大概事件. 当然居于部分浏览器实现可能会有2-3ms的误差. 但是这个时间，基本可以忽略不计. 类似的情况还有后面的.loadEventStart,End. 即 window.onload 所有回调所消耗的时间. .domComplete返回用户代理把其文档的 “current document readiness” 设置为 “complete”的时候. PS:如果 current document readiness 的某个状态被多次触发，那么对应的 domLoading, domInteractive, domContentLoadedEventStart, domContentLoadedEventEnd and domComplete这些对应的API返回的时间,就应该是这个状态第一次触发的时间. .loadEventStart文档触发load事件的时间. 如果load事件没有触发,那么该接口就返回0. 缓存：1、浏览器缓存2、操作系统缓存3、路由器缓存4、运营商缓存 原文地址：👉 https://github.com/ChenChenJoke/JokerWebFont/blob/master/Performance/README.md 感谢。 关于GitHub：👉https://github.com/microzz","tags":[{"name":"Chrome","slug":"Chrome","permalink":"https://microzz.com/tags/Chrome/"},{"name":"性能优化","slug":"性能优化","permalink":"https://microzz.com/tags/性能优化/"},{"name":"Web","slug":"Web","permalink":"https://microzz.com/tags/Web/"}]},{"title":"Vue.js+Socket.io+Koa2打造一个智能聊天室","date":"2017-05-10T13:22:03.000Z","path":"2017/05/10/vuechat/","text":"Vue.js+Socket.io+Koa2打造一个智能聊天室Vue.js全家桶+Socket.io+Express/Koa2 打造的一个智能聊天室。已经开源啦！为了方便大家学习，智能机器人、IP定位接口也开放了！接口请在源码中查看😄 &nbsp;&nbsp;&nbsp;QQ群里面的智能机器人很火，于是用Vue.js+Socket.io+Koa2打造了一个智能聊天室，实现了IP定位、在线群聊，加入了Emoji表情😄，以及接入了智能机器人😏 前言话说最近前端技术圈也有派系之争了，是好事还是坏事？萝卜青菜各有所爱，本项目采用的是Vue.js做前端页面展示，大家完全可以换成自己别的喜欢的，React、Angular等等，每个框架都有可取的地方，这里不多说😂下面扯到正题上👇 预览在线预览地址：👉 https://microzz.com/vue-chat/ Vue.js+Socket.io Vue.js+Socket.io 源代码 现在已经开源： 👉https://github.com/microzz/vue-chat 欢迎star和提出宝贵意见😄 技术栈 Vue2.0：前端页面展示。 Socket.io：实现实时通信 Vuex：Vuex，实现不同组件间的状态共享 vue-router：页面路由切换 axios：一个基于 Promise 的 HTTP 库，向后端发起请求。 Express、Koa2：因为vue-cli生成的项目是基于express的，所以在开发阶段我使用的是它，但是真正上线生产环境我换成了Koa2。 Moment.js：一个时间处理的库，方便对时间进行格式化成需要的格式。 ES6、ES7：采用ES6语法，这是以后的趋势。箭头函数、Promise等等语法很好用。 localStorage：保存用户信息以及聊天记录。 Webpack：vue-cli自带Webpack，但是需要自己改造一下，比如要对需要安装sass相关loader，vue-cli已经配置好了webpack，你只需要安装依赖就可以，使用的时候只需要&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt;。 SASS(SCSS)：用SCSS做CSS预处理语言，有些地方很方便，个人很喜欢用。(详看👉SASS用法指南) flex：flex弹性布局，简单适配手机、PC端。 CSS3：CSS3过渡动画及样式。 分析Socket.io通过Express/Koa在服务端可以这样做: // Server (app.js) var app = require(&#39;express&#39;)(); var server = require(&#39;http&#39;).Server(app); var io = require(&#39;socket.io&#39;)(server); server.listen(80); app.get(&#39;/&#39;, function (req, res) { res.sendfile(__dirname + &#39;/index.html&#39;); }); io.on(&#39;connection&#39;, function (socket) { socket.emit(&#39;news&#39;, { hello: &#39;world&#39; }); socket.on(&#39;my other event&#39;, function (data) { console.log(data); }); }); 客户端代码 // Client (index.html) &lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var socket = io.connect(&#39;http://localhost&#39;); socket.on(&#39;news&#39;, function (data) { console.log(data); socket.emit(&#39;my other event&#39;, { my: &#39;data&#39; }); }); &lt;/script&gt; 不管是服务器还是客户端都有 emit 和 on 这两个函数，可以说 socket.io 的核心就是这两个函数了，通过 emit 和 on 可以轻松地实现服务器与客户端之间的双向通信。 emit ：用来发射一个事件或者说触发一个事件，第一个参数为事件名，第二个参数为要发送的数据，第三个参数为回调函数（一般省略，如需对方接受到信息后立即得到确认时，则需要用到回调函数）。on ：用来监听一个 emit 发射的事件，第一个参数为要监听的事件名，第二个参数为一个匿名函数用来接收对方发来的数据，该匿名函数的第一个参数为接收的数据，若有第二个参数，则为要返回的函数。socket.io 提供了三种默认的事件（客户端和服务器都有）：connect 、message 、disconnect 。当与对方建立连接后自动触发 connect 事件，当收到对方发来的数据后触发 message 事件（通常为 socket.send() 触发），当对方关闭连接后触发 disconnect 事件。 此外，socket.io 还支持自定义事件，毕竟以上三种事件应用范围有限，正是通过这些自定义的事件才实现了丰富多彩的通信。 最后，需要注意的是，在服务器端区分以下三种情况： socket.emit() ：向建立该连接的客户端广播socket.broadcast.emit() ：向除去建立该连接的客户端的所有客户端广播io.sockets.emit() ：向所有客户端广播，等同于上面两个的和 Vue.js在Vue的方面就比较常规了，Vue全家桶：Vue2.0+Vuex+axios+vue-router,我GitHub的有几个开源项目可以参考👉https://github.com/microzz 总结 组件状态多了用Vuex管理很方便，引用 Redux 的作者 Dan Abramov 的话说就是： Flux 架构就像眼镜：您自会知道什么时候需要它。 事先一定要先想好整个页面组成，怎样去分组件开发，这样在开发阶段会事半功倍。 Moment.js在Vue中用ES6的方式引入会有问题，可以尝试在main.js尝试这样import moment from &#39;moment&#39; Vue.prototype.moment = moment;给Vue的原型上添加moment，这样就可以在Vue的实例中随意使用它了。 get方式通过URL传参最好使用encodeURI对参数进行编码 一定要处理好那些异步操作，否则会带来各种问题。开发阶段使用的是Promise，上线时候使用了ES7的Async+Promise的组合，让异步操作更加合理。 About关于我：👉https://microzz.com/about/ GitHub：👉 https://github.com/microzz E-mail: 👉 zhaohui@microzz.com","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://microzz.com/tags/Vue-js/"},{"name":"Koa2","slug":"Koa2","permalink":"https://microzz.com/tags/Koa2/"},{"name":"Socket.io","slug":"Socket-io","permalink":"https://microzz.com/tags/Socket-io/"},{"name":"Vuex","slug":"Vuex","permalink":"https://microzz.com/tags/Vuex/"},{"name":"Express","slug":"Express","permalink":"https://microzz.com/tags/Express/"}]},{"title":"Git远程操作详解","date":"2017-05-06T12:41:07.000Z","path":"2017/05/06/git/","text":"Git远程操作详解作者： 阮一峰 Git是目前最流行的版本管理系统，学会Git几乎成了开发者的必备技能。Git有很多优势，其中之一就是远程操作非常简便。本文详细介绍5个Git命令，它们的概念和用法，理解了这些内容，你就会完全掌握Git远程操作。git clone、git remote、git fetch、git pull、git push 本文针对初级用户，从最简单的讲起，但是需要读者对Git的基本用法有所了解。同时，本文覆盖了上面5个命令的几乎所有的常用用法，所以对于熟练用户也有参考价值。 Git git clone远程操作的第一步，通常是从远程主机克隆一个版本库，这时就要用到git clone命令。 $ git clone &lt;版本库的网址&gt; 比如，克隆jQuery的版本库。 $ git clone https://github.com/jquery/jquery.git 该命令会在本地主机生成一个目录，与远程主机的版本库同名。如果要指定不同的目录名，可以将目录名作为git clone命令的第二个参数。 $ git clone &lt;版本库的网址&gt; &lt;本地目录名&gt;git clone支持多种协议，除了HTTP(s)以外，还支持SSH、Git、本地文件协议等，下面是一些例子。 $ git clone http[s]://example.com/path/to/repo.git/ $ git clone ssh://example.com/path/to/repo.git/ $ git clone git://example.com/path/to/repo.git/ $ git clone /opt/git/project.git $ git clone file:///opt/git/project.git $ git clone ftp[s]://example.com/path/to/repo.git/ $ git clone rsync://example.com/path/to/repo.git/ SSH协议还有另一种写法。 $ git clone [user@]example.com:path/to/repo.git/ 通常来说，Git协议下载速度最快，SSH协议用于需要用户认证的场合。各种协议优劣的详细讨论请参考官方文档。 git remote为了便于管理，Git要求每个远程主机都必须指定一个主机名。git remote命令就用于管理主机名。不带选项的时候，git remote命令列出所有远程主机。 $ git remote origin 使用-v选项，可以参看远程主机的网址。 $ git remote -v origin git@github.com:jquery/jquery.git (fetch) origin git@github.com:jquery/jquery.git (push) 上面命令表示，当前只有一台远程主机，叫做origin，以及它的网址。克隆版本库的时候，所使用的远程主机自动被Git命名为origin。如果想用其他的主机名，需要用git clone命令的-o选项指定。 $ git clone -o jQuery https://github.com/jquery/jquery.git $ git remote jQuery 上面命令表示，克隆的时候，指定远程主机叫做jQuery。git remote show命令加上主机名，可以查看该主机的详细信息。 $ git remote show &lt;主机名&gt; git remote add命令用于添加远程主机。 $ git remote add &lt;主机名&gt; &lt;网址&gt; git remote rm命令用于删除远程主机。 $ git remote rm &lt;主机名&gt; git remote rename命令用于远程主机的改名。 $ git remote rename &lt;原主机名&gt; &lt;新主机名&gt; git fetch一旦远程主机的版本库有了更新（Git术语叫做commit），需要将这些更新取回本地，这时就要用到git fetch命令。 $ git fetch &lt;远程主机名&gt;上面命令将某个远程主机的更新，全部取回本地。git fetch命令通常用来查看其他人的进程，因为它取回的代码对你本地的开发代码没有影响。默认情况下，git fetch取回所有分支（branch）的更新。如果只想取回特定分支的更新，可以指定分支名。 $ git fetch &lt;远程主机名&gt; &lt;分支名&gt;比如，取回origin主机的master分支。 $ git fetch origin master所取回的更新，在本地主机上要用”远程主机名/分支名”的形式读取。比如origin主机的master，就要用origin/master读取。git branch命令的-r选项，可以用来查看远程分支，-a选项查看所有分支。 $ git branch -r origin/master $ git branch -a * master remotes/origin/master 上面命令表示，本地主机的当前分支是master，远程分支是origin/master。取回远程主机的更新以后，可以在它的基础上，使用git checkout命令创建一个新的分支。 $ git checkout -b newBrach origin/master上面命令表示，在origin/master的基础上，创建一个新分支。此外，也可以使用git merge命令或者git rebase命令，在本地分支上合并远程分支。 $ git merge origin/master 或者$ git rebase origin/master上面命令表示在当前分支上，合并origin/master。 git pullgit pull命令的作用是，取回远程主机某个分支的更新，再与本地的指定分支合并。它的完整格式稍稍有点复杂。 $ git pull &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;比如，取回origin主机的next分支，与本地的master分支合并，需要写成下面这样。 $ git pull origin next:master如果远程分支是与当前分支合并，则冒号后面的部分可以省略。 $ git pull origin next上面命令表示，取回origin/next分支，再与当前分支合并。实质上，这等同于先做git fetch，再做git merge。 $ git fetch origin$ git merge origin/next 在某些场合，Git会自动在本地分支与远程分支之间，建立一种追踪关系（tracking）。比如，在git clone的时候，所有本地分支默认与远程主机的同名分支，建立追踪关系，也就是说，本地的master分支自动”追踪”origin/master分支。Git也允许手动建立追踪关系。 git branch --set-upstream master origin/next上面命令指定master分支追踪origin/next分支。如果当前分支与远程分支存在追踪关系，git pull就可以省略远程分支名。 $ git pull origin上面命令表示，本地的当前分支自动与对应的origin主机”追踪分支”（remote-tracking branch）进行合并。如果当前分支只有一个追踪分支，连远程主机名都可以省略。 $ git pull上面命令表示，当前分支自动与唯一一个追踪分支进行合并。如果合并需要采用rebase模式，可以使用–rebase选项。 $ git pull --rebase &lt;远程主机名&gt; &lt;远程分支名&gt;:&lt;本地分支名&gt;如果远程主机删除了某个分支，默认情况下，git pull 不会在拉取远程分支的时候，删除对应的本地分支。这是为了防止，由于其他人操作了远程主机，导致git pull不知不觉删除了本地分支。但是，你可以改变这个行为，加上参数 -p 就会在本地删除远程已经删除的分支。 $ git pull -p 等同于下面的命令$ git fetch --prune origin$ git fetch -p git pushgit push命令用于将本地分支的更新，推送到远程主机。它的格式与git pull命令相仿。 $ git push &lt;远程主机名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;注意，分支推送顺序的写法是&lt;来源地&gt;:&lt;目的地&gt;，所以git pull是&lt;远程分支&gt;:&lt;本地分支&gt;，而git push是&lt;本地分支&gt;:&lt;远程分支&gt;。如果省略远程分支名，则表示将本地分支推送与之存在”追踪关系”的远程分支（通常两者同名），如果该远程分支不存在，则会被新建。 $ git push origin master上面命令表示，将本地的master分支推送到origin主机的master分支。如果后者不存在，则会被新建。如果省略本地分支名，则表示删除指定的远程分支，因为这等同于推送一个空的本地分支到远程分支。 $ git push origin :master等同于$ git push origin --delete master上面命令表示删除origin主机的master分支。如果当前分支与远程分支之间存在追踪关系，则本地分支和远程分支都可以省略。 $ git push origin上面命令表示，将当前分支推送到origin主机的对应分支。如果当前分支只有一个追踪分支，那么主机名都可以省略。 $ git push如果当前分支与多个主机存在追踪关系，则可以使用-u选项指定一个默认主机，这样后面就可以不加任何参数使用git push。 $ git push -u origin master上面命令将本地的master分支推送到origin主机，同时指定origin为默认主机，后面就可以不加任何参数使用git push了。不带任何参数的git push，默认只推送当前分支，这叫做simple方式。此外，还有一种matching方式，会推送所有有对应的远程分支的本地分支。Git 2.0版本之前，默认采用matching方法，现在改为默认采用simple方式。如果要修改这个设置，可以采用git config命令。 $ git config --global push.default matching 或者$ git config --global push.default simple还有一种情况，就是不管是否存在对应的远程分支，将本地的所有分支都推送到远程主机，这时需要使用–all选项。 $ git push --all origin上面命令表示，将所有本地分支都推送到origin主机。如果远程主机的版本比本地版本更新，推送时Git会报错，要求先在本地做git pull合并差异，然后再推送到远程主机。这时，如果你一定要推送，可以使用–force选项。 $ git push --force origin上面命令使用–force选项，结果导致远程主机上更新的版本被覆盖。除非你很确定要这样做，否则应该尽量避免使用–force选项。最后，git push不会推送标签（tag），除非使用–tags选项。$ git push origin --tags （完） AboutGitHub：👉https://github.com/microzz个人网站：👉https://microzz.com/","tags":[{"name":"Git","slug":"Git","permalink":"https://microzz.com/tags/Git/"},{"name":"版本管理","slug":"版本管理","permalink":"https://microzz.com/tags/版本管理/"}]},{"title":"JS中的call和apply应用","date":"2017-05-04T12:38:49.000Z","path":"2017/05/04/callapply/","text":"JavaScript中的call和apply应用 ECMAScript3给Function的原型定义了两个方法，他们是Function.prototype.call 和 Function.prototype.apply. 在实际开发中，特别是在一些函数式风格的代码编写中，call和apply方法尤为有用。 call和apply区别其实他们的作用是一样的，只是传递的参数不一样而已。apply： 接受2个参数，第一个参数指定了函数体内this对象的指向，第二个参数为数组或者一个类数组。apply传入的是一个参数数组，也就是将多个参数组合成为一个数组传入，而call则作为call的参数传入（从第二个参数开始）。 举个栗子： const obj1 = { name: &#39;microzz&#39;, getName: function() { return this.name; } }; const obj2 = { name: &#39;Zhaohui&#39; } console.log(obj1.getName()); // &quot;microzz&quot; console.log(obj1.getName.call(obj2)); // &quot;Zhaohui&quot; console.log(obj1.getName.apply(obj2)); // &quot;Zhaohui&quot; call和apply的用途改变this指向call和apply可以改变this的指向，这点我们从上面这个例子中可以看出。我们还可以举一个实际当中可以遇到的情况： 有的时候我们会觉得 document.getElementById这个方法太长了，我们会尝试用一个短函数来代替它，如同prototype.js等一些框架所做过的事情，下面用代码说明： const getId = function(id) { return document.getElementById(id); } getId(&#39;id&#39;); 在Chrome、Firefox、IE10中执行会发现抛出异常，这是因为很多引擎的 document.getElementById 的方法内部需要用到this，这个this本来被期望指向document，但直接普通函数调用就指向了window。我们可以利用apply“修正” this： document.getElementById = (function(func) { return function() { return func.apply(document, arguments); } })(document.getElement); const getId = document.getElementById; Function.prototype.bind在大部分高级浏览器已经实现了内置的Function.prototype.bind，用来指定函数内部的this指向，如果没有原生的Function.prototype.bind,我们也可以模拟一个，代码如下： Function.prototype.bind = function(context) { var self = this; return function() { return self.apply(context, arguments); } } var obj = { name: &#39;microzz&#39; }; var func = function() { console.log(this.name); // microzz }.bind(obj); func(); 这是一个简化版的，通常我们会实现得稍微复杂一点： Function.prototype.bind = function() { var self = this; // 需要绑定的this上下文 var context = [].shift.call(arguments); // 剩余的参数转成数组 var args = [].slice.call(arguments); return function() { return self.apply(context, [].concat.call(args, [].slice.call(arguments))); } } var obj = { name: &#39;microzz&#39; }; var func = function(a, b, c, d) { console.log(this.name); // microzz console.log([a, b, c, d]); // [1, 2, 3, 4] }.bind(obj, 1, 2); func(3, 4); 借用其他对象的方法借用构造函数借用方法的第一种场景是“借用构造函数”，可以实现类似继承的效果： var A = function(name) { this.name = name; } var B = function() { A.apply(this, arguments); } B.prototype.getName = function() { return this.name; } var b = new B(&#39;microzz&#39;); console.log(b.getName()); // microzz 类数组函数参数列表arguments是一个类数组对象，虽然它有下标，但是并不是真正的数组。为了能使用数组的一些方法，我们常常会借用Array.prototype对象上的方法。比如想往arguments中添加新元素，通常会借用Array.prototype.push想把arguments转成真正数组的时候，可以借用Array.prototype.slice或者也可以使用ES6的Array.from AboutGitHub：👉https://github.com/microzz个人网站：👉https://microzz.com/","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"call","slug":"call","permalink":"https://microzz.com/tags/call/"},{"name":"apply","slug":"apply","permalink":"https://microzz.com/tags/apply/"}]},{"title":"你真的知道JS吗？","date":"2017-04-30T10:08:44.000Z","path":"2017/04/30/knowjs/","text":"你真的知道JavaScript吗 &nbsp;&nbsp;&nbsp;&nbsp;JavaScript是一门奇怪的语言，要真正掌握并不容易。废话不多说，来一个快速测试，5道题目，看看你对JavaScript是否真正掌握。准备好了吗？开始咯😄 题目No.1if (!(&quot;a&quot; in window)) { var a = 1; } console.log(a); No.2var a = 1, b = function a(x) { x &amp;&amp; a(--x); }; console.log(a); No.3function a(x) { return x * 2; } var a; console.log(a); No.4function b(x, y, a) { arguments[2] = 10; console.log(a); } b(1, 2, 3); No.5function a() { console.log(this); } a.call(null); 解析No.1&nbsp;&nbsp;&nbsp;&nbsp;在浏览器环境中，全局变量都是window的一个属性，即var a = 1 等价于 window.a = 1。in操作符用来判断某个属性属于某个对象，可以是对象的直接属性，也可以是通过prototype继承的属性。&nbsp;&nbsp;&nbsp;&nbsp;再看题目，在浏览器中，如果没有全局变量 a ，则声明一个全局变量 a (ES5没有块级作用域)，并且赋值为1。很多人会认为打印的是1。非也，大家不要忘了变量声明会被前置！什么意思呢？题目也就等价于 var a; if (!(&quot;a&quot; in window)) { a = 1; } console.log(a); 所以其实已经声明了变量a，只不过if语句之前值是undefined，所以if语句压根不会执行。最后答案就是 undefined No.2这道题有几个需要注意的地方： 变量声明、函数声明会被前置，但是函数表达式并不会，准确说类似变量声明前置，举个栗子： console.log(&#39;b&#39;, b); // b undefined var b = function() {} console.log(&#39;b&#39;, b); // b function () {} 2.具名的函数表达式的名字只能在该函数内部取到，举个例子(排除老的IE😂)： var foo = function bar () {} console.log(&#39;foo&#39;, foo); // foo function bar(){} console.log(&#39;bar&#39;, bar); // Uncaught ReferenceError: bar is not defined &nbsp;&nbsp;&nbsp;&nbsp;综合这两点，再看题目，最后输出的内容就为 1 No.3函数声明会覆盖变量声明，但不会覆盖变量赋值，举个栗子简单粗暴： function foo(){ return 1; } var foo; console.log(typeof foo); // &quot;function&quot; 函数声明的优先级高于变量声明的优先级，但如果该变量foo赋值了，那结果就完全不一样了： function foo(){ return 1; } var foo = 1; console.log(typeof foo); // &quot;number&quot; 变量foo赋值以后，变量赋值初始化就覆盖了函数声明。这个需要注意再看题目 function a(x) { return x * 2; } var a; console.log(a); // function a(x) {...} No.4这题考察 arguments 对象的用法(详看👉JavaScript中的arguments对象)一般情况，arguments与函数参数是动态绑定关系(为什么说是一般稍后会解释)，所以很好理解，最后输出的是10 但是但是但是，我们不要忘了一个特殊情况–严格模式，在严格模式中 arguments 与相当于函数参数的一个拷贝，并没有动态绑定关系，举个栗子： &#39;use strict&#39; // 严格模式！！ function b(x, y, a) { arguments[2] = 10; console.log(a); } b(1, 2, 3); // 3 No.5function a() { console.log(this); } a.call(null); 关于 a.call(null); 根据ECMAScript262规范规定：如果第一个参数传入的对象调用者是null或者undefined的话，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管你什么时候传入null或者 undefined，其this都是全局对象window。所以，在浏览器上答案是输出 window 对象。 但是但是但是，我们依旧不能忘记一个特殊情况–严格模式，在严格模式中，null 就是 null，undefined 就是 undefined ，举个栗子： &#39;use strict&#39;; // 严格模式！！ function a() { console.log(this); } a.call(null); // null a.call(undefined); // undefined 提醒 在浏览器中的全局对象是window，Node.js中是global; 为了使代码更加严谨与健壮，建议写JS都加上严格模式&#39;use strict&#39;; ES6已经成为前端必备技能，呼吁大家都使用ES6，方便高效，可以使用babel把ES6转成ES5甚至ES3，尽量使用ES6推动前端的发展👍 AboutGitHub: 👉https://github.com/microzz个人网站: 👉https://microzz.com/","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"}]},{"title":"深入理解ES6中的箭头函数","date":"2017-04-29T13:08:13.000Z","path":"2017/04/29/arrowfunc/","text":"JavaScript深入理解ES6中的箭头函数 &nbsp;&nbsp;&nbsp;&nbsp;箭头函数表达式的语法比函数表达式短，并且不绑定自己的 this，arguments，super或 new.target。此外，箭头函数最好在非方法函数中使用，且不能用作构造函数。 语法基础语法(param1, param2, …, paramN) =&gt; { statements } (param1, param2, …, paramN) =&gt; expression // 等价于: =&gt; { return expression; } // 如果只有一个参数，圆括号是可选的: (singleParam) =&gt; { statements } singleParam =&gt; { statements } // 无参数或者多参数的箭头函数需要使用圆括号或者下划线: () =&gt; { statements } _ =&gt; { statements } 高级语法// 只返回一个对象字面量,没有其他语句时, 应当用圆括号将其包起来: params =&gt; ({foo: bar}) // 支持 Rest parameters 和 default parameters: (param1, param2, ...rest) =&gt; { statements } (param1 = defaultValue1, param2, …, paramN = defaultValueN) =&gt; { statements } // 支持参数列表中的解构赋值 var f = ([a, b] = [1, 2], {x: c} = {x: a + b}) =&gt; a + b + c; f(); // 6 描述 &nbsp;&nbsp;&nbsp;&nbsp;箭头函数的引入有两个方面的作用：一是更简短的函数书写，二是对 this的词法解析。 更短的函数更短的函数在函数式编程里很受欢迎。试比较： var a = [ &quot;Hydrogen&quot;, &quot;Helium&quot;, &quot;Lithium&quot;, &quot;Beryl­lium&quot; ]; var a2 = a.map(function(s){ return s.length }); var a3 = a.map( s =&gt; s.length ); 不绑定 this &nbsp;&nbsp;&nbsp;&nbsp;在箭头函数出现之前，每个新定义的函数都有其自己的 this 值（例如，构造函数的 this 指向了一个新的对象；严格模式下的函数的 this 值为 undefined；如果函数是作为对象的方法被调用的，则其 this 指向了那个调用它的对象）。在面向对象风格的编程中，这会带来很多困扰。 function Person() { // 构造函数 Person() 定义的 `this` 就是新实例对象自己 this.age = 0; setInterval(function growUp() { // 在非严格模式下，growUp() 函数定义了其内部的 `this`为全局对象, 不同于构造函数Person()的定义的 `this` this.age++; }, 1000); } var p = new Person(); // 在 ECMAScript 3/5 中，这个问题通过把this的值赋给变量， // 然后将该变量放到闭包中来解决。 function Person() { var self = this; // 也有人选择使用 `that` 而非 `self`. // 只要保证一致就好. self.age = 0; setInterval(function growUp() { // 回调里面的 `self` 变量就指向了期望的那个对象了 self.age++; }, 1000); } 除此之外，还可以使用 bind 函数，把期望的 this 值传递给 growUp() 函数。 箭头函数会捕获其所在上下文的 this 值，作为自己的 this 值，因此下面的代码将如期运行。 function Person(){ this.age = 0; setInterval(() =&gt; { this.age++; // this正确地指向了person对象 }, 1000); } var p = new Person(); 与严格模式的关系考虑到 this 是词法层面上的，严格模式中与 this 相关的规则都将被忽略。 var f = () =&gt; {&#39;use strict&#39;; return this}; f() === window; // 或全局对象 严格模式的其他规则依然不变. 使用 call 或 apply 调用由于 this 已经在词法层面完成了绑定，通过 call() 或 apply() 方法调用一个函数时，只是传入了参数而已，对 this 并没有什么影响： var adder = { base : 1, add : function(a) { var f = v =&gt; v + this.base; return f(a); }, addThruCall: function(a) { var f = v =&gt; v + this.base; var b = { base : 2 }; return f.call(b, a); } }; console.log(adder.add(1)); // 输出 2 console.log(adder.addThruCall(1)); // 仍然输出 2（而不是3） 不绑定参数（arguments） &nbsp;&nbsp;&nbsp;&nbsp;箭头函数不会在其内部暴露出参数（arguments )： arguments.length, arguments[0], arguments[1] 等等，都不会指向箭头函数的 arguments，而是指向了箭头函数所在作用域的一个名为 arguments 的值（如果有的话，否则，就是 undefined。） var arguments = 42; var arr = () =&gt; arguments; arr(); // 42 function foo() { var f = (i) =&gt; arguments[0]+i; // foo函数的间接参数绑定 return f(2); } foo(1); // 3 // 箭头函数没有自己的 arguments ， // 不过在大多数情形下，rest参数可以给出一个解决方案： function foo() { var f = (...args) =&gt; args[0]; return f(2); } foo(1); // 2 像方法一样使用箭头函数如上所述，箭头函数表达式对非方法函数是最合适的。让我们看看当我们试着把它们作为方法时发生了什么。 &#39;use strict&#39;; var obj = { i: 10, b: () =&gt; console.log(this.i, this), c: function() { console.log( this.i, this) } } obj.b(); // undefined, Window obj.c(); // 10, Object {...} // 箭头函数没有定义this绑定。 // 另一个涉及Object.defineProperty():的示例： &#39;use strict&#39;; var obj = { a: 10 }; Object.defineProperty(obj, &quot;b&quot;, { get: () =&gt; { console.log(this.a, typeof this.a, this); return this.a+10; // represents global object &#39;Window&#39;, // therefore &#39;this.a&#39; returns &#39;undefined&#39; } }); 使用 new 操作符箭头函数不能用作构造器，和 new 一起用就会抛出错误。 var Foo = () =&gt; {}; var foo = new Foo(); // TypeError: Foo is not a constructor 使用原型属性箭头函数没有原型属性。 var Foo = () =&gt; {}; console.log(Foo.prototype); // undefined 使用 yield 关键字 yield 关键字通常不能在箭头函数中使用（除非是嵌套在允许使用的函数内）。因此，箭头函数不能用作生成器。 函数主体箭头函数既支持简写也支持常规编写。 简写时只需要一个表达式和一个返回值。常规编写时必须有一个明确的返回值。 var func = x =&gt; x * x; // 简写函数 省略return var func = (x, y) =&gt; { return x + y; }; //常规编写 明确的返回值 返回文字表达式请牢记，用 params =&gt; {object:literal} 这种简单的语法返回一个文字表达式是行不通的： var func = () =&gt; { foo: 1 }; // undefined! var func = () =&gt; { foo: function() {} }; // SyntaxError: function statement requires a name（未定义函数语句） // 这是因为花括号（即 {} ）里面的代码被解析为序列语句了 //（例如， foo 被认为是一个标签, 而非文字表达式的组成部分）。 所以，记得用圆括号把文字表达式包起来： var func = () =&gt; ({ foo: 1 }); 换行箭头函数在参数和箭头之间不能换行哦 var func = () =&gt; 1; // SyntaxError: expected expression, got &#39;=&gt;&#39; 解析顺序在箭头函数中的箭头不是操作符(或者运算符,就像’+ -‘那些)， 但是箭头函数有特殊的解析规则就是：相比普通的函数，受操作符的优先级影响。 let callback; callback = callback || function() {}; // ok callback = callback || () =&gt; {}; // SyntaxError:非法箭头函数属性 callback = callback || (() =&gt; {}); // ok 示例// 一个空箭头函数,返回 undefined let empty = () =&gt; {}; (() =&gt; &quot;foobar&quot;)() // 返回 &quot;foobar&quot; var simple = a =&gt; a &gt; 15 ? 15 : a; simple(16); // 15 simple(10); // 10 let max = (a, b) =&gt; a &gt; b ? a : b; // 简单的数组筛选（数组filter方法），运算（数组map方法）, ... var arr = [5, 6, 13, 0, 1, 18, 23]; var sum = arr.reduce((a, b) =&gt; a + b); // 66 var even = arr.filter(v =&gt; v % 2 == 0); // [6, 0, 18] var double = arr.map(v =&gt; v * 2); // [10, 12, 26, 0, 2, 36, 46] // 更多简明的promise链 promise.then(a =&gt; { // ... }).then(b =&gt; { // ... }); // 更易理解的无参数箭头函数 setTimeout( () =&gt; { console.log(&#39;I happen sooner&#39;); setTimeout( () =&gt; { // deeper code console.log(&#39;I happen later&#39;); }, 1); }, 1); AboutGitHub: 👉https://github.com/microzz个人网站: 👉https://microzz.com/","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"箭头函数","slug":"箭头函数","permalink":"https://microzz.com/tags/箭头函数/"}]},{"title":"JavaScript中的arguments对象","date":"2017-04-28T07:55:02.000Z","path":"2017/04/28/arguments/","text":"JavaScript中的arguments对象arguments 是一个类似数组的对象, 对应于传递给函数的参数。 语法arguments 描述arguments对象是所有函数中可用的局部变量。你可以使用arguments对象在函数中引用函数的参数。此对象包含传递给函数的每个参数的条目，第一个条目的索引从0开始。例如，如果一个函数传递了三个参数，你可以参考它们如下： arguments[0]arguments[1]arguments[2]参数也可以被设置: arguments[1] = &#39;new value&#39;; arguments对象不是一个 Array 。它类似于数组，但除了 长度之外没有任何数组属性。例如，它没有 pop 方法。但是它可以被转换为一个真正的数组：： let args = Array.prototype.slice.call(arguments); let args = [].slice.call(arguments); 你还可以使用 Array.from()方法或 spread 运算符将 arguments 转换为真正的数组： let args = Array.from(arguments); let args = [...arguments]; 对参数使用slice会阻止某些JavaScript引擎中的优化 (比如 V8 引擎)。 如果你关心它们，尝试通过遍历arguments对象来构造一个新的数组。 另一种方法是使用 被忽视的/鄙视/轻视,/看不起 Array构造函数作为一个函数： let args = ( arguments.length === 1 ? [arguments[0]] : Array.apply(null, arguments) ); 如果 Array generics 可用的话，下面的代码可以作为替代: var args = Array.slice(arguments); arguments 对象仅在函数内部有效，在函数外部调用 arguments 对象会出现一个错误。 arguments的typeof返回’object‘。 console.log(typeof arguments); // &#39;object&#39; 可以使用索引来确定各个arguments的类型。 console.log(typeof arguments[0]); //这将返回单个参数的typeof。 如果你调用一个函数，当这个函数的参数数量比它显式声明的参数数量更多的时候，你就可以使用 arguments 对象。这个技术对于参数数量是一个可变量的函数来说比较有用。 你可以用 arguments.length 来得到参数的数量，然后可以用 arguments object 来对每个参数进行处理。 (想要得到函数签名的参数数量, 请使用 Function.length 属性。) 属性arguments.callee // 指向当前执行的函数。 arguments.caller // 指向调用当前函数的函数。 arguments.length // 指向传递给当前函数的参数数量。 例子定义一个连接几个字符串的函数这个例子定义了一个函数来连接字符串。这个函数唯一正式声明了的参数是一个字符串，该参数指定一个字符作为衔接点来连接字符串。该函数定义如下： function myConcat(separator) { var args = Array.prototype.slice.call(arguments, 1); return args.join(separator); } 你可以传递任意数量的参数到该函数，然后该函数会将每个参数作为一个条目来创建一个列表。 myConcat(&quot;, &quot;, &quot;red&quot;, &quot;orange&quot;, &quot;blue&quot;); // returns &quot;red, orange, blue&quot; myConcat(&quot;; &quot;, &quot;elephant&quot;, &quot;giraffe&quot;, &quot;lion&quot;, &quot;cheetah&quot;); // returns &quot;elephant; giraffe; lion; cheetah&quot; myConcat(&quot;. &quot;, &quot;sage&quot;, &quot;basil&quot;, &quot;oregano&quot;, &quot;pepper&quot;, &quot;parsley&quot;); // returns &quot;sage. basil. oregano. pepper. parsley&quot; 定义一个创建HTML列表的方法这个例子定义了一个函数通过一个字符串来创建HTML列表。这个函数唯一正式声明了的参数是一个字符。当该参数为 “u” 时，创建一个无序列表 (项目列表)；当该参数为 “o” 时，则创建一个有序列表 (编号列表)。该函数定义如下： function list(type) { var result = &quot;&lt;&quot; + type + &quot;l&gt;&lt;li&gt;&quot;; var args = Array.prototype.slice.call(arguments, 1); result += args.join(&quot;&lt;/li&gt;&lt;li&gt;&quot;); result += &quot;&lt;/li&gt;&lt;/&quot; + type + &quot;l&gt;&quot;; // end list return result; } 你可以传递任意数量的参数到该函数，然后该函数会将每个参数作为一个条目添加到第一个参数指定类型的列表当中。 var listHTML = list(&quot;u&quot;, &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;); /* listHTML is: &quot;&lt;ul&gt;&lt;li&gt;One&lt;/li&gt;&lt;li&gt;Two&lt;/li&gt;&lt;li&gt;Three&lt;/li&gt;&lt;/ul&gt;&quot; */ 注意ES6中的箭头函数没有自己的 arguments 对象，不过在大多数情形下，rest参数可以给出一个解决方案： let a; const fn = (...rest) =&gt; Array.prototype.slice.call(rest, 1); a = fn(1, 2); // [2] 关于GitHub：👉https://github.com/microzz个人网站：👉https://microzz.com/","tags":[{"name":"JavaScrip","slug":"JavaScrip","permalink":"https://microzz.com/tags/JavaScrip/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"arguments","slug":"arguments","permalink":"https://microzz.com/tags/arguments/"}]},{"title":"Vue+Socket.io+Koa2打造一个智能聊天室","date":"2017-04-27T02:07:21.000Z","path":"2017/04/27/vue-chat/","text":"Vue.js+Socket.io+Koa2打造一个智能聊天室👉文章已更新请看这里 QQ群里面的智能机器人很火，于是用Vue.js+Socket.io+Koa2打造了一个智能聊天室，实现了IP定位、在线群聊，加入了Emoji表情😄，以及接入了智能机器人😏 预览 Vue.js+Socket.io 在线预览地址：👉 https://microzz.com/vue-chat/ 技术栈 Vue2.0：前端页面展示。 Socket.io：实现实时通信 Vuex：Vuex，实现不同组件间的状态共享 vue-router：页面路由切换 axios：一个基于 Promise 的 HTTP 库，向后端发起请求。 Express、Koa2：因为vue-cli生成的项目是基于express的，所以在开发阶段我使用的是它，但是真正上线生产环境我换成了Koa2。 Moment.js：一个时间处理的库，方便对时间进行格式化成需要的格式。 ES6、ES7：采用ES6语法，这是以后的趋势。箭头函数、Promise等等语法很好用。 localStorage：保存用户信息以及聊天记录。 Webpack：vue-cli自带Webpack，但是需要自己改造一下，比如要对需要安装sass相关loader，vue-cli已经配置好了webpack，你只需要安装依赖就可以，使用的时候只需要&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt;。 SASS(SCSS)：用SCSS做CSS预处理语言，有些地方很方便，个人很喜欢用。(详看👉SASS用法指南) flex：flex弹性布局，简单适配手机、PC端。 CSS3：CSS3过渡动画及样式。 分析Socket.io通过Express/Koa在服务端可以这样做: // Server (app.js) var app = require(&#39;express&#39;)(); var server = require(&#39;http&#39;).Server(app); var io = require(&#39;socket.io&#39;)(server); server.listen(80); app.get(&#39;/&#39;, function (req, res) { res.sendfile(__dirname + &#39;/index.html&#39;); }); io.on(&#39;connection&#39;, function (socket) { socket.emit(&#39;news&#39;, { hello: &#39;world&#39; }); socket.on(&#39;my other event&#39;, function (data) { console.log(data); }); }); 客户端代码 // Client (index.html) &lt;script src=&quot;/socket.io/socket.io.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var socket = io.connect(&#39;http://localhost&#39;); socket.on(&#39;news&#39;, function (data) { console.log(data); socket.emit(&#39;my other event&#39;, { my: &#39;data&#39; }); }); &lt;/script&gt; 不管是服务器还是客户端都有 emit 和 on 这两个函数，可以说 socket.io 的核心就是这两个函数了，通过 emit 和 on 可以轻松地实现服务器与客户端之间的双向通信。 emit ：用来发射一个事件或者说触发一个事件，第一个参数为事件名，第二个参数为要发送的数据，第三个参数为回调函数（一般省略，如需对方接受到信息后立即得到确认时，则需要用到回调函数）。on ：用来监听一个 emit 发射的事件，第一个参数为要监听的事件名，第二个参数为一个匿名函数用来接收对方发来的数据，该匿名函数的第一个参数为接收的数据，若有第二个参数，则为要返回的函数。socket.io 提供了三种默认的事件（客户端和服务器都有）：connect 、message 、disconnect 。当与对方建立连接后自动触发 connect 事件，当收到对方发来的数据后触发 message 事件（通常为 socket.send() 触发），当对方关闭连接后触发 disconnect 事件。 此外，socket.io 还支持自定义事件，毕竟以上三种事件应用范围有限，正是通过这些自定义的事件才实现了丰富多彩的通信。 最后，需要注意的是，在服务器端区分以下三种情况： socket.emit() ：向建立该连接的客户端广播socket.broadcast.emit() ：向除去建立该连接的客户端的所有客户端广播io.sockets.emit() ：向所有客户端广播，等同于上面两个的和 Vue.js在Vue的方面就比较常规了，Vue2.0+Vuex+axios+vue-router,我GitHub的有几个开源项目可以参考👉https://github.com/microzz 总结 组件状态多了用Vuex管理很方便，引用 Redux 的作者 Dan Abramov 的话说就是： Flux 架构就像眼镜：您自会知道什么时候需要它。 事先一定要先想好整个页面组成，怎样去分组件开发，这样在开发阶段会事半功倍。 Moment.js在Vue中用ES6的方式引入会有问题，可以尝试在main.js尝试这样import moment from &#39;moment&#39; Vue.prototype.moment = moment;给Vue的原型上添加moment，这样就可以在Vue的实例中随意使用它了。 get方式通过URL传参最好使用encodeURI对参数进行编码 一定要处理好那些异步操作，否则会带来各种问题。开发阶段使用的是Promise，上线时候使用了ES7的Async+Promise的组合，让异步操作更加合理。 源代码已经开源，GitHub 👉 https://github.com/microzz/vue-chat 📮 zhaohui@microzz.com 也可以关注我的GitHub获取最新情况 👉 https://github.com/microzz About个人网站：👉 microzz.com GitHub：👉 https://github.com/microzz","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://microzz.com/tags/Vue-js/"},{"name":"Koa2","slug":"Koa2","permalink":"https://microzz.com/tags/Koa2/"},{"name":"Socket.io","slug":"Socket-io","permalink":"https://microzz.com/tags/Socket-io/"}]},{"title":"iTerm2 快捷键大全","date":"2017-04-22T02:03:18.000Z","path":"2017/04/22/iterm2/","text":"iTerm2 快捷键大全 提升Mac开发效率标签新建标签：command + t 关闭标签：command + w 切换标签：command + 数字 command + 左右方向键 切换全屏：command + enter 查找：command + f 分屏垂直分屏：command + d 水平分屏：command + shift + d 切换屏幕：command + option + 方向键command + [ 或 command + ] 查看历史命令：command + ; 查看剪贴板历史：command + shift + h 其他清除当前行：ctrl + u 到行首：ctrl + a 到行尾：ctrl + e 前进后退：ctrl + f/b (相当于左右方向键) 上一条命令：ctrl + p 搜索命令历史：ctrl + r 删除当前光标的字符：ctrl + d 删除光标之前的字符：ctrl + h 删除光标之前的单词：ctrl + w 删除到文本末尾：ctrl + k 交换光标处文本：ctrl + t 清屏1：command + r 清屏2：ctrl + l 自带有哪些很实用的功能/快捷键⌘ + 数字 在各 tab 标签直接来回切换 选择即复制 + 鼠标中键粘贴，这个很实用 ⌘ + f 所查找的内容会被自动复制 ⌘ + d 横着分屏 /⌘ + shift + d 竖着分屏 ⌘ + r = clear，而且只是换到新一屏，不会想 clear 一样创建一个空屏 ctrl + u 清空当前行，无论光标在什么位置 输入开头命令后 按 ⌘ + ; 会自动列出输入过的命令 ⌘ + shift + h 会列出剪切板历史 可以在 Preferences &gt; keys 设置全局快捷键调出 iterm，这个也可以用过 Alfred 实现 常用的一些快捷键⌘ + 1 / 2 左右 tab 之间来回切换，这个在 前面 已经介绍过了 ⌘← / ⌘→ 到一行命令最左边/最右边 ，这个功能同 C+a / C+e ⌥← / ⌥→ 按单词前移/后移，相当与 C+f / C+b，其实这个功能在Iterm中已经预定义好了，⌥f / ⌥b，看个人习惯了 好像就这几个 设置方法如下 当然除了这些可以自定义的也不能忘了 linux 下那些好用的组合 C+a / C+e 这个几乎在哪都可以使用 C+p / !! 上一条命令 C+k 从光标处删至命令行尾 (本来 C+u 是删至命令行首，但iterm中是删掉整行) C+w A+d 从光标处删至字首/尾 C+h C+d 删掉光标前后的自负 C+y 粘贴至光标后 C+r 搜索命令历史，这个较常用 选中即复制iterm2 有 2 种好用的选中即复制模式。 一种是用鼠标，在 iterm2 中，选中某个路径或者某个词汇，那么，iterm2 就自 动复制了。 另一种是无鼠标模式，command+f,弹出 iterm2 的查找模式，输入要查找并复制的内容的前几个字母，确认找到的是自己的内容之后，输入 tab，查找窗口将自动变化内容，并将其复制。如果输入的是 shift+tab，则自动将查找内容的左边选中并复制。 自动完成输入打头几个字母，然后输入 command+; iterm2 将自动列出之前输入过的类似命令。 剪切历史输入 command+shift+h，iterm2 将自动列出剪切板的历史记录。如果需要将剪切板的历史记录保存到磁盘，在 Preferences &gt; General &gt; Save copy/paste history to disk 中设置。 About个人网站：👉 https://microzz.com/ GitHub：👉 https://github.com/microzz","tags":[{"name":"开发者","slug":"开发者","permalink":"https://microzz.com/tags/开发者/"},{"name":"Mac","slug":"Mac","permalink":"https://microzz.com/tags/Mac/"},{"name":"iTerm2","slug":"iTerm2","permalink":"https://microzz.com/tags/iTerm2/"}]},{"title":"原生JS中对象相关API合集","date":"2017-04-20T10:02:48.000Z","path":"2017/04/20/jsobject/","text":"原生JavaScript中对象相关API合集-对象篇现在jQuery已经没有那么有优势了，原生JS赶紧学起来😄附：👉原生JS中DOM节点相关API合集-DOM操作篇👉原生JS中CSS相关API合集-CSS操作篇 Object对象生成实例对象var o = new Object() 属性Object.prototype //返回原型对象 方法Object.keys(o) //遍历对象的可枚举属性 Object.getOwnPropertyName(o) //遍历对象不可枚举的属性 对象实例的方法valueOf // 返回当前对象对应的值。 toString // 返回当前对象对应的字符串形式。 toLocaleString // 返回当前对象对应的本地字符串形式。 hasOwnProperty // 判断某个属性是否为当前对象自身的属性，还是继承自原型对象的属性。 isPrototypeOf // 判断当前对象是否为另一个对象的原型。 propertyIsEnumerable // 判断某个属性是否可枚举。 Array对象生成实例对象var a = new Array() 属性a.length // 长度 Array.isArray()Array.isArray(a) // 用来判断一个值是否为数组 Array实例的方法a.valueof() // 返回数组本身 a.toString() // 返回数组的字符串形式 a.push(value,vlaue....) // 用于在数组的末端添加一个或多个元素， // 并返回添加新元素后的数组长度。 pop() // 用于删除数组的最后一个元素，并返回该元素 join() // 以参数作为分隔符，将所有数组成员组成一个字符串返回。 // 如果不提供参数，默认用逗号分隔。 concat() // 用于多个数组的合并。它将新数组的成员， // 添加到原数组的尾部，然后返回一个新数组，原数组不变。 shift() // 用于删除数组的第一个元素，并返回该元素。 unshift(value) // 用于在数组的第一个位置添加元素， // 并返回添加新元素后的数组长度。 reverse() // 用于颠倒数组中元素的顺序，返回改变后的数组 slice(start_index, upto_index) // 用于提取原数组的一部分，返回一个新数组，原数组不变。 // 第一个参数为起始位置（从0开始），第二个参数为终止位置 // （但该位置的元素本身不包括在内）。 // 如果省略第二个参数，则一直返回到原数组的最后一个成员。 // 负数表示倒数第几个。 splice(index, count_to_remove, addElement1, addElement2, ...); // 用于删除原数组的一部分成员，并可以在被删除的位置添加入新的数组成员， // 返回值是被删除的元素。第一个参数是删除的起始位置， // 第二个参数是被删除的元素个数。如果后面还有更多的参数， // 则表示这些就是要被插入数组的新元素。 sort() // 对数组成员进行排序，默认是按照字典顺序排序。 // 排序后，原数组将被改变。如果想让sort方法按照自定义方式排序， // 可以传入一个函数作为参数，表示按照自定义方法进行排序。 // 该函数本身又接受两个参数，表示进行比较的两个元素。 // 如果返回值大于0，表示第一个元素排在第二个元素后面； // 其他情况下，都是第一个元素排在第二个元素前面。 map() // 对数组的所有成员依次调用一个函数，根据函数结果返回一个新数组。 map(elem,index,arr) // map方法接受一个函数作为参数。 // 该函数调用时，map方法会将其传入三个参数， // 分别是当前成员、当前位置和数组本身。 forEach() // 遍历数组的所有成员，执行某种操作,参数是一个函数。 // 它接受三个参数，分别是当前位置的值、当前位置的编号和整个数组。 filter() // 参数是一个函数，所有数组成员依次执行该函数， // 返回结果为true的成员组成一个新数组返回。该方法不会改变原数组。 some() // 用来判断数组成员是否符合某种条件。 // 接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。 // 该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。 // 只要有一个数组成员的返回值是true，则整个some方法的返回值就是true，否则false。 every() // 用来判断数组成员是否符合某种条件。 // 接受一个函数作为参数，所有数组成员依次执行该函数，返回一个布尔值。 // 该函数接受三个参数，依次是当前位置的成员、当前位置的序号和整个数组。 // 所有数组成员的返回值都是true，才返回true，否则false。 reduce() // 依次处理数组的每个成员，最终累计为一个值。 // 从左到右处理（从第一个成员到最后一个成员） reduceRight() // 依次处理数组的每个成员，最终累计为一个值。 // 从右到左（从最后一个成员到第一个成员） indexOf(s) // 返回给定元素在数组中第一次出现的位置，如果没有出现则返回-1。 // 可以接受第二个参数，表示搜索的开始位置 lastIndexOf() // 返回给定元素在数组中最后一次出现的位置，如果没有出现则返回-1。 Number对象生成对象var n = new Number() Number对象的属性Number.POSITIVE_INFINITY // 正的无限，指向Infinity。 Number.NEGATIVE_INFINITY // 负的无限，指向-Infinity。 Number.NaN // 表示非数值，指向NaN。 Number.MAX_VALUE // 表示最大的正数，相应的，最小的负数为-Number.MAX_VALUE。 Number.MIN_VALUE // 表示最小的正数（即最接近0的正数，在64位浮点数体系中为5e-324）， // 相应的，最接近0的负数为-Number.MIN_VALUE。 Number.MAX_SAFE_INTEGER // 表示能够精确表示的最大整数，即9007199254740991。 Number.MIN_SAFE_INTEGER // 表示能够精确表示的最小整数，即-9007199254740991。 Number对象实例的方法toString() // 用来将一个数值转为字符串形式.可以接受一个参数，表示输出的进制。 // 如果省略这个参数，默认将数值先转为十进制，再输出字符串； // 否则，就根据参数指定的进制，将一个数字转化成某个进制的字符串。 toFixed() // 用于将一个数转为指定位数的小数，返回这个小数对应的字符串。 toExponential() // 用于将一个数转为科学计数法形式。 //可传入一个参数，参数表示小数点后有效数字的位数，范围为0到20， // 超出这个范围，会抛出一个RangeError。 toPrecision() // 用于将一个数转为指定位数的有效数字。 String 对象生成实例对象var s = new String() String对象的属性s.length //返回字符串的长度 方法s.chatAt(index) // 返回指定位置的字符 s.fromCharCode() // 该方法的参数是一系列Unicode码点，返回对应的字符串。 s.charCodeAt(index) // 返回给定位置字符的Unicode码点（十进制表示） s.concat(s2) // 用于连接两个字符串 s.slice(start,end) // 用于从原字符串取出子字符串并返回，不改变原字符串。 // 第一个参数是子字符串的开始位置，第二个参数是子字符串的结束位置（不含该位置）。 // 如果参数是负值，表示从结尾开始倒数计算的位置，即该负值加上字符串长度。 s.substring(start,end) // 用于从原字符串取出子字符串并返回，不改变原字符串. // 第一个参数表示子字符串的开始位置，第二个位置表示结束位置。 s.substr(start,length) // 用于从原字符串取出子字符串并返回，不改变原字符串。 // 第一个参数是子字符串的开始位置，第二个参数是子字符串的长度。 // 如果第一个参数是负数，表示倒数计算的字符位置。 // 如果第二个参数是负数，将被自动转为0，因此会返回空字符串。 s.indexOf(s) // 返回给定元素在字符串中第一次出现的位置，如果没有出现则返回-1。 // 可以接受第二个参数，表示搜索的开始位置 s.lastIndexOf() // 返回给定元素在字符串中最后一次出现的位置，如果没有出现则返回-1。 s.trim() // 用于去除字符串两端的空格，返回一个新字符串 s.toLowerCase() // 用于将一个字符串全部转为小写,返回一个新字符串，不改变原字符串。 s.toUpperCase() // 全部转为大写 s.localeCompare(s2) // 用于比较两个字符串。它返回一个整数，如果小于0，表示第一个字符串小于第二个字符串； // 如果等于0，表示两者相等；如果大于0，表示第一个字符串大于第二个字符串。 s.match(regexp) // 用于确定原字符串是否匹配某个子字符串，返回一个数组， // 成员为匹配的第一个字符串。如果没有找到匹配，则返回null。 s.search() // 返回值为匹配的第一个位置。如果没有找到匹配，则返回-1。 s.replace(oldValue,newValue) // 用于替换匹配的子字符串，一般情况下只替换第一个匹配 // （除非使用带有g修饰符的正则表达式）。 s.split() // 按照给定规则分割字符串，返回一个由分割出来的子字符串组成的数组。 // 还可传入第二个参数，决定了返回数组的成员数。 Math对象属性Math.E // 常数e。 Math.LN2 // 2的自然对数。 Math.LN10 // 10的自然对数。 Math.LOG2E // 以2为底的e的对数。 Math.LOG10E // 以10为底的e的对数。 Math.PI // 常数Pi。 Math.SQRT1_2 // 0.5的平方根。 Math.SQRT2 // 2的平方根。 数学方法Math.abs() // 返回参数的绝对值 Math.ceil() // 向上取整，接受一个参数，返回大于该参数的最小整数。 Math.floor() // 向下取整 Math.max(n,n1,...) // 可接受多个参数，返回最大值 Math.min(n,n1,..) // 可接受多个参数，返回最小值 Math.pow(n,e) // 指数运算, 返回以第一个参数为底数、第二个参数为幂的指数值。 Math.sqrt() // 返回参数值的平方根。如果参数是一个负值，则返回NaN。 Math.log() // 返回以e为底的自然对数值。 Math.exp() // 返回e的指数，也就是常数e的参数次方。 Math.round() // 四舍五入 Math.random() //返回0到1之间的一个伪随机数，可能等于0，但是一定小于1。 三角函数方法Math.sin() // 返回参数的正弦 Math.cos() // 返回参数的余弦 Math.tan() // 返回参数的正切 Math.asin() // 返回参数的反正弦（弧度值） Math.acos() // 返回参数的反余弦（弧度值） Math.atan() // 返回参数的反正切（弧度值） JSON对象方法JSON.stringify() // 用于将一个值转为字符串。该字符串应该符合JSON格式，并且可以被JSON.parse方法还原。 //（JSON.stringify(obj, selectedProperties)）还可以接受一个数组， // 作为第二个参数，指定需要转成字符串的属性。 // 还可以接受第三个参数，用于增加返回的JSON字符串的可读性。 // 如果是数字，表示每个属性前面添加的空格（最多不超过10个）； // 如果是字符串（不超过10个字符），则该字符串会添加在每行前面。 JSON.parse() //用于将JSON字符串转化成对象。 console对象方法console.log(text,text2,...) // 用于在console窗口输出信息。 // 它可以接受多个参数，将它们的结果连接起来输出。 // 如果第一个参数是格式字符串（使用了格式占位符）， // console.log方法将依次用后面的参数替换占位符，然后再进行输出。 console.info() // 在console窗口输出信息， // 同时，会在输出信息的前面，加上一个蓝色图标。 console.debug() // 在console窗口输出信息， // 同时，会在输出信息的前面，加上一个蓝色图标。 console.warn() // 输出信息时，在最前面加一个黄色三角，表示警告； console.error() // 输出信息时，在最前面加一个红色的叉， // 表示出错，同时会显示错误发生的堆栈 console.table() // 可以将复合类型的数据转为表格显示。 console.count() // 用于计数，输出它被调用了多少次。 console.dir() // 用来对一个对象进行检查（inspect）， // 并以易于阅读和打印的格式显示。 console.dirxml() // 用于以目录树的形式，显示DOM节点。 console.assert() // 接受两个参数，第一个参数是表达式，第二个参数是字符串。 // 只有当第一个参数为false，才会输出第二个参数，否则不会有任何结果。 // 这两个方法用于计时，可以算出一个操作所花费的准确时间。 console.time() console.timeEnd() // time方法表示计时开始，timeEnd方法表示计时结束。 // 它们的参数是计时器的名称。 // 调用timeEnd方法之后，console窗口会显示“计时器名称: // 所耗费的时间”。 console.profile() // 用来新建一个性能测试器（profile）， // 它的参数是性能测试器的名字。 console.profileEnd() // 用来结束正在运行的性能测试器。 console.group() console.groupend() // 上面这两个方法用于将显示的信息分组。 // 它只在输出大量信息时有用，分在一组的信息，可以用鼠标折叠/展开。 console.groupCollapsed() // 用于将显示的信息分组，该组的内容， //在第一次显示时是收起的（collapsed），而不是展开的。 console.trace() // 显示当前执行的代码在堆栈中的调用路径。 console.clear() // 用于清除当前控制台的所有输出，将光标回置到第一行。 AboutGitHub：👉 https://github.com/microzz个人网站：👉 https://microzz.com/","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"Object","slug":"Object","permalink":"https://microzz.com/tags/Object/"}]},{"title":"Vue.js打造一个开源的CNode社区","date":"2017-04-17T09:04:19.000Z","path":"2017/04/17/vue-cnode/","text":"Vue.js打造一个开源的CNode社区Vue.js打造一个开源的CNode社区，实现了浏览、发帖、收藏、回复、点赞、个人中心等等功能。 源代码源代码地址：👉 https://github.com/microzz/vue-cnode 欢迎大家star和fork😄 预览在线预览地址：👉 https://microzz.com/vue-cnode/ 技术栈 Vue2.0：前端页面展示。 Vuex：Vuex，实现不同组件间的状态共享 vue-router：页面路由切换 axios：一个基于 Promise 的 HTTP 库，向后端发起请求。 Express、Koa2：因为vue-cli生成的项目是基于express的，所以在开发阶段我使用的是它，但是真正上线生产环境我换成了Koa2。 Moment.js：一个时间处理的库，方便对时间进行格式化成需要的格式，如主题、回复时间显示” 分钟前、 小时前、*天前”等等。 ES6、ES7：采用ES6语法，这是以后的趋势。箭头函数、Promise等等语法很好用。 localStorage：保存用户信息。 Canvas：页面顶部小雪花效果。 Webpack：vue-cli自带Webpack，但是需要自己改造一下，比如要对需要安装sass相关loader，vue-cli已经配置好了webpack，你只需要安装依赖就可以，使用的时候只需要&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt;。 SASS(SCSS)：用SCSS做CSS预处理语言，有些地方很方便，个人很喜欢用。(详看👉SASS用法指南) flex：flex弹性布局，简单适配手机、PC端。 CSS3：CSS3过渡动画及样式。 总结 组件状态多了用Vuex管理很方便，引用 Redux 的作者 Dan Abramov 的话说就是： Flux 架构就像眼镜：您自会知道什么时候需要它。 事先一定要先想好整个页面组成，怎样去分组件开发，这样在开发阶段会事半功倍。 Moment.js在Vue中用ES6的方式引入会有问题，可以尝试在main.js尝试这样import moment from &#39;moment&#39; Vue.prototype.moment = moment;给Vue的原型上添加moment，这样就可以在Vue的实例中随意使用它了。 项目结构如下图 Vue-CNode 时间轨迹 4.13：基本功能完成，后续完成登录后的操作。 4.14：完成登录以及侧边栏。 4.15：增加收藏 4.16：加入回复、单条回复、点赞。项目完成。 About源代码地址：👉 GitHub 个人网站：👉 microzz.com GitHub：👉 microzz Build Setup# install dependencies npm install # serve with hot reload at localhost:8080 npm run dev # build for production with minification npm run build # build for production and view the bundle analyzer report npm run build --report","tags":[{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://microzz.com/tags/Vue-js/"},{"name":"SCSS","slug":"SCSS","permalink":"https://microzz.com/tags/SCSS/"},{"name":"Vuex","slug":"Vuex","permalink":"https://microzz.com/tags/Vuex/"}]},{"title":"原生JS中CSS相关API合集","date":"2017-04-14T14:42:43.000Z","path":"2017/04/14/jscss/","text":"原生JS中CSS相关API合集-CSS操作篇类名操作//ie8以下 Element.className //获取元素节点的类名 Element.className += &#39; &#39; + newClassName //新增一个类名 //判断是否有某个类名 function hasClass(element,className){ return new RegExp(className,&#39;gi&#39;).test(element.className); } //移除class function removeClass(element,className){ element.className = element.className.replace(new RegExp(&#39;(^|\\\\b)&#39; + className.split(&#39; &#39;).join(&#39;|&#39;) + &#39;(\\\\b|$)&#39;, &#39;gi&#39;),&#39;&#39;); } //ie10 element.classList.add(className) //新增 element.classList.remove(className) //删除 element.classList.contains(className) //是否包含 element.classList.toggle(className) //toggle class style操作element.setAttribute(&#39;style&#39;,&#39;&#39;) element.style.backgroundColor = &#39;red&#39; element.style.cssText //用来读写或删除整个style属性 element.style.setProperty(propertyName,value) //设置css属性 element.style.getPropertyValue(property) //获取css属性 element.style.removeProperty(property) //删除css属性 操作非内联样式 //ie8 element.currentStyle[attrName] //ie9+ window.getComputedStyle(el,null)[attrName] window.getComputedStyle(el,null).getPropertyValue(attrName) //伪类 window.getComputedStyle(el,&#39;:after&#39;)[attrName] 附录👉 原生JS中DOM节点相关API合集 About个人网站：👉 https://microzz.com/ GitHub：👉 https://github.com/microzz","tags":[{"name":"API","slug":"API","permalink":"https://microzz.com/tags/API/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"CSS","slug":"CSS","permalink":"https://microzz.com/tags/CSS/"}]},{"title":"上手Weex踩到的坑 长期更新","date":"2017-04-12T00:56:29.000Z","path":"2017/04/12/weex-start/","text":"上手Weex踩到的坑 长期更新weex-toolkit VS weexpack官方出了两个脚手架工具：weex-toolkit、weexpack。 weex-toolkit 是官方提供的一个脚手架命令行工具，你可以使用它进行 Weex 项目的创建，调试以及打包等功能。 weexpack 是基于 Weex 快速搭建应用原型的利器。它能够帮助开发者通过命令行创建 Weex 工程，添加相应平台的 Weex app 模版，并基于模版从本地，GitHub 或者 Weex 应用市场安装插件，快速打包 Weex 应用并安装到手机运行，对于具有分享精神的开发者而言还能够创建 Weex 插件模版并发布插件到 Weex 应用市场。 官网是这样描述它们的 &nbsp;&nbsp;&nbsp;&nbsp;现在使用 weex-toolkit 同样支持对 weexpack 的命令调用,如果你当前的项目与 weexpack 生成的项目目录一致，那么你可以直接实现对于 platform 的操作，从而构建具体的 Android/IOS app 。 请注意，说的是如果你当前的项目与 weexpack 生成的项目目录一致，但是实际上它们生成的项目目录并不一样，构建Android和IOS项目会失败。而且官网教程中有的使用weex命令，有的使用weexpack命令，对于刚上手的人来说不友好。看官方3.22在Issues中回复说 &nbsp;&nbsp;&nbsp;&nbsp;确实我们内部在争论目录一致性，后期我们希望让两者的目录保持一致性，或者通过检查的形式自动补全缺损的目录，从而让它们一致。 希望尽早统一目录或者合并这两个工具吧😄 安装源问题安装完weex-toolki和weexpack两个工具之后，生成项目没什么问题，但是打包到真机运行就出现了问题，非常莫名其妙的各种错误。于是用npm命令 npm list -g --depth 0 查看这两个全局安装的包的情况，发现大量相关依赖报错。我是淘宝源cnpm全局安装这两个工具的，按道理都是阿里的东西，应该不会有什么问题。看了一下官方GitHub的Issues，发现也有一样的情况。于是立马卸载这两个全局安装的工具：npm uninstall weex-toolkit -g npm uninstall weexpack -g， 然后开翻墙，重新安装这两个工具，虽然速度慢一点，但是安装完之后再次npm list -g --depth 0 至少不会报错了。 然后再生成项目，真机运行，一切就正常了。。。","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://microzz.com/tags/Vue-js/"},{"name":"npm","slug":"npm","permalink":"https://microzz.com/tags/npm/"},{"name":"Weex","slug":"Weex","permalink":"https://microzz.com/tags/Weex/"}]},{"title":"Vue做一个GitHub项目排行榜","date":"2017-04-10T11:41:53.000Z","path":"2017/04/10/github-ranking/","text":"Vue做一个GitHub项目排行榜GitHub不同语言热门项目排行，Vue做页面展示。 源代码源代码地址：🔗 GitHub欢迎大家 star和fork😄 预览地址在线效果预览地址：https://microzz.com/github-ranking/ 技术栈 Vue2.0：前端页面展示。 axios：一个基于 Promise 的 HTTP 库，向后端发起请求。 Express、Koa2：因为vue-cli生成的项目是基于express的，所以在开发阶段我使用的是它，但是真正上线生产环境我换成了Koa2。 request、request-promise：没有用Node.js原生的http/https模块是因为不喜欢回调函数式的异步，可读性和可维护性很差。所以选择了request+request-promise，让异步更为优雅一点。 cheerio：服务器特别定制的，快速、灵活、实施的jQuery核心实现，抓取页面内容很方便。 SASS(SCSS)：用SCSS做CSS预处理语言，有些地方很方便，个人很喜欢用。(详看👉SASS用法指南) ES6、ES7：采用ES6语法，这是以后的趋势。自己上线的生产环境后端增加了Async/await，使异步更加优雅。 Webpack：vue-cli自带Webpack，但是需要自己改造一下，比如要对 build/dev-server.js扩展express，增加后端请求路由(上线版本用的是Koa2)。此外需要安装sass相关loader，vue-cli已经配置好了webpack，你只需要安装依赖就可以，使用的时候只需要&lt;style lang=&quot;scss&quot;&gt;&lt;/style&gt;。 flex：flex弹性布局。 CSS3：CSS3过渡动画及样式。 遇到的问题 异步操作很容易出问题，异步处理一定要小心！要熟练掌握Promise、Async/await、Generator等方法。(详看👉异步操作和Async函数、Promise对象、Generator 函数) 因为访问每次爬取GitHub速度慢，性能差，所以建议使用缓存，把爬取到的数据保存为json文件或者其他缓存方式，我在上线的正式版是保存为json文件。那么这个时候就要有一个定时爬取的工具了，这里推荐node-schedule模块，很方便就能实现定时任务，查看官方文档就能简单上手了。上线版本我是每隔几个小时就爬取一次，然后保存数据，这样减轻了服务器压力，前端访问速度也大大加快。 GitHub貌似最多只能有10个并发，我尝试9个是正常的，10个就会报错，刚好我一次性爬取的语言数目超过数目，一看报错信息是429状态码。查信息发现： &nbsp;&nbsp;&nbsp;&nbsp;429 Too Many Requests (太多请求)当你需要限制客户端请求某个服务的数量，也就是限制请求速度时，该状态码就会非常有用。在此之前，有一些类似的状态码。例如“509 Bandwidth Limit Exceeded”。 所以一定好处理好这些异步请求，不然就爬取不到信息缓存了。 About源代码地址：👉 GitHub 个人网站：🔗microzz-IT技术分享 GitHub：🔗microzz Build Setup# install dependencies npm install # serve with hot reload at localhost:8080 npm run dev # build for production with minification npm run build # build for production and view the bundle analyzer report npm run build --report","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://microzz.com/tags/Vue-js/"},{"name":"SASS","slug":"SASS","permalink":"https://microzz.com/tags/SASS/"},{"name":"SCSS","slug":"SCSS","permalink":"https://microzz.com/tags/SCSS/"},{"name":"Koa2","slug":"Koa2","permalink":"https://microzz.com/tags/Koa2/"}]},{"title":"Vue.js音乐播放器升级版","date":"2017-04-07T23:08:28.000Z","path":"2017/04/08/vue-music2/","text":"Vue.js音乐播放器2.0升级版之前初学Vue做了一个音乐播放器，受到不少人的喜欢。现在升级版来了！功能更强，技术栈更多。 源代码源代码地址：👉 GitHub欢迎大家star和follow😄 预览在线预览在线预览地址：👉 Vue音乐播放器 预览图 Vue音乐播放器升级版 更多预览图请看👉 更多 技术栈Vue2：采用最新Vue2的语法😁Vuex：实现不同组件之间的状态共享✌️vue-router：单页应用路由管理必备😎axios：发起http请求😉SASS(SCSS)：css预处理语言💪Express(上线版本是Koa2)：因为vue-cli是用的Express做服务器，所以开源的开发版本是Express，自己生产环境用的是Koa2。 😜Webpack：自动化构建工具，大部分配置vue-cli脚手架已经弄好了，很方便。😏ES6：采用ES6语法，这是趋势。👏localStorage(HTML5)：本地存储，保存用户个性化设置。😊CSS3：CSS3动画及样式。👍 使用 Build Setup# install dependencies npm install # serve with hot reload at localhost:8080 npm run dev # build for production with minification npm run build # build for production and view the bundle analyzer report npm run build --report 遇到的问题 vuex什么时候使用，如何使用，就要看项目需要。引用 Redux 的作者 Dan Abramov 的话说就是： Flux 架构就像眼镜：您自会知道什么时候需要它。 各组件之间状态共享也是难点。 异步编程：JS是单线程，异步编程尤为重要。当我们向后端请求数据，是异步的，如果没有处理好相关的异步操作，是会有各种问题的。JS可以利用setTimeout、回调、Generator、Promise、Async。定时这种方式太麻烦，还是不推荐；回调层次多了，有回调地狱，代码维护性很差；Generator需要手动去执行，当然可以使用类似co的模块。相比之下Promise和Async是比较理想的。(详看👉Promise对象、异步操作和Async函数) 本项目中使用了QQ音乐和One(一个)的接口，后端API编写也是难点，包含了各种异步请求。对返回数据的解析也是难点，有的时候你还需要对数据进行解码。 各组件结构的设计：一开始大纲没设计好，后面想修改涉及面会很广。 过渡动画让交互更有趣，但是有的还是耗性能的，有设备差异，没用好会造成卡顿。 【声明】：本项目仅供学习交流，请不要用做任何商业用途😊有任何疑问请联系作者📩zhaohui@microzz.com About源代码地址：👉 GitHub个人网站：🔗microzz-IT技术分享GitHub：🔗microzz","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"https://microzz.com/tags/HTML5/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://microzz.com/tags/Vue-js/"},{"name":"SASS","slug":"SASS","permalink":"https://microzz.com/tags/SASS/"},{"name":"SCSS","slug":"SCSS","permalink":"https://microzz.com/tags/SCSS/"}]},{"title":"原生JS中DOM节点相关API合集","date":"2017-04-06T12:14:10.000Z","path":"2017/04/06/jsdom/","text":"原生JS中DOM节点相关API合集节点属性Node.nodeName //返回节点名称，只读 Node.nodeType //返回节点类型的常数值，只读 Node.nodeValue //返回Text或Comment节点的文本值，只读 Node.textContent //返回当前节点和它的所有后代节点的文本内容，可读写 Node.baseURI //返回当前网页的绝对路径 Node.ownerDocument //返回当前节点所在的顶层文档对象，即document Node.nextSibling //返回紧跟在当前节点后面的第一个兄弟节点 Node.previousSibling //返回当前节点前面的、距离最近的一个兄弟节点 Node.parentNode //返回当前节点的父节点 Node.parentElement //返回当前节点的父Element节点 Node.childNodes //返回当前节点的所有子节点 Node.firstChild //返回当前节点的第一个子节点 Node.lastChild //返回当前节点的最后一个子节点 //parentNode接口 Node.children //返回指定节点的所有Element子节点 Node.firstElementChild //返回当前节点的第一个Element子节点 Node.lastElementChild //返回当前节点的最后一个Element子节点 Node.childElementCount //返回当前节点所有Element子节点的数目。 操作Node.appendChild(node) //向节点添加最后一个子节点 Node.hasChildNodes() //返回布尔值，表示当前节点是否有子节点 Node.cloneNode(true); // 默认为false(克隆节点), true(克隆节点及其属性，以及后代) Node.insertBefore(newNode,oldNode) // 在指定子节点之前插入新的子节点 Node.removeChild(node) //删除节点，在要删除节点的父节点上操作 Node.replaceChild(newChild,oldChild) //替换节点 Node.contains(node) //返回一个布尔值，表示参数节点是否为当前节点的后代节点。 Node.compareDocumentPosition(node) //返回一个7个比特位的二进制值，表示参数节点和当前节点的关系 Node.isEqualNode(noe) //返回布尔值，用于检查两个节点是否相等。所谓相等的节点，指的是两个节点的类型相同、属性相同、子节点相同。 Node.normalize() //用于清理当前节点内部的所有Text节点。它会去除空的文本节点，并且将毗邻的文本节点合并成一个。 //ChildNode接口 Node.remove() //用于删除当前节点 Node.before() // Node.after() Node.replaceWith() Document节点Document节点的属性document.doctype // document.documentElement //返回当前文档的根节点 document.defaultView //返回document对象所在的window对象 document.body //返回当前文档的&lt;body&gt;节点 document.head //返回当前文档的&lt;head&gt;节点 document.activeElement //返回当前文档中获得焦点的那个元素。 //节点集合属性 document.links //返回当前文档的所有a元素 document.forms //返回页面中所有表单元素 document.images //返回页面中所有图片元素 document.embeds //返回网页中所有嵌入对象 document.scripts //返回当前文档的所有脚本 document.styleSheets //返回当前网页的所有样式表 //文档信息属性 document.documentURI //表示当前文档的网址 document.URL //返回当前文档的网址 document.domain //返回当前文档的域名 document.lastModified //返回当前文档最后修改的时间戳 document.location //返回location对象，提供当前文档的URL信息 document.referrer //返回当前文档的访问来源 document.title //返回当前文档的标题 document.characterSet属性返回渲染当前文档的字符集，比如UTF-8、ISO-8859-1。 document.readyState //返回当前文档的状态 document.designMode //控制当前文档是否可编辑，可读写 document.compatMode //返回浏览器处理文档的模式 document.cookie //用来操作Cookie Document节点的方法读写方法document.open() //用于新建并打开一个文档 document.close() //不安比open方法所新建的文档 document.write() //用于向当前文档写入内容 document.writeIn() //用于向当前文档写入内容，尾部添加换行符。 查找节点document.querySelector(selectors) //接受一个CSS选择器作为参数，返回第一个匹配该选择器的元素节点。 document.querySelectorAll(selectors) //接受一个CSS选择器作为参数，返回所有匹配该选择器的元素节点。 document.getElementsByTagName(tagName) //返回所有指定HTML标签的元素 document.getElementsByClassName(className) //返回包括了所有class名字符合指定条件的元素 document.getElementsByName(name) //用于选择拥有name属性的HTML元素（比如&lt;form&gt;、&lt;radio&gt;、&lt;img&gt;、&lt;frame&gt;、&lt;embed&gt;和&lt;object&gt;等） document.getElementById(id) //返回匹配指定id属性的元素节点。 document.elementFromPoint(x,y) //返回位于页面指定位置最上层的Element子节点。 生成节点document.createElement(tagName) //用来生成HTML元素节点。 document.createTextNode(text) //用来生成文本节点 document.createAttribute(name) //生成一个新的属性对象节点，并返回它。 document.createDocumentFragment() //生成一个DocumentFragment对象 （4）事件方法 document.createEvent(type) //生成一个事件对象，该对象能被element.dispatchEvent()方法使用 document.addEventListener(type,listener,capture) //注册事件 document.removeEventListener(type,listener,capture) //注销事件 document.dispatchEvent(event) //触发事件 其他document.hasFocus() //返回一个布尔值，表示当前文档之中是否有元素被激活或获得焦点。 document.adoptNode(externalNode) //将某个节点，从其原来所在的文档移除，插入当前文档，并返回插入后的新节点。 document.importNode(externalNode, deep) //从外部文档拷贝指定节点，插入当前文档。 Element节点Element节点的属性特性属性Element.attributes //返回当前元素节点的所有属性节点 Element.id //返回指定元素的id属性，可读写 Element.tagName //返回指定元素的大写标签名 Element.innerHTML //返回该元素包含的HTML代码，可读写 Element.outerHTML //返回指定元素节点的所有HTML代码，包括它自身和包含的的所有子元素，可读写 Element.className //返回当前元素的class属性，可读写 Element.classList //返回当前元素节点的所有class集合 Element.dataset //返回元素节点中所有的data-*属性。 尺寸属性Element.clientHeight //返回元素节点可见部分的高度 Element.clientWidth //返回元素节点可见部分的宽度 Element.clientLeft //返回元素节点左边框的宽度 Element.clientTop //返回元素节点顶部边框的宽度 Element.scrollHeight //返回元素节点的总高度 Element.scrollWidth //返回元素节点的总宽度 Element.scrollLeft //返回元素节点的水平滚动条向右滚动的像素数值,通过设置这个属性可以改变元素的滚动位置 Element.scrollTop //返回元素节点的垂直滚动向下滚动的像素数值 Element.offsetHeight //返回元素的垂直高度(包含border,padding) Element.offsetWidth //返回元素的水平宽度(包含border,padding) Element.offsetLeft //返回当前元素左上角相对于Element.offsetParent节点的垂直偏移 Element.offsetTop //返回水平位移 Element.style //返回元素节点的行内样式 节点相关属性Element.children //包括当前元素节点的所有子元素 Element.childElementCount //返回当前元素节点包含的子HTML元素节点的个数 Element.firstElementChild //返回当前节点的第一个Element子节点 Element.lastElementChild //返回当前节点的最后一个Element子节点 Element.nextElementSibling //返回当前元素节点的下一个兄弟HTML元素节点 Element.previousElementSibling //返回当前元素节点的前一个兄弟HTML节点 Element.offsetParent //返回当前元素节点的最靠近的、并且CSS的position属性不等于static的父元素。 Element节点的方法位置方法getBoundingClientRect() // getBoundingClientRect返回一个对象，包含top,left,right,bottom,width,height // width、height 元素自身宽高 // top 元素上外边界距窗口最上面的距离 // right 元素右外边界距窗口最上面的距离 // bottom 元素下外边界距窗口最上面的距离 // left 元素左外边界距窗口最上面的距离 // width 元素自身宽(包含border,padding) // height 元素自身高(包含border,padding) getClientRects() //返回当前元素在页面上形参的所有矩形。 // 元素在页面上的偏移量 var rect = el.getBoundingClientRect() return { top: rect.top + document.body.scrollTop, left: rect.left + document.body.scrollLeft } 属性方法Element.getAttribute()：读取指定属性 Element.setAttribute()：设置指定属性 Element.hasAttribute()：返回一个布尔值，表示当前元素节点是否有指定的属性 Element.removeAttribute()：移除指定属性 查找方法Element.querySelector() Element.querySelectorAll() Element.getElementsByTagName() Element.getElementsByClassName() 事件方法Element.addEventListener()：添加事件的回调函数 Element.removeEventListener()：移除事件监听函数 Element.dispatchEvent()：触发事件 //ie8 Element.attachEvent(oneventName,listener) Element.detachEvent(oneventName,listener) // event对象 var event = window.event||event; // 事件的目标节点 var target = event.target || event.srcElement; // 事件代理 ul.addEventListener(&#39;click&#39;, function(event) { if (event.target.tagName.toLowerCase() === &#39;li&#39;) { console.log(event.target.innerHTML) } }); 其他Element.scrollIntoView() //滚动当前元素，进入浏览器的可见区域 //解析HTML字符串，然后将生成的节点插入DOM树的指定位置。 Element.insertAdjacentHTML(where, htmlString); Element.insertAdjacentHTML(&#39;beforeBegin&#39;, htmlString); // 在该元素前插入 Element.insertAdjacentHTML(&#39;afterBegin&#39;, htmlString); // 在该元素第一个子元素前插入 Element.insertAdjacentHTML(&#39;beforeEnd&#39;, htmlString); // 在该元素最后一个子元素后面插入 Element.insertAdjacentHTML(&#39;afterEnd&#39;, htmlString); // 在该元素后插入 Element.remove() //用于将当前元素节点从DOM中移除 Element.focus() //用于将当前页面的焦点，转移到指定元素上 👉GitHub","tags":[{"name":"API","slug":"API","permalink":"https://microzz.com/tags/API/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"DOM","slug":"DOM","permalink":"https://microzz.com/tags/DOM/"}]},{"title":"为Array对象添加一个去除重复项的方法","date":"2017-04-01T14:34:16.000Z","path":"2017/04/01/array-uniq/","text":"为 Array 对象上添加一个去除重复项的方法输入例子[false, true, undefined, null, NaN, 0, 1, {}, {}, &#39;a&#39;, &#39;a&#39;, NaN].uniq() 输出例子[false, true, undefined, null, NaN, 0, 1, {}, {}, &#39;a&#39;] 分析题目要求给 Array 添加方法，所以我们需要用到 prototype。数组去重本身算法不是很难，但是在 JavaScript 中很多人会忽视 NaN 的存在，因为在 JS 中 NaN !== NaN 。但是在去重中我们又不能保留两个 NaN ，所以需要进行一下判断，这是很多人容易忽视的。ES5的实现如下： 代码Array.prototype.uniq = function () { var arr = []; var flag = true; this.forEach(function(item) { // 排除 NaN (重要！！！) if (item != item) { flag &amp;&amp; arr.indexOf(item) === -1 ? arr.push(item) : &#39;&#39;; flag = false; } else { arr.indexOf(item) === -1 ? arr.push(item) : &#39;&#39; } }); return arr; } 验证我们只需要在数组上直接调用 uniq 方法就可以了，如： [false, true, undefined, null, NaN, 0, 1, {}, {}, &#39;a&#39;, &#39;a&#39;, NaN].uniq() 结果为： [false, true, undefined, null, NaN, 0, 1, {}, {}, &#39;a&#39;] 进阶ES6的实现ES6新增了 Set 对象，也就是我们所说的“集合”，它类似于数组，但是成员的值都是唯一的，没有重复的值。所以可以方便去重。Set本身是一个构造函数，用来生成Set数据结构。(详看👉Set和Map数据结构) 如果用ES6为 Array 对象添加一个去除重复项的方法，则可以如下实现： Array.prototype.uniq = function() { return Array.from(new Set(this)); } 代码中用 Array.from 把 Set 结构转换成数组，当然，你也可以用其他方法，这里不深究。这里去重关键代码只需要一行，是不是非常简单？😄如果你要优雅一点，可以使用 ES6 的扩展运算符。如下： Array.prototype.uniq = function() { return [...new Set(this)]; }","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"prototype","slug":"prototype","permalink":"https://microzz.com/tags/prototype/"},{"name":"原型链","slug":"原型链","permalink":"https://microzz.com/tags/原型链/"}]},{"title":"ReactJS新闻App","date":"2017-03-29T11:58:19.000Z","path":"2017/03/29/react-news/","text":"ReactNewsApp介绍一个由React.js编写的新闻WebApp。A news WebApp by React.js.本应用仅供学习，请不要用于商业用途，供学习交流😁因为技术有限，所以可能有好多不足，欢迎提建议哦😄 👉 项目地址 技术栈React.js组件化开发项目采用组件化的思想，把大的功能模块划分成一个个小的模块，便于团队合作和维护。 react-router路由管理路由库React-Router，它是官方维护的，事实上也是唯一可选的路由库。它通过管理 URL，实现组件的切换和状态的变化，开发复杂的应用几乎肯定会用到，特别是SPA(单页应用) antd使页面更加美观Ant Design 是蚂蚁金服开发和正在使用的一套企业级的前端设计语言和基于 React 的前端框架实现。 特性 企业级金融产品的交互语言和视觉体系。 丰富实用的 React UI 组件。 基于 React 的组件化开发模式。 背靠 npm 生态圈。 基于 webpack 的调试构建方案，支持 ES6。 WebpackWebpack作为构建工具 ES6语法全面采用ES6语法 开始本项目以慕课网视频为原型开发，大家可以发挥想象改进功能😄 下载下来之后，先安装依赖 npm install 或者 cnpm install，然后： npm run dev or npm run build 预览PC端 react-news 手机端 react-news 👉 个人技术网站👉GitHub","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"ReactJS","slug":"ReactJS","permalink":"https://microzz.com/tags/ReactJS/"}]},{"title":"JS中一个运算符优先级问题引发的思考","date":"2017-03-25T11:32:46.000Z","path":"2017/03/25/operator/","text":"JavaScript中一个运算符优先级问题引发的思考题目 假设 val 已经声明,可定义为任何值。则下面js代码有可能输出的结果为: console.log(&#39;Value is &#39; + (val != &#39;0&#39;) ? &#39;define&#39; : &#39;undefine&#39;); A. Value is defineB. Value is undefineC. defineD. undefineE. Value is define 或者 Value is undefineF. define 或者 undefineG. 其它选项都有可能 如果是你，你会选什么呢？ 可以说，大部分人都会在A、B、E中选择，以为重点在后面的三目运算符，前面字符串原样输出就是了。但是答案是 C 。 分析因为我们忽略了运算符的优先级。要知道，加号 + 优先级高于三目运算 ? :，低于括号 ()。不管 (val != &#39;0&#39;) 的真假，&#39;Value is &#39; + (val != &#39;0&#39;) 是一个字符串并且转换成布尔值一定是 true ！ 下面我们来具体分析里面的每一部分。 先来看看括号里面的情况，题目已经说了： 假设 val 已经声明,可定义为任何值。 所以，(val != &#39;0&#39;) 的值可以是 true 或者 false ，那么这个就涉及到JavaScript的一些隐式转换逻辑。 众所周知， 0 == &#39;0&#39; // true null == undefined // true false == &#39;0&#39; // true 常用的隐式转换逻辑x+&quot;&quot; //等价于String（x） +x //等价于Number（x），也可以写成x-0 !!x //等价于Boolean(x) 附录 - Javascript类型转换 值 转换为：字符串 数字 布尔值 对象 undefined “undefined” NaN false throws TypeError null “null” 0 false TypeError true “true” 1 new Boolean(true) false “false” 0 new Boolean(false) “”空字符串 0 false new String(“”) “1.2”（非空，数字） 1.2 true new String(“1.2”) “one”（非空，非数字） NaN true new String(“one”) 0 “0” false Number(0) -0 “0” false Number(-0) NaN “NaN” false new Number(NaN) Infinity “Infinity” true new Number(Infinity) -Infinity “-Infinity” true new Number(-Infinity) 1（无穷大，非零） “1” true new Number(1) {}（任意对象） true []（任意数组） “” 0 true [9]（1个数字对象） “9” 9 true [‘a’]（其他数组） 使用join（）方法 NaN true function（）｛｝（任意函数） NaN true 回到本题条件永远为真，并且只输出 &#39;define&#39; Boolean还有一个需要注意的地方 下面程序的显示结果是？ var x = new Boolean(false); if (x) { alert(&#39;hi&#39;); } var y = Boolean(0); if (y) { alert(&#39;hello&#39;); } x为Boolean对象，在if语句里的判断为true，虽然x的值为false，但是作为对象，if会直接判断为true。y为Boolean值，在if里的判断就是false值。所以会显示 &#39;hi&#39;。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"Boolean","slug":"Boolean","permalink":"https://microzz.com/tags/Boolean/"}]},{"title":"【面试题】创建长度为100的数组","date":"2017-03-24T10:57:25.000Z","path":"2017/03/24/create-arr/","text":"不用循环创建一个长度为100的数组，并且每个元素的值等于它的下标先来说一下最直接的解法… var arr = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99]; … 接下来转入正题。。。 传统for循环来说一下传统的for循环： var arr = new Array(100) for (var i = 0; i &lt; arr.length; i++) { arr[i] = i; } arr; // [0, 1, ..., 99] 想必大家都没什么问题👍 不用for循环但是如何不用for循环实现呢？ ES5的实现Object.keys(Array.from({ length: 100 })); // [&quot;0&quot;, &quot;1&quot;, &quot;2&quot;, ..., &quot;98&quot;, &quot;99&quot;] 什么？Array.from是ES6的？没事，我们可以换成ES5的😄 Object.keys( Array.apply(null,{ length: 100 })); 这样似乎的确完成了功能，但是还有一个问题，此时值是字符串类型，所以我们可以用ES5的map方法进行处理一下： Object.keys(Array.from({ length: 100 })).map(function(item) { return +item; }); 这里用了一个小技巧，字符串前面加一个 “+” 就可以转成数字。如果你不喜欢这样，可以使用parseInt，也是一样的效果。 ES6的实现普通实现ES6中数组实例有keys、values、entries方法，分别用于遍历数组的索引、键值、键值对，它们都返回遍历器对象（详细👉Iterator和for…of循环） 因此我们可以用ES6的Array.from转成数组： Array.from(new Array(100).keys()); Array.from其实还有一个回调函数，可以很方便遍历处理每一个数据 Array.from({ length: 100 }, (v, i) =&gt; i); Array.from(Array(100), (v, i) =&gt; i); // [0, 1, 2, ..., 98, 99] 优雅进阶 - 扩展运算符ES6新增 ... 扩展运算符，极大方便了相关操作(详见👉函数的扩展里面的扩展运算符) 因此我们可以更加优雅地实现： [...Array(100).keys()] 或者 [...Array.from({ length: 100 }).keys()] 思路就是这样，当然我们还可以混合搭配出各种解法，甚至ES5、ES6混合😂有可能还有各种奇妙解法，每个人去细细专研吧😊","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"Array","slug":"Array","permalink":"https://microzz.com/tags/Array/"},{"name":"ECMAScrpt6","slug":"ECMAScrpt6","permalink":"https://microzz.com/tags/ECMAScrpt6/"}]},{"title":"React和Vue对比","date":"2017-03-22T15:23:29.000Z","path":"2017/03/22/react-vue/","text":"React.js和Vue.js对比相同点 数据驱动视图，提供响应式的视图组件 都有Virtual DOM，组件化开发，通过props参数进行父子组件数据的传递，都实现webComponents规范 数据流动单向都支持服务端渲染 都有支持native的方案，React的React native，Vue的weex 不同点 社区：React社区还是要比vue大很多； 开发模式：React在view层侵入性还是要比Vue大很多的,React严格上只针对MVC的view层，Vue则是MVVM模式的一种实现； 数据绑定：Vue有实现了双向数据绑定，React数据流动是单向的 数据渲染：对于大规模数据渲染，React要比Vue更快，渲染机制启动时候要做的工作比较多； 数据更新方面：Vue 由于采用依赖追踪，默认就是优化状态：你动了多少数据，就触发多少更新，不多也不少。React在复杂的应用里有两个选择: (1). 手动添加 shouldComponentUpdate 来避免不需要的 vdom re-render。(2).Components 尽可能都用 pureRenderMixin，然后采用 redux 结构 + Immutable.js； 开发风格的偏好：React 推荐的做法是 JSX + inline style，也就是把 HTML 和 CSS 全都写进 JavaScript 了，即”all in js”；Vue进阶之后推荐的是使用 webpack + vue-loader 的单文件组件格式，即html,css,js写在同一个文件； 使用场景：React配合Redux架构适合超大规模多人协作的复杂项目;Vue则适合小快灵的项目。对于需要对 DOM 进行很多自定义操作的项目，Vue 的灵活性优于 React； Vue要比React更好上手，具体可能体现在很多人不熟悉React的JSX语法和函数式编程的思想，以及想要发挥出React的最大威力需要学习它一系列生态的缘故； Vue着重提高开发效率,让前端程序员更快速方便的开发应用。React着重于变革开发思想，提升前端程序员编程的深度与创造力,让前端工程师成为真正的程序员而不是UI的构建者 关于GitHub: 👉https://github.com/microzz","tags":[{"name":"Vue.js","slug":"Vue-js","permalink":"https://microzz.com/tags/Vue-js/"},{"name":"ReactJS","slug":"ReactJS","permalink":"https://microzz.com/tags/ReactJS/"}]},{"title":"Vue.js2.0学习笔记","date":"2017-03-20T14:30:39.000Z","path":"2017/03/20/vue-note/","text":"Vue.js2.0学习笔记父子组件如何通信1.父子组件如何通信？ 事件 父组件监听一个事件，子组件触发该事件，并且可以传递自身数据。比如 // 父组件引入子组件 &lt;child v-on:tellFather=&quot;fatherFunc&quot;&gt;&lt;/child&gt; // 父组件 data 里面有 info data() { return { info: &#39;&#39; } // 父组件 methods 有 fatherFunc 方法 methods: { fatherFunc(msg) { this.info = msg } } // 子组件 通过 childFunc 触发父组件监听的事件 &lt;button v-on:click=&quot;childFunc&quot;&gt;Button&lt;/button&gt; // 子组件 data 里面有 msg 信息要传给父组件 data() { return { msg: &#39;This is the message from child&#39; } }, // 子组件的 childFunc 方法 methods: { childFunc() { // 关键！！！ // 子组件触发父组件的 tellFather 事件， // 并可以传递自身 data 里面的数据给父组件 this.$emit(&#39;tellFather&#39;, this.msg) } } 使用Vuex 使用 Vuex 让不同组件间共享状态(state) this.$parent.message2.子组件中使用this.$parent.message可以获取父亲data里面的message this.$refs3.this.$refs.img可以获取ref属性为img的DOM元素 $event4.有时也需要在内联语句处理器中访问原生 DOM 事件。可以用特殊变量 $event 把它传入方法： &lt;button v-on:click=&quot;warn(&#39;Form cannot be submitted yet.&#39;, $event)&quot;&gt;Submit&lt;/button&gt; // ... methods: { warn: function (message, event) { // 现在我们可以访问原生事件对象 if (event) event.preventDefault() alert(message) } } 修饰符5.在事件处理程序中调用 event.preventDefault() 或 event.stopPropagation() 是非常常见的需求。尽管我们可以在 methods 中轻松实现这点，但更好的方式是：methods 只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。为了解决这个问题， Vue.js 为v-on 提供了 事件修饰符。通过由点(.)表示的指令后缀来调用修饰符。.stop.prevent.capture.self.once &lt;!-- 阻止单击事件冒泡 --&gt; &lt;a v-on:click.stop=&quot;doThis&quot;&gt;&lt;/a&gt; &lt;!-- 提交事件不再重载页面 --&gt; &lt;form v-on:submit.prevent=&quot;onSubmit&quot;&gt;&lt;/form&gt; &lt;!-- 修饰符可以串联 --&gt; &lt;a v-on:click.stop.prevent=&quot;doThat&quot;&gt;&lt;/a&gt; &lt;!-- 只有修饰符 --&gt; &lt;form v-on:submit.prevent&gt;&lt;/form&gt; &lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt; &lt;div v-on:click.capture=&quot;doThis&quot;&gt;...&lt;/div&gt; &lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt; &lt;div v-on:click.self=&quot;doThat&quot;&gt;...&lt;/div&gt; name6.一开始好多人会忽视 name 的属性，为什么要给组件写上 name 呢？ 允许组件模板递归地调用自身。注意，组件在全局用 Vue.component() 注册时，全局 ID 自动作为组件的 name。 指定 name 选项的另一个好处是便于调试。有名字的组件有更友好的警告信息。另外，当在有 vue-devtools, 未命名组件将显示成 &lt;AnonymousComponent&gt;, 这很没有语义。通过提供 name 选项，可以获得更有语义信息的组件树。 Vuex action7.Vuex中 Mutations 必须是同步的，Action 提交的是 mutation，而不是直接变更状态。Action 可以包含任意异步操作。 未完待续…","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://microzz.com/tags/Vue-js/"},{"name":"Vuex","slug":"Vuex","permalink":"https://microzz.com/tags/Vuex/"}]},{"title":"SASS用法指南","date":"2017-03-18T15:17:32.000Z","path":"2017/03/18/sass/","text":"&nbsp;&nbsp;&nbsp;&nbsp;学过CSS的人都知道，它不是一种编程语言。&nbsp;&nbsp;&nbsp;&nbsp;你可以用它开发网页样式，但是没法用它编程。也就是说，CSS基本上是设计师的工具，不是程序员的工具。在程序员眼里，CSS是一件很麻烦的东西。它没有变量，也没有条件语句，只是一行行单纯的描述，写起来相当费事。 &nbsp;&nbsp;&nbsp;&nbsp;很自然地，有人就开始为CSS加入编程元素，这被叫做”CSS预处理器”（css preprocessor）。它的基本思想是，用一种专门的编程语言，进行网页样式设计，然后再编译成正常的CSS文件。&nbsp;&nbsp;&nbsp;&nbsp;各种”CSS预处理器”之中，我自己最喜欢SASS，觉得它有很多优点，打算以后都用它来写CSS。下面是我整理的用法总结，供自己开发时参考，相信对其他人也有用。 SASS用法指南作者：阮一峰 一、什么是SASSSASS是一种CSS的开发工具，提供了许多便利的写法，大大节省了设计者的时间，使得CSS的开发，变得简单和可维护。本文总结了SASS的主要用法。我的目标是，有了这篇文章，日常的一般使用就不需要去看官方文档了。 二、安装和使用2.1 安装SASS是Ruby语言写的，但是两者的语法没有关系。不懂Ruby，照样使用。只是必须先安装Ruby，然后再安装SASS。假定你已经安装好了Ruby，接着在命令行输入下面的命令： gem install sass然后，就可以使用了。 2.2 使用SASS文件就是普通的文本文件，里面可以直接使用CSS语法。文件后缀名是.scss，意思为Sassy CSS。下面的命令，可以在屏幕上显示.scss文件转化的css代码。（假设文件名为test。） sass test.scss如果要将显示结果保存成文件，后面再跟一个.css文件名。 sass test.scss test.cssSASS提供四个编译风格的选项： nested：嵌套缩进的css代码，它是默认值。 expanded：没有缩进的、扩展的css代码。 compact：简洁格式的css代码。 compressed：压缩后的css代码。生产环境当中，一般使用最后一个选项。 sass --style compressed test.sass test.css你也可以让SASS监听某个文件或目录，一旦源文件有变动，就自动生成编译后的版本。 // watch a file sass --watch input.scss:output.css // watch a directory sass --watch app/sass:public/stylesheets SASS的官方网站，提供了一个在线转换器。你可以在那里，试运行下面的各种例子。 三、基本用法3.1 变量SASS允许使用变量，所有变量以$开头。 $blue : #1875e7; div { color : $blue; } 如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中。 $side : left; .rounded { border-#{$side}-radius: 5px; } 3.2 计算功能SASS允许在代码中使用算式： body { margin: (14px/2); top: 50px + 100px; right: $var * 10%; } 3.3 嵌套SASS允许选择器嵌套。比如，下面的CSS代码： div h1 { color : red; } 可以写成： div { hi { color:red; } } 属性也可以嵌套，比如border-color属性，可以写成： p { border: { color: red; } } 注意，border后面必须加上冒号。在嵌套的代码块内，可以使用&amp;引用父元素。比如a:hover伪类，可以写成： a { &amp;:hover { color: #ffb3ff; } } 3.4 注释SASS共有两种注释风格。标准的CSS注释 /* comment */，会保留到编译后的文件。单行注释 // comment，只保留在SASS源文件中，编译后被省略。在/*后面加一个感叹号，表示这是”重要注释”。即使是压缩模式编译，也会保留这行注释，通常可以用于声明版权信息。 /*! 重要注释！ */ 四、代码的重用4.1 继承SASS允许一个选择器，继承另一个选择器。比如，现有class1： .class1 { border: 1px solid #ddd; } class2要继承class1，就要使用@extend命令： .class2 { @extend .class1; font-size:120%; } 4.2 MixinMixin有点像C语言的宏（macro），是可以重用的代码块。使用@mixin命令，定义一个代码块。 @mixin left { float: left; margin-left: 10px; } 使用@include命令，调用这个mixin。 div { @include left; } mixin的强大之处，在于可以指定参数和缺省值。 @mixin left($value: 10px) { float: left; margin-right: $value; } 使用的时候，根据需要加入参数： div { @include left(20px); } 下面是一个mixin的实例，用来生成浏览器前缀。 @mixin rounded($vert, $horz, $radius: 10px) { border-#{$vert}-#{$horz}-radius: $radius; -moz-border-radius-#{$vert}#{$horz}: $radius; -webkit-border-#{$vert}-#{$horz}-radius: $radius; } 使用的时候，可以像下面这样调用： #navbar li { @include rounded(top, left); } #footer { @include rounded(top, left, 5px); } 4.3 颜色函数SASS提供了一些内置的颜色函数，以便生成系列颜色。 lighten(#cc3, 10%) // #d6d65c darken(#cc3, 10%) // #a3a329 grayscale(#cc3) // #808080 complement(#cc3) // #33c 4.4 插入文件@import命令，用来插入外部文件。 @import &quot;path/filename.scss&quot;;如果插入的是.css文件，则等同于css的import命令。 @import &quot;foo.css&quot;; 五、高级用法5.1 条件语句@if可以用来判断： p { @if 1 + 1 == 2 { border: 1px solid; } @if 5 &lt; 3 { border: 2px dotted; } } 配套的还有@else命令： @if lightness($color) &gt; 30% { background-color: #000; } @else { background-color: #fff; } 5.2 循环语句SASS支持for循环： @for $i from 1 to 10 { .border-#{$i} { border: #{$i}px solid blue; } } 也支持while循环： $i: 6; @while $i &gt; 0 { .item-#{$i} { width: 2em * $i; } $i: $i - 2; } each命令，作用与for类似： @each $member in a, b, c, d { .#{$member} { background-image: url(&quot;/image/#{$member}.jpg&quot;); } } 5.3 自定义函数SASS允许用户编写自己的函数。 @function double($n) { @return $n * 2; } #sidebar { width: double(5px); } 须知感谢阮一峰老师的总结，原文地址","tags":[{"name":"SASS","slug":"SASS","permalink":"https://microzz.com/tags/SASS/"},{"name":"SCSS","slug":"SCSS","permalink":"https://microzz.com/tags/SCSS/"},{"name":"CSS","slug":"CSS","permalink":"https://microzz.com/tags/CSS/"}]},{"title":"Vue.js写一个音乐播放器","date":"2017-03-15T13:44:02.000Z","path":"2017/03/15/vue-music/","text":"Vue.js写一个音乐播放器Vue音乐播放器2.0升级版已经发布，请看👉 Vue.js音乐播放器升级版 在线预览2.0版本预览地址：🔗https://microzz.com/vue-music/在线预览地址1: 🔗http://microzz.cn/vue-music/在线预览地址2: 🔗https://microzz.github.io/vue-music-player/ 源代码GitHub地址: 🔗https://github.com/microzz/vue-music-player欢迎大家follow和star哦😄 介绍学习Vue.js后，决定做个小项目锻炼一下，于是选择了典型的音乐播放器上手。其中遇到了很多坑，也学到了很多。代码可能还有瑕疵，欢迎大家到我的GitHub反馈，相互交流学习。同时也欢迎大家follow和star😄预览图： 红色皮肤-microzz.com 绿色皮肤-microzz.com 蓝色皮肤-microzz.com 黑色皮肤-microzz.com 技术栈Vue.jsVue的双向数据绑定真的很爽，让开发者更多的关注业务逻辑，而不是耗性能的DOM操作。借鉴了React.js和Angular.js等著名框架，Vue写起来也的确很方便，很多地方也想的很周到。因为实际场景，并没有使用到路由、vuex等东西。其中也遇到了几个值得注意的地方： 用好watch会事半功倍 有些操作要在实例加载完，所以钩子函数mounted需要注意 很多小技巧要试过才知道走了弯路😂 ES6本示例采用的是ES6的语法，因为webpack编译，所以也不必太过当心兼容性问题。ES6也即ECMAScript 2015，发布也有一段时间了，很多地方很方便，这是大势所趋，以后会慢慢地向ES6迁移。掌握是很必要的！ HTML5localStorage本demo用localStorage本地存储保存用户设置（如：皮肤）和用户歌单列表 CSS3很多动画都是依靠CSS3完成的，方便性能也不错，缺点是兼容性问题。 更新记录2017.03.13A music player by Vue.js。一个由Vue.js写的音乐播放器，今天完成了播放器的大体功能，数据是通过JSON模拟 后续完善 搭建后台调用网上音乐API 完善功能 2017.03.14列表部分功能完善，部分代码优化，部分异步代码Promise化 后续完善 冗余代码整合优化 部分代码封装 2017.03.151.0.0正式版发布 2017.03.192.0.0版本筹划… 2017.04.032.0.0版本开始 2017.04.082.0.0版本完成 Vue音乐播放器2.0升级版已经发布，请看👉 Vue.js音乐播放器升级版 About个人网站：🔗https://microzz.com/GitHub：🔗https://github.com/microzz","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"https://microzz.com/tags/HTML5/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://microzz.com/tags/Vue-js/"}]},{"title":"三级联动的生成器插件","date":"2017-03-12T09:03:01.000Z","path":"2017/03/12/select-plugin/","text":"三级联动的生成器插件介绍一个三级联动的生成器插件，默认生成中国地区🇨🇳的三级联动数据，也可以自定义数据。npm地址：https://www.npmjs.com/package/select-plugin 安装输入 npm install select-plugin . 最好先初始化一下package.json文件，输入 npm init -y，然后再执行安装npm install select-plugin 使用默认数据 引入js文件。 在html文件中插入&lt;script src=&quot;./node_modules/select-plugin/dist/select-plugin-all.js&quot;&gt;&lt;/script&gt;， 然后 &lt;script&gt;new Select()&lt;/script&gt; 默认就可以生成中国地区的三级联动数据啦😄 自定义数据如果你只使用自定义的数据，建议只引入不包含地区数据的js文件，即&lt;script src=&quot;./node_modules/select-plugin/dist/select-plugin.js&quot;&gt;&lt;/script&gt;，这样文件大小可以减少很多，毕竟大中国地区数据太庞大了😇但是务必传递传递相关参数！new Select(&#39;.container&#39;, data, id, text); 参数依次是插入父容器位置（默认是body，参数是CSS3选择器的形式，如’#id’ , ‘ .className’），数据，在DOM元素的id，显示的文本 示例&lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;ie=edge&quot;&gt; &lt;title&gt;三级联动生成器插件&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;div class=&quot;container&quot;&gt;&lt;/div&gt; &lt;script src=&quot;./node_modules/select-plugin/dist/select-plugin-all.js&quot;&gt;&lt;/script&gt; &lt;script&gt; // 不传任何参数,默认生成中国地区三级联动 new Select(); // 自定义数据 var data = { One: [&#39;a1&#39;, &#39;a2&#39;, &#39;a3&#39;], Two: [ [&#39;a11&#39;, &#39;a12&#39;, &#39;a13&#39;], [&#39;a21&#39;, &#39;a22&#39;], [&#39;a31&#39;, &#39;a32&#39;] ], Three: [ [[&#39;a111&#39;, &#39;a112&#39;], [&#39;a121&#39;, &#39;a122&#39;], [&#39;a131&#39;, &#39;a132&#39;]], [[&#39;a211&#39;, &#39;a212&#39;], [&#39;a221&#39;, &#39;a222&#39;]], [[&#39;a311&#39;], [&#39;a312&#39;]] ] }; var id = [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;]; var text = [&#39;选项1&#39;, &#39;选项2&#39;, &#39;选项3&#39;]; // 参数依次是插入父容器位置，数据，DOM的id，显示的文本 new Select(&#39;.container&#39;, data, id, text); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; 效果预览 select-plugin-microzz.com 在线预览在线预览地址1在线预览地址2 AboutGitHub： https://github.com/microzz 个人网站：https://microzz.com/","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"npm","slug":"npm","permalink":"https://microzz.com/tags/npm/"}]},{"title":"Vue.js初体验-TodoList","date":"2017-03-09T14:51:14.000Z","path":"2017/03/09/vue-begin/","text":"Vue.js初体验 &nbsp;&nbsp;&nbsp;之前学了React.js，今天简单上手了Vue.js，感受到了Vue.js的一些独特魅力。双向的数据绑定让人开发起来很“爽”，于是动手简单写了一个Todo List小demo，Vue上手的确比较简单，方便不少。期待后续的学习😄 TodoList小demo在线预览在线预览地址1: 🔗http://microzz.cn/todo-vue/在线预览地址2: 🔗https://microzz.github.io/todo-list-vuejs/ 源代码源代码地址：🔗https://github.com/microzz/todo-list-vuejs Vue.js简介Vue.js是一套构建用户界面的渐进式框架。与其他重量级框架不同的是，Vue 采用自底向上增量开发的设计。Vue 的核心库只关注视图层，并且非常容易学习，非常容易与其它库或已有项目整合。另一方面，Vue 完全有能力驱动采用单文件组件和 Vue 生态系统支持的库开发的复杂单页应用。Vue.js 的目标是通过尽可能简单的 API 实现响应的数据绑定和组合的视图组件。 特点 易用已经会了HTML,CSS,JavaScript？即刻阅读指南开始构建应用！ 灵活简单小巧的核心，渐进式技术栈，足以应付任何规模的应用。 性能17kb min+gzip 运行大小超快虚拟 DOM最省心的优化","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Vue.js","slug":"Vue-js","permalink":"https://microzz.com/tags/Vue-js/"}]},{"title":"JavaScript实现继承的几种方法","date":"2017-03-06T13:44:25.000Z","path":"2017/03/06/extend/","text":"JavaScript中实现继承的几种方法ES5中的实现概述JavaScript(ES5)中没有像Java那样类的概念，写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。但是我们可以通过原型链prototype来模拟类，去实现继承的相关功能。下面来看看ES5中实现继承常见的三种方法。代码如下： 代码/** * JavaScript(ES5)中实现继承的几种方法 */ // 定义基类Person function Person(name, age) { this.name = name; this.age = age; } // 共享数据 Person.prototype.LEGS_NUM = 2; // 共享方法 Person.prototype.info = function () { console.log(&#39;My name is &#39; + this.name + &#39; .I\\&#39;m &#39; + this.age + &#39; years old now&#39;); }; Person.prototype.walk = function () { console.log(this.name + &#39; is walking...&#39;); }; // Student子类 function Student(name, age, className) { // 调用父类 Person.call(this, name, age); this.className = className; } // 1⃣️ 方法一：Person.prototype直接赋值给Student.prototype // Student.prototype = Person.prototype; // 2⃣️ 方法二：Student.prototype为Person的实例 // Student.prototype = new Person(); // 3⃣️ 方法三：创建一个空对象，对象的原型指向Person.prototype，赋值给Student.prototype Student.prototype = Object.create(Person.prototype); Student.prototype.constructor = Student; // 覆盖父类的info方法 Student.prototype.info = function () { console.log(&#39;My name is &#39; + this.name + &#39;,I\\&#39;m &#39; + this.age + &#39; years old now, and from class &#39; + this.className + &#39;.&#39;); }; // Student类的共享方法 Student.prototype.learn = function (subject) { console.log(this.name + &#39; is learning &#39; + subject + &#39;.&#39;); }; // 测试,创建一个Student的实例 var microzz = new Student(&#39;Microzz&#39;, 22, 5); microzz.info(); // My name is Microzz,I&#39;m 22 years old now, and from class 5. console.log(microzz.LEGS_NUM); // 2 microzz.walk(); // Microzz is walking... microzz.learn(&#39;JavaScript&#39;); // Microzz is learning JavaScript. console.log(microzz.__proto__.__proto__ === Person.prototype); // true console.log(microzz.__proto__ === Student.prototype); // true console.log(microzz.__proto__.constructor === Student); // true 三种方法比较上面代码中有三种方法实现继承，现在我们可以来分析一下这几种方法。1⃣️这种方法中，Person.prototype直接赋值给Student.prototype，但是有一个很严重的问题，如果子类prototype添加新的东西的话也会改写父类。所以这种方法不推荐。2⃣️第二种方法Student.prototype为Person的实例，这也是可以实现的。但是Person构造函数有参数应该传什么呢？传任何一个都是很奇怪的。所以也不推荐。3⃣️第三种方法是比较理想的，创建一个空对象，对象的原型指向Person.prototype，赋值给Student.prototype。但是Object.create也有一点小瑕疵，因为它是ES5之后才支持的，不过我们可以通过模拟实现Object.create方法。代码如下： if (!Object.create) { Object.prototype.create = function (proto) { function F() {} F.prototype = proto; return new F; } } 这样在ES5中就完美实现了继承😄 ES6中的实现概述ES6提供了更接近传统语言”类”的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。下面我们用ES6的语法实现类的继承。 代码// 基类 Person class Person { // 父类的构造方法 constructor(name, age) { this.name = name; this.age = age; // 共享变量 this.LEGS_NUM = 2; } // 父类的info方法 info() { console.log(`My name is ${this.name}, I\\&#39;m ${this.age} years old now.`); } // 父类的walk方法 walk() { console.log(this.name + &#39; is walking...&#39;); } } // 子类 Student class Student extends Person { constructor(name, age, className) { // 调用基类的构造方法 super(name, age); this.className = className; } // 覆盖父类的info方法 info() { console.log(`My name is ${this.name}, I\\&#39;m ${this.age} years old, and from class ${this.className}.`); } } // 实例化一个Student的实例 let stu = new Student(&#39;Zhaohui&#39;, 22, 5); stu.info(); // My name is Zhaohui, I&#39;m 22 years old, and from class 5. stu.walk(); // Zhaohui is walking... console.log(stu.LEGS_NUM); // 2 console.log(stu instanceof Student); // true console.log(stu instanceof Person); // true 这样我们就通过ES6中的class实现了“类”的继承了😄","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"原型链","slug":"原型链","permalink":"https://microzz.com/tags/原型链/"}]},{"title":"JS中的高阶函数和偏函数","date":"2017-03-05T11:49:42.000Z","path":"2017/03/05/func/","text":"JS中的高阶函数和偏函数高阶函数什么是高阶函数高阶函数是异步编程的基础，那么什么是高阶函数呢? 高阶二字听起来有点高大上的感觉，其实不然，高阶函数与普通函数不同的地方是高阶函数可以把函数作为参数，或者是将函数作为返回值，请看如下示例。 示例：function test(v){ return function(){ return v; } } 示例中是一个最简单的高阶函数，如你所见，高阶函数test的返回值是一个匿名函数。 现实中的应用虽然有可能是第一次真正的去了解什么是高阶函数，但是其实我们在日常开发中经常会用到它，只是我们没有去留意或者说不知道它的称谓而已。 示例：数组的排序(sort)函数 var arr = [23,54,3,12,78]; arr.sort(function(a,b){ return a-b; }); 偏函数什么是偏函数假设有一个参数或变量已经预置的函数A，我们通过调用A来产生一个新的函数B，函数B就是我们说的偏函数。下面可以看一个示例。 示例// 判断类型的小demo var isType = function(type){ return function(obj){ return toString.call(obj)==&#39;[object &#39;+type+&#39;]&#39;; } }; // 定制新的函数 var isString = isType(&#39;String&#39;); var isArray = isType(&#39;Array&#39;); var isFunction = isType(&#39;Function&#39;); // 测试偏函数 console.log(isString(&#39;abc&#39;)); // true console.log(isArray([1, 2])); // true console.log(isFunction(&#39;abc&#39;)); // false isType函数中预置了判断类型的方法，只指定部分参数来产生的新的定制的函数isString、isArray和isFunction就是偏函数。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"函数","slug":"函数","permalink":"https://microzz.com/tags/函数/"}]},{"title":"基于HTML5的Web阅读器","date":"2017-03-04T12:11:26.000Z","path":"2017/03/04/WebReader/","text":"基于HTML5的Web阅读器介绍这是基于HTML5开发的简单的轻量级 WebApp在线阅读器，可以进行简单的个性化设置，适配了手机和电脑。运行需要一个Web服务器的支持。欢迎大家在我的GitHub上Star，也可以提出宝贵意见哦😄 在线预览 基于HTML5的Web阅读器 在线预览地址1：🔗http://microzz.cn/web-reader/在线预览地址2:🔗https://microzz.github.io/WebReader/ 源码源码地址：https://github.com/microzz/WebReader","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"HTML5","slug":"HTML5","permalink":"https://microzz.com/tags/HTML5/"},{"name":"WebApp","slug":"WebApp","permalink":"https://microzz.com/tags/WebApp/"}]},{"title":"响应式网页设计","date":"2017-03-02T14:55:31.000Z","path":"2017/03/02/responsive/","text":"响应式网页设计什么是响应式网站响应式布局是Ethan Marcotte在2010年5月份提出的一个概念，简而言之，就是一个网站能够兼容多个终端——而不是为每个终端做一个特定的版本。这个概念是为解决移动互联网浏览而诞生的。 优点和缺点优点优点：面对不同分辨率设备灵活性强能够快捷解决多设备显示适应问题 缺点兼容各种设备工作量大，效率低下代码累赘，会出现隐藏无用的元素，加载时间加长其实这是一种折中性质的设计解决方案，多方面因素影响而达不到最佳效果一定程度上改变了网站原有的布局结构，会出现用户混淆的情况 响应式网页设计实战用HTML5以及CSS3的媒体查询完成了一个响应式布局的demo，大家可以用不同的尺寸的设备，查看不同分辨率下的表现。也可以在控制台模拟各种设备，欢迎大家提出意见。😄 在线预览在线预览地址1: 🔗http://microzz.cn/responsive/在线预览地址2: 🔗https://microzz.github.io/ResponsiveWeb/ 源码源码地址：🔗https://github.com/microzz/ResponsiveWeb","tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://microzz.com/tags/HTML5/"},{"name":"CSS3","slug":"CSS3","permalink":"https://microzz.com/tags/CSS3/"},{"name":"Responsive","slug":"Responsive","permalink":"https://microzz.com/tags/Responsive/"},{"name":"响应式设计","slug":"响应式设计","permalink":"https://microzz.com/tags/响应式设计/"}]},{"title":"JS实现文字信息无缝滚动效果","date":"2017-03-01T07:42:04.000Z","path":"2017/03/01/flow-info/","text":"JS实现文字信息无缝滚动效果预览 JS实现文字信息无缝滚动效果 在线预览1在线预览地址1: 🔗http://microzz.cn/flow-info/ 在线预览2在线预览地址2: 🔗https://microzz.github.io/flow-info-by-js/ 源代码源代码地址：🔗https://github.com/microzz/flow-info-by-js","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"}]},{"title":"前端工作面试问题","date":"2017-02-26T12:02:20.000Z","path":"2017/02/26/interview2/","text":"前端工作面试问题本文包含了一些用于考查候选者的前端面试问题。不建议对单个候选者问及每个问题 (那需要好几个小时)。只要从列表里挑选一些，就能帮助你考查候选者是否具备所需要的技能。 备注： 这些问题中很多都是开放性的，可以引发有趣的讨论。这比直接的答案更能体现此人的能力。 常见问题： 你在昨天/本周学到了什么？ 编写代码的哪些方面能够使你兴奋或感兴趣？ 你最近遇到过什么技术挑战？你是如何解决的？ 在制作一个网页应用或网站的过程中，你是如何考虑其 UI、安全性、高性能、SEO、可维护性以及技术因素的？ 请谈谈你喜欢的开发环境。 你最熟悉哪一套版本控制系统？ 你能描述当你制作一个网页的工作流程吗？ 假若你有 5 个不同的样式文件 (stylesheets), 整合进网站的最好方式是? 你能描述渐进增强 (progressive enhancement) 和优雅降级 (graceful degradation) 之间的不同吗? 你如何对网站的文件和资源进行优化？ 浏览器同一时间可以从一个域名下载多少资源？ 有什么例外吗？ 请说出三种减少页面加载时间的方法。(加载时间指感知的时间或者实际加载时间) 如果你参与到一个项目中，发现他们使用 Tab 来缩进代码，但是你喜欢空格，你会怎么做？ 请写一个简单的幻灯效果页面。 如果今年你打算熟练掌握一项新技术，那会是什么？ 请谈谈你对网页标准和标准制定机构重要性的理解。 什么是 FOUC (无样式内容闪烁)？你如何来避免 FOUC？ 请解释什么是 ARIA 和屏幕阅读器 (screenreaders)，以及如何使网站实现无障碍访问 (accessible)。 请解释 CSS 动画和 JavaScript 动画的优缺点。 什么是跨域资源共享 (CORS)？它用于解决什么问题？ HTML 相关问题： doctype(文档类型) 的作用是什么？ 浏览器标准模式 (standards mode) 、几乎标准模式（almost standards mode）和怪异模式 (quirks mode) 之间的区别是什么？ HTML 和 XHTML 有什么区别？ 如果页面使用 ‘application/xhtml+xml’ 会有什么问题吗？ 如果网页内容需要支持多语言，你会怎么做？ 在设计和开发多语言网站时，有哪些问题你必须要考虑？ 使用 data- 属性的好处是什么？ 如果把 HTML5 看作做一个开放平台，那它的构建模块有哪些？ 请描述 cookies、sessionStorage 和 localStorage 的区别。 请解释 &lt;script&gt;、&lt;script async&gt; 和 &lt;script defer&gt; 的区别。 为什么通常推荐将 CSS &lt;link&gt; 放置在 &lt;head&gt;&lt;/head&gt; 之间，而将 JS &lt;script&gt; 放置在 &lt;/body&gt; 之前？你知道有哪些例外吗？ 什么是渐进式渲染 (progressive rendering)？ 你用过哪些不同的 HTML 模板语言？ CSS 相关问题： CSS 中类 (classes) 和 ID 的区别。 请问 “resetting” 和 “normalizing” CSS 之间的区别？你会如何选择，为什么？ 请解释浮动 (Floats) 及其工作原理。 描述z-index和叠加上下文是如何形成的。 请描述 BFC(Block Formatting Context) 及其如何工作。 列举不同的清除浮动的技巧，并指出它们各自适用的使用场景。 请解释 CSS sprites，以及你要如何在页面或网站中实现它。 你最喜欢的图片替换方法是什么，你如何选择使用。 你会如何解决特定浏览器的样式问题？ 如何为有功能限制的浏览器提供网页？ 你会使用哪些技术和处理方法？ 有哪些的隐藏内容的方法 (如果同时还要保证屏幕阅读器可用呢)？ 你用过栅格系统 (grid system) 吗？如果使用过，你最喜欢哪种？ 你用过媒体查询，或针对移动端的布局/CSS 吗？ 你熟悉 SVG 样式的书写吗？ 如何优化网页的打印样式？ 在书写高效 CSS 时会有哪些问题需要考虑？ 使用 CSS 预处理器的优缺点有哪些？ 请描述你曾经使用过的 CSS 预处理器的优缺点。 如果设计中使用了非标准的字体，你该如何去实现？ 请解释浏览器是如何判断元素是否匹配某个 CSS 选择器？ 请描述伪元素 (pseudo-elements) 及其用途。 请解释你对盒模型的理解，以及如何在 CSS 中告诉浏览器使用不同的盒模型来渲染你的布局。 请解释 * { box-sizing: border-box; } 的作用, 并且说明使用它有什么好处？ 请罗列出你所知道的 display 属性的全部值 请解释 inline 和 inline-block 的区别？ 请解释 relative、fixed、absolute 和 static 元素的区别 CSS 中字母 ‘C’ 的意思是叠层 (Cascading)。请问在确定样式的过程中优先级是如何决定的 (请举例)？如何有效使用此系统？ 你在开发或生产环境中使用过哪些 CSS 框架？你觉得应该如何改善他们？ 请问你有尝试过 CSS Flexbox 或者 Grid 标准规格吗？ 为什么响应式设计 (responsive design) 和自适应设计 (adaptive design) 不同？ 你有兼容 retina 屏幕的经历吗？如果有，在什么地方使用了何种技术？ 请问为何要使用 translate() 而非 absolute positioning，或反之的理由？为什么？ JS 相关问题： 请解释事件代理 (event delegation)。 请解释 JavaScript 中 this 是如何工作的。 请解释原型继承 (prototypal inheritance) 的原理。 你怎么看 AMD vs. CommonJS？ 请解释为什么接下来这段代码不是 IIFE (立即调用的函数表达式)：function foo(){ }();. 要做哪些改动使它变成 IIFE? 描述以下变量的区别：null，undefined 或 undeclared？ 该如何检测它们？ 什么是闭包 (closure)，如何使用它，为什么要使用它？ 请举出一个匿名函数的典型用例？ 你是如何组织自己的代码？是使用模块模式，还是使用经典继承的方法？ 请指出 JavaScript 宿主对象 (host objects) 和原生对象 (native objects) 的区别？ 请指出以下代码的区别：function Person(){}、var person = Person()、var person = new Person()？ .call 和 .apply 的区别是什么？ 请解释 Function.prototype.bind？ 在什么时候你会使用 document.write()？ 请指出浏览器特性检测，特性推断和浏览器 UA 字符串嗅探的区别？ 请尽可能详尽的解释 Ajax 的工作原理。 使用 Ajax 都有哪些优劣？ 请解释 JSONP 的工作原理，以及它为什么不是真正的 Ajax。 你使用过 JavaScript 模板系统吗？ 如有使用过，请谈谈你都使用过哪些库？ 请解释变量声明提升 (hoisting)。 请描述事件冒泡机制 (event bubbling)。 “attribute” 和 “property” 的区别是什么？ 为什么扩展 JavaScript 内置对象不是好的做法？ 请指出 document load 和 document DOMContentLoaded 两个事件的区别。 == 和 === 有什么不同？ 请解释 JavaScript 的同源策略 (same-origin policy)。 如何实现下列代码：[1,2,3,4,5].duplicator(); // [1,2,3,4,5,1,2,3,4,5] 什么是三元表达式 (Ternary expression)？“三元 (Ternary)” 表示什么意思？ 什么是 &quot;use strict&quot;; ? 使用它的好处和坏处分别是什么？ 请实现一个遍历至 100 的 for loop 循环，在能被 3 整除时输出 “fizz”，在能被 5 整除时输出 “buzz”，在能同时被 3 和 5 整除时输出 “fizzbuzz”。 为何通常会认为保留网站现有的全局作用域 (global scope) 不去改变它，是较好的选择？ 为何你会使用 load 之类的事件 (event)？此事件有缺点吗？你是否知道其他替代品，以及为何使用它们？ 请解释什么是单页应用 (single page app), 以及如何使其对搜索引擎友好 (SEO-friendly)。 What is the extent of your experience with Promises and/or their polyfills? 使用 Promises 而非回调 (callbacks) 优缺点是什么？ 使用一种可以编译成 JavaScript 的语言来写 JavaScript 代码有哪些优缺点？ 你使用哪些工具和技术来调试 JavaScript 代码？ 你会使用怎样的语言结构来遍历对象属性 (object properties) 和数组内容？ 请解释可变 (mutable) 和不变 (immutable) 对象的区别。 请举出 JavaScript 中一个不变性对象 (immutable object) 的例子？ 不变性 (immutability) 有哪些优缺点？ 如何用你自己的代码来实现不变性 (immutability)？ 请解释同步 (synchronous) 和异步 (asynchronous) 函数的区别。 什么是事件循环 (event loop)？ 请问调用栈 (call stack) 和任务队列 (task queue) 的区别是什么？ 解释 function foo() {} 与 var foo = function() {} 用法的区别 测试相关问题： 对代码进行测试的有什么优缺点？ 你会用什么工具测试你的代码功能？ 单元测试与功能/集成测试的区别是什么？ 代码风格 linting 工具的作用是什么？ 效能相关问题： 你会用什么工具来查找代码中的性能问题？ 你会用什么方式来增强网站的页面滚动效能？ 请解释 layout、painting 和 compositing 的区别。 网络相关问题： 为什么传统上利用多个域名来提供网站资源会更有效？ 请尽可能完整得描述从输入 URL 到整个网页加载完毕及显示在屏幕上的整个流程。 Long-Polling、Websockets 和 Server-Sent Event 之间有什么区别？ 请描述以下 request 和 response headers： Diff. between Expires, Date, Age and If-Modified-… Do Not Track Cache-Control Transfer-Encoding ETag X-Frame-Options 什么是 HTTP method？请罗列出你所知道的所有 HTTP method，并给出解释。 代码相关的问题：问题：foo的值是什么？ var foo = 10 + &#39;20&#39;; 问题：如何实现以下函数？ add(2, 5); // 7 add(2)(5); // 7 问题：下面的语句的返回值是什么？ &quot;i&#39;m a lasagna hog&quot;.split(&quot;&quot;).reverse().join(&quot;&quot;); 问题：window.foo的值是什么？ ( window.foo || ( window.foo = &quot;bar&quot; ) ); 问题：下面两个 alert 的结果是什么？ var foo = &quot;Hello&quot;; (function() { var bar = &quot; World&quot;; alert(foo + bar); })(); alert(foo + bar); 问题：foo.length的值是什么？ var foo = []; foo.push(1); foo.push(2); 问题：foo.x的值是什么？ var foo = {n: 1}; var bar = foo; foo.x = foo = {n: 2}; 问题：下面代码的输出是什么？ console.log(&#39;one&#39;); setTimeout(function() { console.log(&#39;two&#39;); }, 0); console.log(&#39;three&#39;); 趣味问题： 你最近写过什么的很酷的项目吗？ 在你使用的开发工具中，最喜欢哪些方面？ 谁使你踏足了前端开发领域？ 你有什么业余项目吗？是哪种类型的？ 你最爱的 IE 特性是什么？ 你对咖啡有没有什么喜好？ 声明本文收集自网络，不用作任何商业用途，感谢贡献者。","tags":[{"name":"Web","slug":"Web","permalink":"https://microzz.com/tags/Web/"},{"name":"前端","slug":"前端","permalink":"https://microzz.com/tags/前端/"},{"name":"面试","slug":"面试","permalink":"https://microzz.com/tags/面试/"},{"name":"求职","slug":"求职","permalink":"https://microzz.com/tags/求职/"}]},{"title":"JS惰性函数实现Ajax封装","date":"2017-02-23T06:55:16.000Z","path":"2017/02/23/lazy-func/","text":"JS惰性函数实现Ajax封装JavaScript惰性函数 &nbsp;&nbsp;&nbsp;惰性函数，即只在第一次执行，第一次执行后再调用得到的结果都是一样的。这对于前端性能优化有一定的帮助，有助于开发健壮的项目。 Ajax &nbsp;&nbsp;&nbsp;AJAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），是指一种创建交互式网页应用的网页开发技术。AJAX = 异步 JavaScript和XML。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 惰性函数实现Ajax封装/** * 惰性函数 */ function createXHR() { var xhr = null; if ( typeof XMLHttpRequest !== &#39;undefined&#39;) { xhr = new XMLHttpRequest(); createXHR = function () { return new XMLHttpRequest(); }; } else { try { xhr = new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); createXHR = function () { return new ActiveXObject(&quot;Msxml2.XMLHTTP&quot;); }; } catch (e) { try { xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;); createXHR = function () { return ActiveXObject(&#39;Microsoft.XMLHTTP&#39;); }; } catch (e) { createXHR = function () { return null; } } } } return xhr; }","tags":[{"name":"性能优化","slug":"性能优化","permalink":"https://microzz.com/tags/性能优化/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"Function","slug":"Function","permalink":"https://microzz.com/tags/Function/"},{"name":"Ajax","slug":"Ajax","permalink":"https://microzz.com/tags/Ajax/"}]},{"title":"原生JS实现轮播图","date":"2017-02-22T02:05:02.000Z","path":"2017/02/22/carousel/","text":"原生JS实现轮播图效果图 原生JS实现定时自动切换轮播图 在线预览在线预览地址1 🔗http://microzz.cn/Carousel/ 在线预览地址2 🔗https://microzz.github.io/carousel/ 源代码源代码地址：🔗https://github.com/microzz/carousel","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"Carousel","slug":"Carousel","permalink":"https://microzz.com/tags/Carousel/"}]},{"title":"React.JS学习思维导图","date":"2017-02-21T13:41:34.000Z","path":"2017/02/21/react-mind-map/","text":"React.JS学习思维导图ReactJS简介React 是一个用于构建用户界面的 JAVASCRIPT 库。React主要用于构建UI，很多人认为 React 是 MVC 中的 V（视图）。React 起源于 Facebook 的内部项目，用来架设 Instagram 的网站，并于 2013 年 5 月开源。React 拥有较高的性能，代码逻辑非常简单，越来越多的人已开始关注和使用它。 思维导图在线预览地址 mind 源文件React.JS学习思维导图","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"ReactJS","slug":"ReactJS","permalink":"https://microzz.com/tags/ReactJS/"}]},{"title":"jQuery实现一个瀑布流布局","date":"2017-02-20T13:42:02.000Z","path":"2017/02/20/waterfalljq/","text":"jQuery实现一个瀑布流布局瀑布流布局概念瀑布流，又称瀑布流式布局。是比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。最早采用此布局的网站是Pinterest，逐渐在国内流行开来。国内大多数清新站基本为这类风格。 瀑布流布局特点 琳琅满目：整版以图片为主，大小不一的图片按照一定的规律排列。 唯美：图片的风格以唯美的图片为主。 操作简单：在浏览网站的时候只需要轻轻滑动一下鼠标滚轮，一切的美妙的图片精彩便可呈现在你面前。 效果预览 在线预览地址1： 🔗http://microzz.cn/waterfall-jq/ 在线预览地址2： 🔗https://microzz.github.io/waterfall-jq/ 代码实现源代码地址：🔗https://github.com/microzz/waterfall-jq 瀑布流布局优缺点布局优点 有效的降低了界面复杂度，节省了空间：我们不再需要臃肿复杂的页码导航链接或按钮了。 对触屏设备来说，交互方式更符合直觉：在移动应用的交互环境当中，通过向上滑动进行滚屏的操作已经成为最基本的用户习惯，而且所需要的操作精准程度远远低于点击链接或按钮。 更高的参与度：以上两点所带来的交互便捷性可以使用户将注意力更多的集中在内容而不是操作上，从而让他们更乐于沉浸在探索与浏览当中。布局缺点 有限的用例：无限滚动的方式只适用于某些特定类型产品当中一部分特定类型的内容。例如，在电商网站当中，用户时常需要在商品列表与详情页面之间切换，这种情况下，传统的、带有页码导航的方式可以帮助用户更稳妥和准确的回到某个特定的列表页面当中。 额外的复杂度：那些用来打造无限滚动的JS库虽然都自称很容易使用，但你总会需要在自己的产品中进行不同程度的定制化处理，以满足你们自己的需求;另外这些JS库在浏览器和设备兼容性等方面的表现也参差不齐，你必须做好充分的测试与调整工作。 再见了，页脚：如果使用了比较典型的无限滚动加载模式，这就意味着你可以和页脚说拜拜了。最好考虑一下页脚对于你的网站，特别是用户的重要性;如果其中确实有比较重要的内容或链接，那么最好换一种更传统和稳妥的方式。千万不要耍弄你的用户，当他们一次次的浏览到页面底部，看到页脚，却因为自动加载的内容突然出现而无论如何都无法点击页脚中的链接时，他们会变的越发愤怒。 SEO：集中在一页当中动态加载数据，与一页一页的输出相比，究竟那种方式更利于SEO，这是你必须考虑的问题。对于某些以类型网站来说，在这方面进行冒险是很不划算的。 关于页面数量的印象：其实站在用户的角度来看，这一点并非负面;不过，如果对于你的网站来说，通过更多的内容页面展示更多的相关信息(包括广告)是很重要的策略，那么单页无限滚动的方式对你并不适用。 相关链接 原生JavaScript实现瀑布流布局 CSS3实现一个瀑布流布局","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"waterfall","slug":"waterfall","permalink":"https://microzz.com/tags/waterfall/"},{"name":"瀑布流","slug":"瀑布流","permalink":"https://microzz.com/tags/瀑布流/"},{"name":"jQuery","slug":"jQuery","permalink":"https://microzz.com/tags/jQuery/"}]},{"title":"CSS3实现一个瀑布流布局","date":"2017-02-19T11:30:02.000Z","path":"2017/02/19/waterfallcss3/","text":"CSS3实现一个瀑布流布局瀑布流布局概念瀑布流，又称瀑布流式布局。是比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。最早采用此布局的网站是Pinterest，逐渐在国内流行开来。国内大多数清新站基本为这类风格。 瀑布流布局特点 琳琅满目：整版以图片为主，大小不一的图片按照一定的规律排列。 唯美：图片的风格以唯美的图片为主。 操作简单：在浏览网站的时候只需要轻轻滑动一下鼠标滚轮，一切的美妙的图片精彩便可呈现在你面前。 效果预览 在线预览地址1： 🔗http://microzz.cn/waterfall-css3/ 在线预览地址2： 🔗https://microzz.github.io/waterfall-css3/ 代码实现源代码地址：🔗https://github.com/microzz/waterfall-css3 瀑布流布局优缺点布局优点 有效的降低了界面复杂度，节省了空间：我们不再需要臃肿复杂的页码导航链接或按钮了。 对触屏设备来说，交互方式更符合直觉：在移动应用的交互环境当中，通过向上滑动进行滚屏的操作已经成为最基本的用户习惯，而且所需要的操作精准程度远远低于点击链接或按钮。 更高的参与度：以上两点所带来的交互便捷性可以使用户将注意力更多的集中在内容而不是操作上，从而让他们更乐于沉浸在探索与浏览当中。布局缺点 有限的用例：无限滚动的方式只适用于某些特定类型产品当中一部分特定类型的内容。例如，在电商网站当中，用户时常需要在商品列表与详情页面之间切换，这种情况下，传统的、带有页码导航的方式可以帮助用户更稳妥和准确的回到某个特定的列表页面当中。 额外的复杂度：那些用来打造无限滚动的JS库虽然都自称很容易使用，但你总会需要在自己的产品中进行不同程度的定制化处理，以满足你们自己的需求;另外这些JS库在浏览器和设备兼容性等方面的表现也参差不齐，你必须做好充分的测试与调整工作。 再见了，页脚：如果使用了比较典型的无限滚动加载模式，这就意味着你可以和页脚说拜拜了。最好考虑一下页脚对于你的网站，特别是用户的重要性;如果其中确实有比较重要的内容或链接，那么最好换一种更传统和稳妥的方式。千万不要耍弄你的用户，当他们一次次的浏览到页面底部，看到页脚，却因为自动加载的内容突然出现而无论如何都无法点击页脚中的链接时，他们会变的越发愤怒。 SEO：集中在一页当中动态加载数据，与一页一页的输出相比，究竟那种方式更利于SEO，这是你必须考虑的问题。对于某些以类型网站来说，在这方面进行冒险是很不划算的。 关于页面数量的印象：其实站在用户的角度来看，这一点并非负面;不过，如果对于你的网站来说，通过更多的内容页面展示更多的相关信息(包括广告)是很重要的策略，那么单页无限滚动的方式对你并不适用。 相关链接 原生JavaScript实现瀑布流布局jQuery实现一个瀑布流布局","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"CSS3","slug":"CSS3","permalink":"https://microzz.com/tags/CSS3/"},{"name":"waterfall","slug":"waterfall","permalink":"https://microzz.com/tags/waterfall/"},{"name":"瀑布流","slug":"瀑布流","permalink":"https://microzz.com/tags/瀑布流/"}]},{"title":"原生JavaScript实现瀑布流布局","date":"2017-02-17T09:35:03.000Z","path":"2017/02/17/waterfalljs/","text":"原生JavaScript实现一个瀑布流布局瀑布流布局概念瀑布流，又称瀑布流式布局。是比较流行的一种网站页面布局，视觉表现为参差不齐的多栏布局，随着页面滚动条向下滚动，这种布局还会不断加载数据块并附加至当前尾部。最早采用此布局的网站是Pinterest，逐渐在国内流行开来。国内大多数清新站基本为这类风格。 瀑布流布局特点 琳琅满目：整版以图片为主，大小不一的图片按照一定的规律排列。 唯美：图片的风格以唯美的图片为主。 操作简单：在浏览网站的时候只需要轻轻滑动一下鼠标滚轮，一切的美妙的图片精彩便可呈现在你面前。 代码实现源代码地址：🔗https://github.com/microzz/waterfall-js 效果预览 在线预览地址1： 🔗http://microzz.cn/waterfall/ 在线预览地址2： 🔗https://microzz.github.io/waterfall-js/ 瀑布流布局优缺点布局优点 有效的降低了界面复杂度，节省了空间：我们不再需要臃肿复杂的页码导航链接或按钮了。 对触屏设备来说，交互方式更符合直觉：在移动应用的交互环境当中，通过向上滑动进行滚屏的操作已经成为最基本的用户习惯，而且所需要的操作精准程度远远低于点击链接或按钮。 更高的参与度：以上两点所带来的交互便捷性可以使用户将注意力更多的集中在内容而不是操作上，从而让他们更乐于沉浸在探索与浏览当中。布局缺点 有限的用例：无限滚动的方式只适用于某些特定类型产品当中一部分特定类型的内容。例如，在电商网站当中，用户时常需要在商品列表与详情页面之间切换，这种情况下，传统的、带有页码导航的方式可以帮助用户更稳妥和准确的回到某个特定的列表页面当中。 额外的复杂度：那些用来打造无限滚动的JS库虽然都自称很容易使用，但你总会需要在自己的产品中进行不同程度的定制化处理，以满足你们自己的需求;另外这些JS库在浏览器和设备兼容性等方面的表现也参差不齐，你必须做好充分的测试与调整工作。 再见了，页脚：如果使用了比较典型的无限滚动加载模式，这就意味着你可以和页脚说拜拜了。最好考虑一下页脚对于你的网站，特别是用户的重要性;如果其中确实有比较重要的内容或链接，那么最好换一种更传统和稳妥的方式。千万不要耍弄你的用户，当他们一次次的浏览到页面底部，看到页脚，却因为自动加载的内容突然出现而无论如何都无法点击页脚中的链接时，他们会变的越发愤怒。 SEO：集中在一页当中动态加载数据，与一页一页的输出相比，究竟那种方式更利于SEO，这是你必须考虑的问题。对于某些以类型网站来说，在这方面进行冒险是很不划算的。 关于页面数量的印象：其实站在用户的角度来看，这一点并非负面;不过，如果对于你的网站来说，通过更多的内容页面展示更多的相关信息(包括广告)是很重要的策略，那么单页无限滚动的方式对你并不适用。 相关链接 CSS3实现一个瀑布流布局jQuery实现一个瀑布流布局","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"waterfall","slug":"waterfall","permalink":"https://microzz.com/tags/waterfall/"},{"name":"瀑布流","slug":"瀑布流","permalink":"https://microzz.com/tags/瀑布流/"}]},{"title":"Node.js实现一个小爬虫","date":"2017-02-14T08:33:13.000Z","path":"2017/02/14/crawler/","text":"Node.js实现一个小爬虫分析我们将用最简单的代码实现一个简单的小爬虫。本示例采用ES6写法。首先我们要安装第三方cheerio模块，在项目目录使用npm install cheerio --save 命令即可。在文件中我们需要引入如下模块： 模块名 作用 cheerio 类似jQuery，方便对DOM内容操作 https 针对https协议，http模块用法类似 代码实现// 引入模块 const https = require(&#39;https&#39;); const cheerio = require(&#39;cheerio&#39;); // 爬取目标网站URL let url = &#39;https://microzz.com&#39;; // 使用get方法访问 https.get(url, res =&gt; { let html = &#39;&#39;; // 监听data事件获取html源码 res.on(&#39;data&#39;, data =&gt; { html += data; }); // 监听end事件，同时把获取到的数据传给filterData方法进行过滤 res.on(&#39;end&#39;, () =&gt; { let titles = filterData(html); console.log(titles); }); }).on(&#39;error&#39;, e =&gt; { console.log(e.message); }); // 使用cheerio模块对内容进行筛选过滤 function filterData(html) { let $ = cheerio.load(html); let oTitles = $(&#39;.post-title-link&#39;); let titles = &#39;&#39;; oTitles.each( (index, item) =&gt; { let title = $(item).text(); let end = index == (oTitles.length - 1) ? &#39;&#39; : &#39;\\n&#39;; titles += &#39;【&#39; + (index+1) + &#39;】&#39; + title + end; }); return titles; } 至此一个简单的爬取 https://microzz.com 文章内容标题的小爬虫就完成啦😄","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://microzz.com/tags/Nodejs/"},{"name":"爬虫","slug":"爬虫","permalink":"https://microzz.com/tags/爬虫/"}]},{"title":"npm scripts 使用指南","date":"2017-02-13T11:51:28.000Z","path":"2017/02/13/npm-scripts/","text":"npm scripts 使用指南 &nbsp;&nbsp;&nbsp;Node 开发离不开 npm，而脚本功能是 npm 最强大、最常用的功能之一。本文介绍如何使用 npm 脚本（npm scripts）。 一、什么是 npm 脚本？npm 允许在package.json文件里面，使用scripts字段定义脚本命令。 { // ... &quot;scripts&quot;: { &quot;build&quot;: &quot;node build.js&quot; } } 上面代码是package.json文件的一个片段，里面的scripts字段是一个对象。它的每一个属性，对应一段脚本。比如，build命令对应的脚本是node build.js。命令行下使用npm run命令，就可以执行这段脚本。 $ npm run build # 等同于执行 $ node build.js 这些定义在package.json里面的脚本，就称为 npm 脚本。它的优点很多。项目的相关脚本，可以集中在一个地方。不同项目的脚本命令，只要功能相同，就可以有同样的对外接口。用户不需要知道怎么测试你的项目，只要运行npm run test即可。可以利用 npm 提供的很多辅助功能。查看当前项目的所有 npm 脚本命令，可以使用不带任何参数的npm run命令。 $ npm run 二、原理npm 脚本的原理非常简单。每当执行npm run，就会自动新建一个 Shell，在这个 Shell 里面执行指定的脚本命令。因此，只要是 Shell（一般是 Bash）可以运行的命令，就可以写在 npm 脚本里面。比较特别的是，npm run新建的这个 Shell，会将当前目录的node_modules/.bin子目录加入PATH变量，执行结束后，再将PATH变量恢复原样。这意味着，当前目录的node_modules/.bin子目录里面的所有脚本，都可以直接用脚本名调用，而不必加上路径。比如，当前项目的依赖里面有 Mocha，只要直接写mocha test就可以了。 &quot;test&quot;: &quot;mocha test&quot; 而不用写成下面这样。 &quot;test&quot;: &quot;./node_modules/.bin/mocha test&quot; 由于 npm 脚本的唯一要求就是可以在 Shell 执行，因此它不一定是 Node 脚本，任何可执行文件都可以写在里面。npm 脚本的退出码，也遵守 Shell 脚本规则。如果退出码不是0，npm 就认为这个脚本执行失败。 三、通配符由于 npm 脚本就是 Shell 脚本，因此可以使用 Shell 通配符。 &quot;lint&quot;: &quot;jshint *.js&quot; &quot;lint&quot;: &quot;jshint **/*.js&quot; 上面代码中，表示任意文件名，*表示任意一层子目录。如果要将通配符传入原始命令，防止被 Shell 转义，要将星号转义。 &quot;test&quot;: &quot;tap test/\\*.js&quot; 四、传参向 npm 脚本传入参数，要使用–标明。 &quot;lint&quot;: &quot;jshint **.js&quot; 向上面的npm run lint命令传入参数，必须写成下面这样。 $ npm run lint -- --reporter checkstyle &gt; checkstyle.xml 也可以在package.json里面再封装一个命令。 &quot;lint&quot;: &quot;jshint **.js&quot;, &quot;lint:checkstyle&quot;: &quot;npm run lint -- --reporter checkstyle &gt; checkstyle.xml&quot; 五、执行顺序如果 npm 脚本里面需要执行多个任务，那么需要明确它们的执行顺序。如果是并行执行（即同时的平行执行），可以使用&amp;符号。 $ npm run script1.js &amp; npm run script2.js 如果是继发执行（即只有前一个任务成功，才执行下一个任务），可以使用&amp;&amp;符号。 $ npm run script1.js &amp;&amp; npm run script2.js 这两个符号是 Bash 的功能。此外，还可以使用 node 的任务管理模块：script-runner、npm-run-all、redrun。 六、默认值一般来说，npm 脚本由用户提供。但是，npm 对两个脚本提供了默认值。也就是说，这两个脚本不用定义，就可以直接使用。 &quot;start&quot;: &quot;node server.js&quot;， &quot;install&quot;: &quot;node-gyp rebuild&quot; 上面代码中，npm run start的默认值是node server.js，前提是项目根目录下有server.js这个脚本；npm run install的默认值是node-gyp rebuild，前提是项目根目录下有binding.gyp文件。 七、钩子npm 脚本有pre和post两个钩子。举例来说，build脚本命令的钩子就是prebuild和postbuild。 &quot;prebuild&quot;: &quot;echo I run before the build script&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot;, &quot;postbuild&quot;: &quot;echo I run after the build script&quot; 用户执行npm run build的时候，会自动按照下面的顺序执行。 npm run prebuild &amp;&amp; npm run build &amp;&amp; npm run postbuild 因此，可以在这两个钩子里面，完成一些准备工作和清理工作。下面是一个例子。 &quot;clean&quot;: &quot;rimraf ./dist &amp;&amp; mkdir dist&quot;, &quot;prebuild&quot;: &quot;npm run clean&quot;, &quot;build&quot;: &quot;cross-env NODE_ENV=production webpack&quot; npm 默认提供下面这些钩子。 prepublish，postpublishpreinstall，postinstallpreuninstall，postuninstallpreversion，postversionpretest，posttestprestop，poststopprestart，poststartprerestart，postrestart 自定义的脚本命令也可以加上pre和post钩子。比如，myscript这个脚本命令，也有premyscript和postmyscript钩子。不过，双重的pre和post无效，比如prepretest和postposttest是无效的。npm 提供一个npm_lifecycle_event变量，返回当前正在运行的脚本名称，比如pretest、test、posttest等等。所以，可以利用这个变量，在同一个脚本文件里面，为不同的npm scripts命令编写代码。请看下面的例子。 const TARGET = process.env.npm_lifecycle_event; if (TARGET === &#39;test&#39;) { console.log(`Running the test task!`); } if (TARGET === &#39;pretest&#39;) { console.log(`Running the pretest task!`); } if (TARGET === &#39;posttest&#39;) { console.log(`Running the posttest task!`); } 注意，prepublish这个钩子不仅会在npm publish命令之前运行，还会在npm install（不带任何参数）命令之前运行。这种行为很容易让用户感到困惑，所以 npm 4 引入了一个新的钩子prepare，行为等同于prepublish，而从 npm 5 开始，prepublish将只在npm publish命令之前运行。 八、简写形式四个常用的 npm 脚本有简写形式。npm start是npm run startnpm stop是npm run stop的简写npm test是npm run test的简写npm restart是npm run stop &amp;&amp; npm run restart &amp;&amp; npm run start的简写npm start、npm stop和npm test都比较好理解，而npm restart是一个复合命令，实际上会执行三个脚本命令：stop、restart、start。具体的执行顺序如下。prerestartprestopstoppoststoprestartprestartstartpoststartpostrestart 九、变量npm 脚本有一个非常强大的功能，就是可以使用 npm 的内部变量。首先，通过npmpackage前缀，npm 脚本可以拿到package.json里面的字段。比如，下面是一个package.json。 { &quot;name&quot;: &quot;foo&quot;, &quot;version&quot;: &quot;1.2.5&quot;, &quot;scripts&quot;: { &quot;view&quot;: &quot;node view.js&quot; } } 那么，变量npm_package_name返回foo，变量npm_package_version返回1.2.5。 // view.js console.log(process.env.npm_package_name); // foo console.log(process.env.npm_package_version); // 1.2.5 上面代码中，我们通过环境变量process.env对象，拿到package.json的字段值。如果是 Bash 脚本，可以用\\$npm_package_name和$npm_package_version取到这两个值。npmpackage前缀也支持嵌套的package.json字段。 &quot;repository&quot;: { &quot;type&quot;: &quot;git&quot;, &quot;url&quot;: &quot;xxx&quot; }, scripts: { &quot;view&quot;: &quot;echo $npm_package_repository_type&quot; } 上面代码中，repository字段的type属性，可以通过npm_package_repository_type取到。下面是另外一个例子。 &quot;scripts&quot;: { &quot;install&quot;: &quot;foo.js&quot; } 上面代码中，npm_package_scripts_install变量的值等于foo.js。然后，npm 脚本还可以通过npmconfig前缀，拿到 npm 的配置变量，即npm config get xxx命令返回的值。比如，当前模块的发行标签，可以通过npm_config_tag取到。 &quot;view&quot;: &quot;echo $npm_config_tag&quot;, 注意，package.json里面的config对象，可以被环境变量覆盖。 { &quot;name&quot; : &quot;foo&quot;, &quot;config&quot; : { &quot;port&quot; : &quot;8080&quot; }, &quot;scripts&quot; : { &quot;start&quot; : &quot;node server.js&quot; } } 上面代码中，npm_package_config_port变量返回的是8080。这个值可以用下面的方法覆盖。 $ npm config set foo:port 80 最后，env命令可以列出所有环境变量。 &quot;env&quot;: &quot;env&quot; 十、常用脚本示例// 删除目录 &quot;clean&quot;: &quot;rimraf dist/*&quot;, // 本地搭建一个 HTTP 服务 &quot;serve&quot;: &quot;http-server -p 9090 dist/&quot;, // 打开浏览器 &quot;open:dev&quot;: &quot;opener http://localhost:9090&quot;, // 实时刷新 &quot;livereload&quot;: &quot;live-reload --port 9091 dist/&quot;, // 构建 HTML 文件 &quot;build:html&quot;: &quot;jade index.jade &gt; dist/index.html&quot;, // 只要 CSS 文件有变动，就重新执行构建 &quot;watch:css&quot;: &quot;watch &#39;npm run build:css&#39; assets/styles/&quot;, // 只要 HTML 文件有变动，就重新执行构建 &quot;watch:html&quot;: &quot;watch &#39;npm run build:html&#39; assets/html&quot;, // 部署到 Amazon S3 &quot;deploy:prod&quot;: &quot;s3-cli sync ./dist/ s3://example-com/prod-site/&quot;, // 构建 favicon &quot;build:favicon&quot;: &quot;node scripts/favicon.js&quot;,","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://microzz.com/tags/Nodejs/"},{"name":"npm","slug":"npm","permalink":"https://microzz.com/tags/npm/"},{"name":"js","slug":"js","permalink":"https://microzz.com/tags/js/"}]},{"title":"Mac 终端命令大全 (Shell)","date":"2017-02-12T10:24:35.000Z","path":"2017/02/12/mac-shell/","text":"Mac 终端命令大全目录操作 命令名 功能描述 使用举例 mkdir 创建一个目录 mkdir dirname rmdir 删除一个目录 rmdir dirname mvdir 移动或重命名一个目录 mvdir dir1 dir2 cd 改变当前目录 cd dirname pwd 显示当前目录的路径名 pwd ls 显示当前目录的内容 ls -la dircmp 比较两个目录的内容 dircmp dir1 dir2 文件操作 命令名 功能描述 使用举例 cat 显示或连接文件 cat filename pg 分页格式化显示文件内容 pg filename more 分屏显示文件内容 more filename od 显示非文本文件的内容 od -c filename cp 复制文件或目录 cp file1 file2 rm 删除文件或目录 rm filename mv 改变文件名或所在目录 mv file1 file2 ln 联接文件 ln -s file1 file2 find 使用匹配表达式查找文件 find . -name “*.c” -print file 显示文件类型 file filename open 使用默认的程序打开文件 open filename 选择操作 命令名 功能描述 使用举例 head 显示文件的最初几行 head -20 filename tail 显示文件的最后几行 tail -15 filename cut 显示文件每行中的某些域 cut -f1,7 -d: /etc/passwd colrm 从标准输入中删除若干列 colrm 8 20 file2 paste 横向连接文件 paste file1 file2 diff 比较并显示两个文件的差异 diff file1 file2 sed 非交互方式流编辑器 sed “s/red/green/g” filename grep 在文件中按模式查找 grep “^[a-zA-Z]” filename awk 在文件中查找并处理模式 awk ‘{print $1 $1}’ filename sort 排序或归并文件 sort -d -f -u file1 uniq 去掉文件中的重复行 uniq file1 file2 comm 显示两有序文件的公共和非公共行 comm file1 file2 wc 统计文件的字符数、词数和行数 wc filename nl 给文件加上行号 nl file1 &gt;file2 安全操作 命令名 功能描述 使用举例 passwd 修改用户密码 passwd chmod 改变文件或目录的权限 chmod ug+x filename umask 定义创建文件的权限掩码 umask 027 chown 改变文件或目录的属主 chown newowner filename chgrp 改变文件或目录的所属组 chgrp staff filename xlock 给终端上锁 xlock -remote 编程操作 命令名 功能描述 使用举例 make 维护可执行程序的最新版本 make touch 更新文件的访问和修改时间 touch -m 05202400 filename dbx 命令行界面调试工具 dbx a.out xde 图形用户界面调试工具 xde a.out 进程操作 命令名 功能描述 使用举例 ps 显示进程当前状态 ps u kill 终止进程 kill -9 30142 nice 改变待执行命令的优先级 nice cc -c *.c renice 改变已运行进程的优先级 renice +20 32768 时间操作 命令名 功能描述 使用举例 date 显示系统的当前日期和时间 date cal 显示日历 cal 8 1996 time 统计程序的执行时间 time a.out 网络与通信操作 命令名 功能描述 使用举例 telnet 远程登录 telnet hpc.sp.net.edu.cn rlogin 远程登录 rlogin hostname -l username rsh 在远程主机执行指定命令 rsh f01n03 date ftp 在本地主机与远程主机之间传输文件 ftp ftp.sp.net.edu.cn rcp 在本地主机与远程主机之间复制文件 rcp file1 host1:file2 ping 给一个网络主机发送回应请求 ping hpc.sp.net.edu.cn mail 阅读和发送电子邮件 mail write 给另一用户发送报文 write username pts/1 mesg 允许或拒绝接收报文 mesg n Korn Shell 命令 命令名 功能描述 使用举例 history 列出最近执行过的几条命令及编号 history r 重复执行最近执行过的某条命令 r -2 alias 给某个命令定义别名 alias del=rm -i unalias 取消对某个别名的定义 unalias del 其它命令 命令名 功能描述 使用举例 uname 显示操作系统的有关信息 uname -a clear 清除屏幕或窗口内容 clear env 显示当前所有设置过的环境变量 env who 列出当前登录的所有用户 who whoami 显示当前正进行操作的用户名 whoami tty 显示终端或伪终端的名称 tty stty 显示或重置控制键定义 stty -a du 查询磁盘使用情况 du -k subdir df 显示文件系统的总空间和可用空间 df /tmp w 显示当前系统活动的总信息 w","tags":[{"name":"开发者","slug":"开发者","permalink":"https://microzz.com/tags/开发者/"},{"name":"Mac","slug":"Mac","permalink":"https://microzz.com/tags/Mac/"},{"name":"Shell","slug":"Shell","permalink":"https://microzz.com/tags/Shell/"},{"name":"Linux","slug":"Linux","permalink":"https://microzz.com/tags/Linux/"},{"name":"Unix","slug":"Unix","permalink":"https://microzz.com/tags/Unix/"}]},{"title":"前端开发面试题集锦","date":"2017-02-10T10:01:15.000Z","path":"2017/02/10/interview/","text":"前端开发面试题前言前端还是一个年轻的行业，新的行业标准， 框架， 库都不断在更新和新增，正如赫门在2015深JS大会上的《前端服务化之路》主题演讲中说的一句话：“每18至24个月，前端都会难一倍”，这些变化使前端的能力更加丰富、创造的应用也会更加完美。所以关注各种前端技术，跟上快速变化的节奏，也是身为一个前端程序员必备的技能之一。 面试题目： 根据你的等级和职位的变化，入门级到专家级，广度和深度都会有所增加。 题目类型： 理论知识、算法、项目细节、技术视野、开放性题、工作案例。 细节追问： 可以确保问到你开始不懂或面试官开始不懂为止，这样可以大大延展题目的区分度和深度，知道你的实际能力。因为这种知识关联是长时期的学习，临时抱佛脚绝对是记不住的。 回答问题再棒，面试官（可能是你面试职位的直接领导），会考虑我要不要这个人做我的同事？所以态度很重要、除了能做事，还要会做人。（感觉更像是相亲( •̣̣̣̣̣̥́௰•̣̣̣̣̣̥̀ )） 资深的前端开发能把absolute和relative弄混，这样的人不要也罢，因为团队需要的是：你这个人具有可以依靠的才能（靠谱）。 前端开发知识点： HTML&amp;CSS： 对Web标准的理解、浏览器内核差异、兼容性、hack、CSS基本功：布局、盒子模型、选择器优先级、 HTML5、CSS3、Flexbox JavaScript： 数据类型、运算、对象、Function、继承、闭包、作用域、原型链、事件、RegExp、JSON、Ajax、 DOM、BOM、内存泄漏、跨域、异步装载、模板引擎、前端MVC、路由、模块化、Canvas、ECMAScript 6、Nodejs 其他： 移动端、响应式、自动化构建、HTTP、离线存储、WEB安全、优化、重构、团队协作、可维护、易用性、SEO、UED、架构、职业生涯、快速学习能力 作为一名前端工程师，无论工作年头长短都应该掌握的知识点： 1、DOM结构 —— 两个节点之间可能存在哪些关系以及如何在节点之间任意移动。 2、DOM操作 —— 如何添加、移除、移动、复制、创建和查找节点等。 3、事件 —— 如何使用事件，以及IE和标准DOM事件模型之间存在的差别。 4、XMLHttpRequest —— 这是什么、怎样完整地执行一次GET请求、怎样检测错误。 5、严格模式与混杂模式 —— 如何触发这两种模式，区分它们有何意义。 6、盒模型 —— 外边距、内边距和边框之间的关系，及IE8以下版本的浏览器中的盒模型 7、块级元素与行内元素 —— 怎么用CSS控制它们、以及如何合理的使用它们 8、浮动元素 —— 怎么使用它们、它们有什么问题以及怎么解决这些问题。 9、HTML与XHTML —— 二者有什么区别，你觉得应该使用哪一个并说出理由。 10、JSON —— 作用、用途、设计结构。 备注： 根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达。 资料答案不够正确和全面，欢迎欢迎Star和提交issues。 格式不断修改更新中。 更新记录： 2016年3月25日：新增ECMAScript6 相关问题 HTML Doctype作用？标准模式与兼容模式各有什么区别? （1）、&lt;!DOCTYPE&gt;声明位于位于HTML文档中的第一行，处于 &lt;html&gt; 标签之前。告知浏览器的解析器用什么文档标准解析这个文档。DOCTYPE不存在或格式不正确会导致文档以兼容模式呈现。 （2）、标准模式的排版 和JS运作模式都是以该浏览器支持的最高标准运行。在兼容模式中，页面以宽松的向后兼容的方式显示,模拟老式浏览器的行为以防止站点无法工作。 HTML5 为什么只需要写 &lt;!DOCTYPE HTML&gt;？ HTML5 不基于 SGML，因此不需要对DTD进行引用，但是需要doctype来规范浏览器的行为（让浏览器按照它们应该的方式来运行）； 而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型。 行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？ 首先：CSS规范规定，每个元素都有display属性，确定该元素的类型，每个元素都有默认的display值，如div的display默认值为“block”，则为“块级”元素；span默认display属性值为“inline”，是“行内”元素。 （1）行内元素有：a b span img input select strong（强调的语气） （2）块级元素有：div ul ol li dl dt dd h1 h2 h3 h4…p （3）常见的空元素： &lt;br&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;link&gt; &lt;meta&gt; 鲜为人知的是： &lt;area&gt; &lt;base&gt; &lt;col&gt; &lt;command&gt; &lt;embed&gt; &lt;keygen&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt; 不同浏览器（版本）、HTML4（5）、CSS2等实际略有差异 参考: http://stackoverflow.com/questions/6867254/browsers-default-css-for-html-elements 页面导入样式时，使用link和@import有什么区别？ （1）link属于XHTML标签，除了加载CSS外，还能用于定义RSS, 定义rel连接属性等作用；而@import是CSS提供的，只能用于加载CSS; （2）页面被加载的时，link会同时被加载，而@import引用的CSS会等到页面被加载完再加载; （3）import是CSS2.1 提出的，只在IE5以上才能被识别，而link是XHTML标签，无兼容问题; 介绍一下你对浏览器内核的理解？ 主要分成两部分：渲染引擎(layout engineer或Rendering Engine)和JS引擎。 渲染引擎：负责取得网页的内容（HTML、XML、图像等等）、整理讯息（例如加入CSS等），以及计算网页的显示方式，然后会输出至显示器或打印机。浏览器的内核的不同对于网页的语法解释会有不同，所以渲染的效果也不相同。所有网页浏览器、电子邮件客户端以及其它需要编辑、显示网络内容的应用程序都需要内核。 JS引擎则：解析和执行javascript来实现网页的动态效果。 最开始渲染引擎和JS引擎并没有区分的很明确，后来JS引擎越来越独立，内核就倾向于只指渲染引擎。 常见的浏览器内核有哪些？ Trident内核：IE,MaxThon,TT,The World,360,搜狗浏览器等。[又称MSHTML] Gecko内核：Netscape6及以上版本，FF,MozillaSuite/SeaMonkey等 Presto内核：Opera7及以上。 [Opera内核原为：Presto，现为：Blink;] Webkit内核：Safari,Chrome等。 [ Chrome的：Blink（WebKit的分支）] 详细文章：[浏览器内核的解析和对比](http://www.cnblogs.com/fullhouse/archive/2011/12/19/2293455.html) html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和HTML5？ * HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 绘画 canvas; 用于媒介回放的 video 和 audio 元素; 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失; sessionStorage 的数据在浏览器关闭后自动删除; 语意化更好的内容元素，比如 article、footer、header、nav、section; 表单控件，calendar、date、time、email、url、search; 新的技术webworker, websocket, Geolocation; 移除的元素： 纯表现的元素：basefont，big，center，font, s，strike，tt，u; 对可用性产生负面影响的元素：frame，frameset，noframes； * 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 浏览器支持新标签后，还需要添加标签默认的样式。 当然也可以直接使用成熟的框架、比如html5shim; &lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt; * 如何区分HTML5： DOCTYPE声明\\新增的结构元素\\功能元素 简述一下你对HTML语义化的理解？ 用正确的标签做正确的事情。 html语义化让页面的内容结构化，结构更清晰，便于对浏览器、搜索引擎解析; 即使在没有样式CSS情况下也以一种文档格式显示，并且是容易阅读的; 搜索引擎的爬虫也依赖于HTML标记来确定上下文和各个关键字的权重，利于SEO; 使阅读源代码的人对网站更容易将网站分块，便于阅读维护理解。 HTML5的离线储存怎么使用，工作原理能不能解释一下？ 在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。 原理：HTML5的离线存储是基于一个新建的.appcache文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示。 如何使用： 1、页面头部像下面一样加入一个manifest的属性； 2、在cache.manifest文件的编写离线存储的资源； CACHE MANIFEST #v0.11 CACHE: js/app.js css/style.css NETWORK: resourse/logo.png FALLBACK: / /offline.html 3、在离线状态时，操作window.applicationCache进行需求实现。 详细的使用请参考： [HTML5 离线缓存-manifest简介](http://yanhaijing.com/html/2014/12/28/html5-manifest/) [有趣的HTML5：离线存储](http://segmentfault.com/a/1190000000732617) 浏览器是怎么对HTML5的离线储存资源进行管理和加载的呢？ 在线的情况下，浏览器发现html头部有manifest属性，它会请求manifest文件，如果是第一次访问app，那么浏览器就会根据manifest文件的内容下载相应的资源并且进行离线存储。如果已经访问过app并且资源已经离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的manifest文件与旧的manifest文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，那么就会重新下载文件中的资源并进行离线存储。 离线的情况下，浏览器就直接使用离线存储的资源。 详细请参考：有趣的HTML5：离线存储 请描述一下 cookies，sessionStorage 和 localStorage 的区别？ cookie是网站为了标示用户身份而储存在用户本地终端（Client Side）上的数据（通常经过加密）。 cookie数据始终在同源的http请求中携带（即使不需要），记会在浏览器和服务器间来回传递。 sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 存储大小： cookie数据大小不能超过4k。 sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 有期时间： localStorage 存储持久数据，浏览器关闭后数据不丢失除非主动删除数据； sessionStorage 数据在当前浏览器窗口关闭后自动删除。 cookie 设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭 iframe有那些缺点？ *iframe会阻塞主页面的Onload事件； *搜索引擎的检索程序无法解读这种页面，不利于SEO; *iframe和主页面共享连接池，而浏览器对相同域的连接有限制，所以会影响页面的并行加载。 使用iframe之前需要考虑这两个缺点。如果需要使用iframe，最好是通过javascript 动态给iframe添加src属性值，这样可以绕开以上两个问题。 Label的作用是什么？是怎么用的？ label标签来定义表单控制间的关系,当用户选择该标签时，浏览器会自动将焦点转到和标签相关的表单控件上。 &lt;label for=&quot;Name&quot;&gt;Number:&lt;/label&gt; &lt;input type=“text“name=&quot;Name&quot; id=&quot;Name&quot;/&gt; &lt;label&gt;Date:&lt;input type=&quot;text&quot; name=&quot;B&quot;/&gt;&lt;/label&gt; HTML5的form如何关闭自动完成功能？ 给不想要提示的 form 或某个 input 设置为 autocomplete=off。 如何实现浏览器内多个标签页之间的通信? (阿里) WebSocket、SharedWorker； 也可以调用localstorge、cookies等本地存储方式； localstorge另一个浏览上下文里被添加、修改或删除时，它都会触发一个事件， 我们通过监听事件，控制它的值来进行页面信息通信； 注意quirks：Safari 在无痕模式下设置localstorge值时会抛出 QuotaExceededError 的异常； webSocket如何兼容低浏览器？(阿里) Adobe Flash Socket 、 ActiveX HTMLFile (IE) 、 基于 multipart 编码发送 XHR 、 基于长轮询的 XHR 页面可见性（Page Visibility API） 可以有哪些用途？ 通过 visibilityState 的值检测页面当前是否可见，以及打开网页的时间等; 在页面被切换到其他后台进程的时候，自动暂停音乐或视频的播放； 如何在页面上实现一个圆形的可点击区域？ 1、map+area或者svg 2、border-radius 3、纯js实现 需要求一个点在不在圆上简单算法、获取鼠标坐标等等 实现不使用 border 画出1px高的线，在不同浏览器的标准模式与怪异模式下都能保持一致的效果。 &lt;div style=&quot;height:1px;overflow:hidden;background:red&quot;&gt;&lt;/div&gt; 网页验证码是干嘛的，是为了解决什么安全问题。 区分用户是计算机还是人的公共全自动程序。可以防止恶意破解密码、刷票、论坛灌水； 有效防止黑客对某一个特定注册用户用特定程序暴力破解方式进行不断的登陆尝试。 title与h1的区别、b与strong的区别、i与em的区别？ title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取也有很大的影响； strong是标明重点内容，有语气加强的含义，使用阅读设备阅读网络时：&lt;strong&gt;会重读，而&lt;B&gt;是展示强调内容。 i内容展示为斜体，em表示强调的文本； Physical Style Elements -- 自然样式标签 b, i, u, s, pre Semantic Style Elements -- 语义样式标签 strong, em, ins, del, code 应该准确使用语义样式标签, 但不能滥用, 如果不能确定时首选使用自然样式标签。 CSS 介绍一下标准的CSS的盒子模型？低版本IE的盒子模型有什么不同的？ （1）有两种， IE 盒子模型、W3C 盒子模型； （2）盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)； （3）区 别： IE的content部分把 border 和 padding计算了进去; CSS选择符有哪些？哪些属性可以继承？ * 1.id选择器（ # myid） 2.类选择器（.myclassname） 3.标签选择器（div, h1, p） 4.相邻选择器（h1 + p） 5.子选择器（ul &gt; li） 6.后代选择器（li a） 7.通配符选择器（ * ） 8.属性选择器（a[rel = &quot;external&quot;]） 9.伪类选择器（a:hover, li:nth-child） * 可继承的样式： font-size font-family color, UL LI DL DD DT; * 不可继承的样式：border padding margin width height ; CSS优先级算法如何计算？ * 优先级就近原则，同权重情况下样式定义最近者为准; * 载入样式以最后载入的定位为准; 优先级为: 同权重: 内联样式表（标签内部）&gt; 嵌入样式表（当前文件中）&gt; 外部样式表（外部文件中）。 !important &gt; id &gt; class &gt; tag important 比 内联优先级高 CSS3新增伪类有那些？ 举例： p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :after 在元素之前添加内容,也可以用来做清除浮动。 :before 在元素之后添加内容 :enabled :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中。 如何居中div？ * 水平居中：给div设置一个宽度，然后添加margin:0 auto属性 div{ width:200px; margin:0 auto; } * 让绝对定位的div居中 div { position: absolute; width: 300px; height: 300px; margin: auto; top: 0; left: 0; bottom: 0; right: 0; background-color: pink; /* 方便看效果 */ } * 水平垂直居中一 确定容器的宽高 宽500 高 300 的层 设置层的外边距 div { position: relative; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; margin: -150px 0 0 -250px; /* 外边距为自身宽高的一半 */ background-color: pink; /* 方便看效果 */ } * 水平垂直居中二 未知容器的宽高，利用 `transform` 属性 div { position: absolute; /* 相对定位或绝对定位均可 */ width:500px; height:300px; top: 50%; left: 50%; transform: translate(-50%, -50%); background-color: pink; /* 方便看效果 */ } * 水平垂直居中三 利用 flex 布局 实际使用时应考虑兼容性 .container { display: flex; align-items: center; /* 垂直居中 */ justify-content: center; /* 水平居中 */ } .container div { width: 100px; height: 100px; background-color: pink; /* 方便看效果 */ } display有哪些值？说明他们的作用。 block 块类型。默认宽度为父元素宽度，可设置宽高，换行显示。 none 缺省值。象行内元素类型一样显示。 inline 行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。 inline-block 默认宽度为内容宽度，可以设置宽高，同行显示。 list-item 象块类型元素一样显示，并添加样式列表标记。 table 此元素会作为块级表格来显示。 inherit 规定应该从父元素继承 display 属性的值。 position的值relative和absolute定位原点是？ absolute 生成绝对定位的元素，相对于值不为 static的第一个父元素进行定位。 fixed （老IE不支持） 生成绝对定位的元素，相对于浏览器窗口进行定位。 relative 生成相对定位的元素，相对于其正常位置进行定位。 static 默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right z-index 声明）。 inherit 规定从父元素继承 position 属性的值。 CSS3有哪些新特性？ 新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点） 圆角 （border-radius:8px） 多列布局 （multi-column layout） 阴影和反射 （Shadow\\Reflect） 文字特效 （text-shadow、） 文字渲染 （Text-decoration） 线性渐变 （gradient） 旋转 （transform） 缩放,定位,倾斜,动画,多背景 例如:transform:\\scale(0.85,0.90)\\ translate(0px,-30px)\\ skew(-9deg,0deg)\\Animation: 请解释一下CSS3的Flexbox（弹性盒布局模型）,以及适用场景？ 一个用于页面布局的全新CSS3功能，Flexbox可以把列表放在同一个方向（从上到下排列，从左到右），并让列表能延伸到占用可用的空间。 较为复杂的布局还可以通过嵌套一个伸缩容器（flex container）来实现。 采用Flex布局的元素，称为Flex容器（flex container），简称&quot;容器&quot;。 它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称&quot;项目&quot;。 常规布局是基于块和内联流方向，而Flex布局是基于flex-flow流可以很方便的用来做局中，能对不同屏幕大小自适应。 在布局上有了比以前更加灵活的空间。 具体：http://www.w3cplus.com/css3/flexbox-basics.html 用纯CSS创建一个三角形的原理是什么？ 把上、左、右三条边隐藏掉（颜色设为 transparent） #demo { width: 0; height: 0; border-width: 20px; border-style: solid; border-color: transparent transparent red transparent; } 一个满屏 品 字布局 如何设计? 简单的方式： 上面的div宽100%， 下面的两个div分别宽50%， 然后用float或者inline使其不换行即可 css多列等高如何实现？ 利用padding-bottom|margin-bottom正负值相抵； 设置父容器设置超出隐藏（overflow:hidden），这样子父容器的高度就还是它里面的列没有设定padding-bottom时的高度， 当它里面的任 一列高度增加了，则父容器的高度被撑到里面最高那列的高度， 其他比这列矮的列会用它们的padding-bottom补偿这部分高度差。 经常遇到的浏览器的兼容性有哪些？原因，解决方法是什么，常用hack的技巧 ？ * png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8. * 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。 * IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 浮动ie产生的双倍距离 #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 ——_display:inline;将其转化为行内属性。(_这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 css .bb{ background-color:red;/*所有识别*/ background-color:#00deff\\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/ } * IE下,可以使用获取常规属性的方法来获取自定义属性, 也可以使用getAttribute()获取自定义属性; Firefox下,只能使用getAttribute()获取自定义属性。 解决方法:统一通过getAttribute()获取自定义属性。 * IE下,even对象有x,y属性,但是没有pageX,pageY属性; Firefox下,event对象有pageX,pageY属性,但是没有x,y属性。 * 解决方法：（条件注释）缺点是在IE浏览器下可能会增加额外的HTTP请求数。 * Chrome 中文界面下默认会将小于 12px 的文本强制按照 12px 显示, 可通过加入 CSS 属性 -webkit-text-size-adjust: none; 解决。 超链接访问过后hover样式就不出现了 被点击访问过的超链接样式不在具有hover和active了解决方法是改变CSS属性的排列顺序: L-V-H-A : a:link {} a:visited {} a:hover {} a:active {} li与li之间有看不见的空白间隔是什么原因引起的？有什么解决办法？ 行框的排列会受到中间空白（回车\\空格）等的影响，因为空格也属于字符,这些空白也会被应用样式，占据空间，所以会有间隔，把字符大小设为0，就没有空格了。 为什么要初始化CSS样式。 - 因为浏览器的兼容问题，不同浏览器对有些标签的默认值是不同的，如果没对CSS初始化往往会出现浏览器之间的页面显示差异。 - 当然，初始化样式会对SEO有一定的影响，但鱼和熊掌不可兼得，但力求影响最小的情况下初始化。 最简单的初始化方法： * {padding: 0; margin: 0;} （强烈不建议） 淘宝的样式初始化代码： body, h1, h2, h3, h4, h5, h6, hr, p, blockquote, dl, dt, dd, ul, ol, li, pre, form, fieldset, legend, button, input, textarea, th, td { margin:0; padding:0; } body, button, input, select, textarea { font:12px/1.5tahoma, arial, \\5b8b\\4f53; } h1, h2, h3, h4, h5, h6{ font-size:100%; } address, cite, dfn, em, var { font-style:normal; } code, kbd, pre, samp { font-family:couriernew, courier, monospace; } small{ font-size:12px; } ul, ol { list-style:none; } a { text-decoration:none; } a:hover { text-decoration:underline; } sup { vertical-align:text-top; } sub{ vertical-align:text-bottom; } legend { color:#000; } fieldset, img { border:0; } button, input, select, textarea { font-size:100%; } table { border-collapse:collapse; border-spacing:0; } absolute的containing block(容器块)计算方式跟正常流有什么不同？ 无论属于哪种，都要先找到其祖先元素中最近的 position 值不为 static 的元素，然后再判断： 1、若此元素为 inline 元素，则 containing block 为能够包含这个元素生成的第一个和最后一个 inline box 的 padding box (除 margin, border 外的区域) 的最小矩形； 2、否则,则由这个祖先元素的 padding box 构成。 如果都找不到，则为 initial containing block。 补充： 1. static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分） 2. absolute: 向上找最近的定位为absolute/relative的元素 3. fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block CSS里的visibility属性有个collapse属性值是干嘛用的？在不同浏览器下以后什么区别？ 对于普通元素visibility:collapse;会将元素完全隐藏,不占据页面布局空间,与display:none;表现相同. 如果目标元素为table,visibility:collapse;将table隐藏,但是会占据页面布局空间. 仅在Firefox下起作用,IE会显示元素,Chrome会将元素隐藏,但是占据空间. position跟display、margin collapse、overflow、float这些特性相互叠加后会怎么样？ 如果元素的display为none,那么元素不被渲染,position,float不起作用,如果元素拥有position:absolute;或者position:fixed;属性那么元素将为绝对定位,float不起作用.如果元素float属性不是none,元素会脱离文档流,根据float属性值来显示.有浮动,绝对定位,inline-block属性的元素,margin不会和垂直方向上的其他元素margin折叠. 对BFC规范(块级格式化上下文：block formatting context)的理解？ （W3C CSS 2.1 规范中的一个概念,它是一个独立容器，决定了元素如何对其内容进行定位,以及与其他元素的关系和相互作用。） 一个页面是由很多个 Box 组成的,元素的类型和 display 属性,决定了这个 Box 的类型。 不同类型的 Box,会参与不同的 Formatting Context（决定如何渲染文档的容器）,因此Box内的元素会以不同的方式渲染,也就是说BFC内部的元素和外部的元素不会互相影响。 css定义的权重 以下是权重的规则：标签的权重为1，class的权重为10，id的权重为100，以下例子是演示各种定义的权重值： /*权重为1*/ div{ } /*权重为10*/ .class1{ } /*权重为100*/ #id1{ } /*权重为100+1=101*/ #id1 div{ } /*权重为10+1=11*/ .class1 div{ } /*权重为10+10+1=21*/ .class1 .class2 div{ } 如果权重相同，则最后定义的样式会起作用，但是应该避免这种情况出现 请解释一下为什么需要清除浮动？清除浮动的方式 清除浮动是为了清除使用浮动元素产生的影响。浮动的元素，高度会塌陷，而高度的塌陷使我们页面后面的布局不能正常显示。 1、父级div定义height； 2、父级div 也一起浮动； 3、常规的使用一个class； .clearfix:before, .clearfix:after { content: &quot; &quot;; display: table; } .clearfix:after { clear: both; } .clearfix { *zoom: 1; } 4、SASS编译的时候，浮动元素的父级div定义伪类:after &amp;:after,&amp;:before{ content: &quot; &quot;; visibility: hidden; display: block; height: 0; clear: both; } 解析原理： 1) display:block 使生成的元素以块级元素显示,占满剩余空间; 2) height:0 避免生成内容破坏原有布局的高度。 3) visibility:hidden 使生成的内容不可见，并允许可能被生成内容盖住的内容可以进行点击和交互; 4）通过 content:&quot;.&quot;生成内容作为最后一个元素，至于content里面是点还是其他都是可以的，例如oocss里面就有经典的 content:&quot;.&quot;,有些版本可能content 里面内容为空,一丝冰凉是不推荐这样做的,firefox直到7.0 content:”&quot; 仍然会产生额外的空隙； 5）zoom：1 触发IE hasLayout。 通过分析发现，除了clear：both用来闭合浮动的，其他代码无非都是为了隐藏掉content生成的内容，这也就是其他版本的闭合浮动为什么会有font-size：0，line-height：0。 什么是外边距合并？ 外边距合并指的是，当两个垂直外边距相遇时，它们将形成一个外边距。 合并后的外边距的高度等于两个发生合并的外边距的高度中的较大者。 w3school介绍网址： http://www.w3school.com.cn/css/css_margin_collapsing.asp zoom:1的清除浮动原理? 清除浮动，触发hasLayout； Zoom属性是IE浏览器的专有属性，它可以设置或检索对象的缩放比例。解决ie下比较奇葩的bug。 譬如外边距（margin）的重叠，浮动清除，触发ie的haslayout属性等。 来龙去脉大概如下： 当设置了zoom的值之后，所设置的元素就会就会扩大或者缩小，高度宽度就会重新计算了，这里一旦改变zoom值时其实也会发生重新渲染，运用这个原理，也就解决了ie下子元素浮动时候父元素不随着自动扩大的问题。 Zoom属是IE浏览器的专有属性，火狐和老版本的webkit核心的浏览器都不支持这个属性。然而，zoom现在已经被逐步标准化，出现在 CSS 3.0 规范草案中。 目前非ie由于不支持这个属性，它们又是通过什么属性来实现元素的缩放呢？ 可以通过css3里面的动画属性scale进行缩放。 移动端的布局用过媒体查询吗？ 假设你现在正用一台显示设备来阅读这篇文章，同时你也想把它投影到屏幕上，或者打印出来， 而显示设备、屏幕投影和打印等这些媒介都有自己的特点，CSS就是为文档提供在不同媒介上展示的适配方法 &lt;!-- link元素中的CSS媒体查询 --&gt; 当媒体查询为真时，相关的样式表或样式规则会按照正常的级联规被应用。 当媒体查询返回假， &lt;link&gt; 标签上带有媒体查询的样式表 仍将被下载 （只不过不会被应用）。 &lt;link rel=&quot;stylesheet&quot; media=&quot;(max-width: 800px)&quot; href=&quot;example.css&quot; /&gt; &lt;!-- 样式表中的CSS媒体查询 --&gt; 包含了一个媒体类型和至少一个使用 宽度、高度和颜色等媒体属性来限制样式表范围的表达式。 CSS3加入的媒体查询使得无需修改内容便可以使样式应用于某些特定的设备范围。 &lt;style&gt; @media (min-width: 700px) and (orientation: landscape){ .sidebar { display: none; } } &lt;/style&gt; 使用 CSS 预处理器吗？喜欢那个？ SASS (SASS、LESS没有本质区别，只因为团队前端都是用的SASS) CSS优化、提高性能的方法有哪些？ 关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）； 如果规则拥有 ID 选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）； 提取项目的通用公有样式，增强可复用性，按模块编写组件；增强项目的协同开发性、可维护性和可扩展性; 使用预处理工具或构建工具（gulp对css进行语法检查、自动补前缀、打包压缩、自动优雅降级）； 浏览器是怎样解析CSS选择器的？ 样式系统从关键选择器开始匹配，然后左移查找规则选择器的祖先元素。 只要选择器的子树一直在工作，样式系统就会持续左移，直到和规则匹配，或者是因为不匹配而放弃该规则。 在网页中的应该使用奇数还是偶数的字体？为什么呢？ margin和padding分别适合什么场景使用？ margin是用来隔开元素与元素的间距；padding是用来隔开元素与内容的间隔。 margin用于布局分开元素使元素与元素互不相干； padding用于元素与内容之间的间隔，让内容（文字）与（包裹）元素之间有一段 抽离样式模块怎么写，说出思路，有无实践经验？[阿里航旅的面试题] 元素竖向的百分比设定是相对于容器的高度吗？ 全屏滚动的原理是什么？用到了CSS的那些属性？ 什么是响应式设计？响应式设计的基本原理是什么？如何兼容低版本的IE？ 视差滚动效果，如何给每页做不同的动画？（回到顶部，向下滑动要再次出现，和只出现一次分别怎么做？） ::before 和 :after中双冒号和单冒号 有什么区别？解释一下这2个伪元素的作用。 单冒号(:)用于CSS3伪类，双冒号(::)用于CSS3伪元素。（伪元素由双冒号和伪元素名称组成） 双冒号是在当前规范中引入的，用于区分伪类和伪元素。不过浏览器需要同时支持旧的已经存在的伪元素写法， 比如:first-line、:first-letter、:before、:after等， 而新的在CSS3中引入的伪元素则不允许再支持旧的单冒号的写法。 想让插入的内容出现在其它内容前，使用::before，否者，使用::after； 在代码顺序上，::after生成的内容也比::before生成的内容靠后。 如果按堆栈视角，::after生成的内容会在::before生成的内容之上 如何修改chrome记住密码后自动填充表单的黄色背景 ？ input:-webkit-autofill, textarea:-webkit-autofill, select:-webkit-autofill { background-color: rgb(250, 255, 189); /* #FAFFBD; */ background-image: none; color: rgb(0, 0, 0); } 你对line-height是如何理解的？ 设置元素浮动后，该元素的display值是多少？ 自动变成了 display: inline-block 怎么让Chrome支持小于12px 的文字？ 1、用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。 2、使用12px及12px以上字体大小：为了兼容各大主流浏览器，建议设计美工图时候设置大于或等于12px的字体大小，如果是接单的这个时候就需要给客户讲解小于12px浏览器不兼容等事宜。 3、继续使用小于12px字体大小样式设置：如果不考虑chrome可以不用考虑兼容，同时在设置小于12px对象设置-webkit-text-size-adjust:none，做到最大兼容考虑。 4、使用12px以上字体：为了兼容、为了代码更简单 从新考虑权重下兼容性。 让页面里的字体变清晰，变细用CSS怎么做？ -webkit-font-smoothing: antialiased; font-style属性可以让它赋值为“oblique” oblique是什么意思？ 倾斜的字体样式 position:fixed;在android下无效怎么处理？ fixed的元素是相对整个页面固定位置的，你在屏幕上滑动只是在移动这个所谓的viewport， 原来的网页还好好的在那，fixed的内容也没有变过位置， 所以说并不是iOS不支持fixed，只是fixed的元素不是相对手机屏幕固定的。 &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0, user-scalable=no&quot;/&gt; 如果需要手动写动画，你认为最小时间间隔是多久，为什么？（阿里） 多数显示器默认频率是60Hz，即1秒刷新60次，所以理论上最小间隔为1/60＊1000ms ＝ 16.7ms display:inline-block 什么时候会显示间隙？(携程) 移除空格、使用margin负值、使用font-size:0、letter-spacing、word-spacing overflow: scroll时不能平滑滚动的问题怎么处理？ 有一个高度自适应的div，里面有两个div，一个高度100px，希望另一个填满剩下的高度。 png、jpg、gif 这些图片格式解释一下，分别什么时候用。有没有了解过webp？ 什么是Cookie 隔离？（或者说：请求资源的时候不要让它带cookie怎么做） 如果静态文件都放在主域名下，那静态文件请求的时候都带有的cookie的数据提交给server的，非常浪费流量， 所以不如隔离开。 因为cookie有域的限制，因此不能跨域提交请求，故使用非主要域名的时候，请求头中就不会带有cookie数据， 这样可以降低请求头的大小，降低请求时间，从而达到降低整体请求延时的目的。 同时这种方式不会将cookie传入Web Server，也减少了Web Server对cookie的处理分析环节， 提高了webserver的http请求的解析速度。 style标签写在body后与body前有什么区别？ 什么是CSS 预处理器 / 后处理器？ - 预处理器例如：LESS、Sass、Stylus，用来预编译Sass或less，增强了css代码的复用性， 还有层级、mixin、变量、循环、函数等，具有很方便的UI组件模块化开发能力，极大的提高工作效率。 - 后处理器例如：PostCSS，通常被视为在完成的样式表中根据CSS规范处理CSS，让其更有效；目前最常做的 是给CSS属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。 JavaScript 介绍js的基本数据类型。 Undefined、Null、Boolean、Number、String、 ECMAScript 2015 新增:Symbol(创建后独一无二且不可变的数据类型 ) 介绍js有哪些内置对象？ Object 是 JavaScript 中所有对象的父对象 数据封装类对象：Object、Array、Boolean、Number 和 String 其他对象：Function、Arguments、Math、Date、RegExp、Error 参考：http://www.ibm.com/developerworks/cn/web/wa-objectsinjs-v1b/index.html 说几条写JavaScript的基本规范？ 1.不要在同一行声明多个变量。 2.请使用 ===/!==来比较true/false或者数值 3.使用对象字面量替代new Array这种形式 4.不要使用全局函数。 5.Switch语句必须带有default分支 6.函数不应该有时候有返回值，有时候没有返回值。 7.For循环必须使用大括号 8.If语句必须使用大括号 9.for-in循环中的变量 应该使用var关键字明确限定作用域，从而避免作用域污染。 JavaScript原型，原型链 ? 有什么特点？ 每个对象都会在其内部初始化一个属性，就是prototype(原型)，当我们访问一个对象的属性时， 如果这个对象内部不存在这个属性，那么他就会去prototype里找这个属性，这个prototype又会有自己的prototype， 于是就这样一直找下去，也就是我们平时所说的原型链的概念。 关系：instance.constructor.prototype = instance.__proto__ 特点： JavaScript对象是通过引用来传递的，我们创建的每个新对象实体中并没有一份属于自己的原型副本。当我们修改原型时，与之相关的对象也会继承这一改变。 当我们需要一个属性的时，Javascript引擎会先看当前对象中是否有这个属性， 如果没有的话， 就会查找他的Prototype对象是否有这个属性，如此递推下去，一直检索到 Object 内建对象。 function Func(){} Func.prototype.name = &quot;Sean&quot;; Func.prototype.getInfo = function() { return this.name; } var person = new Func();//现在可以参考var person = Object.create(oldObject); console.log(person.getInfo());//它拥有了Func的属性和方法 //&quot;Sean&quot; console.log(Func.prototype); // Func { name=&quot;Sean&quot;, getInfo=function()} JavaScript有几种类型的值？，你能画一下他们的内存图吗？ 栈：原始数据类型（Undefined，Null，Boolean，Number、String） 堆：引用数据类型（对象、数组和函数） 两种类型的区别是：存储位置不同； 原始数据类型直接存储在栈(stack)中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储； 引用数据类型存储在堆(heap)中的对象,占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体 如何将字符串转化为数字，例如’12.3b’? * parseFloat(&#39;12.3b&#39;); * 正则表达式，&#39;12.3b&#39;.match(/(\\d)+(\\.)?(\\d)+/g)[0] * 1, 但是这个不太靠谱，提供一种思路而已。 如何将浮点数点左边的数每三位添加一个逗号，如12000000.11转化为『12,000,000.11』? function commafy(num){ return num &amp;&amp; num .toString() .replace(/(\\d)(?=(\\d{3})+\\.)/g, function($1, $2){ return $2 + &#39;,&#39;; }); } 如何实现数组的随机排序？ 方法一： ```javascript var arr = [1,2,3,4,5,6,7,8,9,10]; function randSort1(arr){ for(var i = 0,len = arr.length;i &lt; len; i++ ){ var rand = parseInt(Math.random()*len); var temp = arr[rand]; arr[rand] = arr[i]; arr[i] = temp; } return arr; } console.log(randSort1(arr)); ``` 方法二： ```javascript var arr = [1,2,3,4,5,6,7,8,9,10]; function randSort2(arr){ var mixedArray = []; while(arr.length &gt; 0){ var randomIndex = parseInt(Math.random()*arr.length); mixedArray.push(arr[randomIndex]); arr.splice(randomIndex, 1); } return mixedArray; } console.log(randSort2(arr)); ``` 方法三： ```javascript var arr = [1,2,3,4,5,6,7,8,9,10]; arr.sort(function(){ return Math.random() - 0.5; }) console.log(arr); ``` Javascript如何实现继承？ 1、构造继承 2、原型继承 3、实例继承 4、拷贝继承 原型prototype机制或apply和call方法去实现较简单，建议使用构造函数与原型混合方式。 ```javascript function Parent(){ this.name = &#39;wang&#39;; } function Child(){ this.age = 28; } Child.prototype = new Parent();//继承了Parent，通过原型 var demo = new Child(); alert(demo.age); alert(demo.name);//得到被继承的属性 ``` JavaScript继承的几种实现方式？ 参考：构造函数的继承，非构造函数的继承； javascript创建对象的几种方式？ javascript创建对象简单的说,无非就是使用内置对象或各种自定义对象，当然还可以用JSON；但写法有很多种，也能混合使用。 1、对象字面量的方式 person={firstname:&quot;Mark&quot;,lastname:&quot;Yun&quot;,age:25,eyecolor:&quot;black&quot;}; 2、用function来模拟无参的构造函数 function Person(){} var person=new Person();//定义一个function，如果使用new&quot;实例化&quot;,该function可以看作是一个Class person.name=&quot;Mark&quot;; person.age=&quot;25&quot;; person.work=function(){ alert(person.name+&quot; hello...&quot;); } person.work(); 3、用function来模拟参构造函数来实现（用this关键字定义构造的上下文属性） function Pet(name,age,hobby){ this.name=name;//this作用域：当前对象 this.age=age; this.hobby=hobby; this.eat=function(){ alert(&quot;我叫&quot;+this.name+&quot;,我喜欢&quot;+this.hobby+&quot;,是个程序员&quot;); } } var maidou =new Pet(&quot;麦兜&quot;,25,&quot;coding&quot;);//实例化、创建对象 maidou.eat();//调用eat方法 4、用工厂方式来创建（内置对象） var wcDog =new Object(); wcDog.name=&quot;旺财&quot;; wcDog.age=3; wcDog.work=function(){ alert(&quot;我是&quot;+wcDog.name+&quot;,汪汪汪......&quot;); } wcDog.work(); 5、用原型方式来创建 function Dog(){ } Dog.prototype.name=&quot;旺财&quot;; Dog.prototype.eat=function(){ alert(this.name+&quot;是个吃货&quot;); } var wangcai =new Dog(); wangcai.eat(); 5、用混合方式来创建 function Car(name,price){ this.name=name; this.price=price; } Car.prototype.sell=function(){ alert(&quot;我是&quot;+this.name+&quot;，我现在卖&quot;+this.price+&quot;万元&quot;); } var camry =new Car(&quot;凯美瑞&quot;,27); camry.sell(); Javascript作用链域? 全局函数无法查看局部函数的内部细节，但局部函数可以查看其上层的函数细节，直至全局细节。 当需要从局部函数查找某一属性或方法时，如果当前作用域没有找到，就会上溯到上层作用域查找， 直至全局函数，这种组织形式就是作用域链。 谈谈This对象的理解。 this总是指向函数的直接调用者（而非间接调用者）； 如果有new关键字，this指向new出来的那个对象； 在事件中，this指向触发这个事件的对象，特殊的是，IE中的attachEvent中的this总是指向全局对象Window； eval是做什么的？ 它的功能是把对应的字符串解析成JS代码并运行； 应该避免使用eval，不安全，非常耗性能（2次，一次解析成js语句，一次执行）。 由JSON字符串转换为JSON对象的时候可以用eval，var obj =eval(&#39;(&#39;+ str +&#39;)&#39;); 什么是window对象? 什么是document对象? window对象是指浏览器打开的窗口。 document对象是Documentd对象（HTML 文档对象）的一个只读引用，window对象的一个属性。 null，undefined 的区别？ null 表示一个对象是“没有值”的值，也就是值为“空”； undefined 表示一个变量声明了没有初始化(赋值)； undefined不是一个有效的JSON，而null是； undefined的类型(typeof)是undefined； null的类型(typeof)是object； Javascript将未赋值的变量默认值设为undefined； Javascript从来不会将变量设为null。它是用来让程序员表明某个用var声明的变量时没有值的。 typeof undefined //&quot;undefined&quot; undefined :是一个表示&quot;无&quot;的原始值或者说表示&quot;缺少值&quot;，就是此处应该有一个值，但是还没有定义。当尝试读取时会返回 undefined； 例如变量被声明了，但没有赋值时，就等于undefined typeof null //&quot;object&quot; null : 是一个对象(空对象, 没有任何属性和方法)； 例如作为函数的参数，表示该函数的参数不是对象； 注意： 在验证null时，一定要使用 === ，因为 == 无法分别 null 和 undefined null == undefined // true null === undefined // false 再来一个例子： null Q：有张三这个人么？ A：有！ Q：张三有房子么？ A：没有！ undefined Q：有张三这个人么？ A：有！ Q: 张三有多少岁？ A: 不知道（没有被告诉） 参考阅读：[undefined与null的区别](http://www.ruanyifeng.com/blog/2014/03/undefined-vs-null.html) 写一个通用的事件侦听器函数。 // event(事件)工具集，来源：github.com/markyun markyun.Event = { // 页面加载完成后 readyEvent : function(fn) { if (fn==null) { fn=document; } var oldonload = window.onload; if (typeof window.onload != &#39;function&#39;) { window.onload = fn; } else { window.onload = function() { oldonload(); fn(); }; } }, // 视能力分别使用dom0||dom2||IE方式 来绑定事件 // 参数： 操作的元素,事件名称 ,事件处理程序 addEvent : function(element, type, handler) { if (element.addEventListener) { //事件类型、需要执行的函数、是否捕捉 element.addEventListener(type, handler, false); } else if (element.attachEvent) { element.attachEvent(&#39;on&#39; + type, function() { handler.call(element); }); } else { element[&#39;on&#39; + type] = handler; } }, // 移除事件 removeEvent : function(element, type, handler) { if (element.removeEventListener) { element.removeEventListener(type, handler, false); } else if (element.datachEvent) { element.detachEvent(&#39;on&#39; + type, handler); } else { element[&#39;on&#39; + type] = null; } }, // 阻止事件 (主要是事件冒泡，因为IE不支持事件捕获) stopPropagation : function(ev) { if (ev.stopPropagation) { ev.stopPropagation(); } else { ev.cancelBubble = true; } }, // 取消事件的默认行为 preventDefault : function(event) { if (event.preventDefault) { event.preventDefault(); } else { event.returnValue = false; } }, // 获取事件目标 getTarget : function(event) { return event.target || event.srcElement; }, // 获取event对象的引用，取到事件的所有信息，确保随时能使用event； getEvent : function(e) { var ev = e || window.event; if (!ev) { var c = this.getEvent.caller; while (c) { ev = c.arguments[0]; if (ev &amp;&amp; Event == ev.constructor) { break; } c = c.caller; } } return ev; } }; [“1”, “2”, “3”].map(parseInt) 答案是多少？ parseInt() 函数能解析一个字符串，并返回一个整数，需要两个参数 (val, radix)， 其中 radix 表示要解析的数字的基数。【该值介于 2 ~ 36 之间，并且字符串中的数字不能大于radix才能正确返回数字结果值】; 但此处 map 传了 3 个 (element, index, array),我们重写parseInt函数测试一下是否符合上面的规则。 function parseInt(str, radix) { return str+&#39;-&#39;+radix; }; var a=[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;]; a.map(parseInt); // [&quot;1-0&quot;, &quot;2-1&quot;, &quot;3-2&quot;] 不能大于radix 因为二进制里面，没有数字3,导致出现超范围的radix赋值和不合法的进制解析，才会返回NaN 所以[&quot;1&quot;, &quot;2&quot;, &quot;3&quot;].map(parseInt) 答案也就是：[1, NaN, NaN] 详细解析：http://blog.csdn.net/justjavac/article/details/19473199 事件是？IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。 2. 事件处理机制：IE是事件冒泡、Firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件； 3. ev.stopPropagation();（旧ie的方法 ev.cancelBubble = true;） 什么是闭包（closure），为什么要用它？ 闭包是指有权访问另一个函数作用域中变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量,利用闭包可以突破作用链域，将函数内部的变量和方法传递到外部。 闭包的特性： 1.函数内再嵌套函数 2.内部函数可以引用外层的参数和变量 3.参数和变量不会被垃圾回收机制回收 //li节点的onclick事件都能正确的弹出当前被点击的li索引 &lt;ul id=&quot;testUL&quot;&gt; &lt;li&gt; index = 0&lt;/li&gt; &lt;li&gt; index = 1&lt;/li&gt; &lt;li&gt; index = 2&lt;/li&gt; &lt;li&gt; index = 3&lt;/li&gt; &lt;/ul&gt; &lt;script type=&quot;text/javascript&quot;&gt; var nodes = document.getElementsByTagName(&quot;li&quot;); for(i = 0;i&lt;nodes.length;i+= 1){ nodes[i].onclick = (function(i){ return function() { console.log(i); } //不用闭包的话，值每次都是4 })(i); } &lt;/script&gt; 执行say667()后,say667()闭包内部变量会存在,而闭包内部函数的内部变量不会存在 使得Javascript的垃圾回收机制GC不会收回say667()所占用的资源 因为say667()的内部函数的执行需要依赖say667()中的变量 这是对闭包作用的非常直白的描述 function say667() { // Local variable that ends up within closure var num = 666; var sayAlert = function() { alert(num); } num++; return sayAlert; } var sayAlert = say667(); sayAlert()//执行结果应该弹出的667 javascript 代码中的”use strict”;是什么意思 ? 使用它区别是什么？ use strict是一种ECMAscript 5 添加的（严格）运行模式,这种模式使得 Javascript 在更严格的条件下运行, 使JS编码更加规范化的模式,消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为。 默认支持的糟糕特性都会被禁用，比如不能用with，也不能在意外的情况下给全局变量赋值; 全局变量的显示声明,函数必须声明在顶层，不允许在非函数代码块内声明函数,arguments.callee也不允许使用； 消除代码运行的一些不安全之处，保证代码运行的安全,限制函数中的arguments修改，严格模式下的eval函数的行为和非严格模式的也不相同; 提高编译器效率，增加运行速度； 为未来新版本的Javascript标准化做铺垫。 如何判断一个对象是否属于某个类？ 使用instanceof （待完善） if(a instanceof Person){ alert(&#39;yes&#39;); } new操作符具体干了什么呢? 1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 2、属性和方法被加入到 this 引用的对象中。 3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。 var obj = {}; obj.__proto__ = Base.prototype; Base.call(obj); 用原生JavaScript的实现过什么功能吗？ Javascript中，有一个函数，执行时对象查找时，永远不会去查找原型，这个函数是？ hasOwnProperty javaScript中hasOwnProperty函数方法是返回一个布尔值，指出一个对象是否具有指定名称的属性。此方法无法检查该对象的原型链中是否具有该属性；该属性必须是对象本身的一个成员。 使用方法： object.hasOwnProperty(proName) 其中参数object是必选项。一个对象的实例。 proName是必选项。一个属性名称的字符串值。 如果 object 具有指定名称的属性，那么JavaScript中hasOwnProperty函数方法返回 true，反之则返回 false。 JSON 的了解？ JSON(JavaScript Object Notation) 是一种轻量级的数据交换格式。 它是基于JavaScript的一个子集。数据格式简单, 易于读写, 占用带宽小 如：{&quot;age&quot;:&quot;12&quot;, &quot;name&quot;:&quot;back&quot;} JSON字符串转换为JSON对象: var obj =eval(&#39;(&#39;+ str +&#39;)&#39;); var obj = str.parseJSON(); var obj = JSON.parse(str); JSON对象转换为JSON字符串： var last=obj.toJSONString(); var last=JSON.stringify(obj); [].forEach.call($$(&quot;*&quot;),function(a){a.style.outline=&quot;1px solid #&quot;+(~~(Math.random()*(1&lt;&lt;24))).toString(16)}) 能解释一下这段代码的意思吗？ js延迟加载的方式有哪些？ defer和async、动态创建DOM方式（用得最多）、按需异步载入js Ajax 是什么? 如何创建一个Ajax？ ajax的全称：Asynchronous Javascript And XML。 异步传输+js+xml。 所谓异步，在这里简单地解释就是：向服务器发送请求的时候，我们不必等待结果，而是可以同时做其他的事情，等到有了结果它自己会根据设定进行后续操作，与此同时，页面是不会发生整页刷新的，提高了用户体验。 (1)创建XMLHttpRequest对象,也就是创建一个异步调用对象 (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息 (3)设置响应HTTP请求状态变化的函数 (4)发送HTTP请求 (5)获取异步调用返回的数据 (6)使用JavaScript和DOM实现局部刷新 Ajax 解决浏览器缓存问题？ 1、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;If-Modified-Since&quot;,&quot;0&quot;)。 2、在ajax发送请求前加上 anyAjaxObj.setRequestHeader(&quot;Cache-Control&quot;,&quot;no-cache&quot;)。 3、在URL后面加上一个随机数： &quot;fresh=&quot; + Math.random();。 4、在URL后面加上时间搓：&quot;nowtime=&quot; + new Date().getTime();。 5、如果是使用jQuery，直接这样就可以了 $.ajaxSetup({cache:false})。这样页面的所有ajax都会执行这条语句就是不需要保存缓存记录。 同步和异步的区别? 同步的概念应该是来自于OS中关于同步的概念:不同进程为协同完成某项工作而在先后次序上调整(通过阻塞,唤醒等方式).同步强调的是顺序性.谁先谁后.异步则不存在这种顺序性. 同步：浏览器访问服务器请求，用户看得到页面刷新，重新发请求,等请求完，页面刷新，新内容出现，用户看到新内容,进行下一步操作。 异步：浏览器访问服务器请求，用户正常操作，浏览器后端进行请求。等请求完，页面不刷新，新内容也会出现，用户看到新内容。 （待完善） 如何解决跨域问题? jsonp、 iframe、window.name、window.postMessage、服务器上设置代理页面 页面编码和被请求的资源编码如果不一致如何处理？ 模块化开发怎么做？ 立即执行函数,不暴露私有成员 var module1 = (function(){ var _count = 0; var m1 = function(){ //... }; var m2 = function(){ //... }; return { m1 : m1, m2 : m2 }; })(); （待完善） AMD（Modules/Asynchronous-Definition）、CMD（Common Module Definition）规范区别？ AMD 规范在这里：https://github.com/amdjs/amdjs-api/wiki/AMD CMD 规范在这里：https://github.com/seajs/seajs/issues/242 Asynchronous Module Definition，异步模块定义，所有的模块将被异步加载，模块加载不影响后面语句运行。所有依赖某些模块的语句均放置在回调函数中。 区别： 1. 对于依赖的模块，AMD 是提前执行，CMD 是延迟执行。不过 RequireJS 从 2.0 开始，也改成可以延迟执行（根据写法不同，处理方式不同）。CMD 推崇 as lazy as possible. 2. CMD 推崇依赖就近，AMD 推崇依赖前置。看代码： // CMD define(function(require, exports, module) { var a = require(&#39;./a&#39;) a.doSomething() // 此处略去 100 行 var b = require(&#39;./b&#39;) // 依赖可以就近书写 b.doSomething() // ... }) // AMD 默认推荐 define([&#39;./a&#39;, &#39;./b&#39;], function(a, b) { // 依赖必须一开始就写好 a.doSomething() // 此处略去 100 行 b.doSomething() // ... }) requireJS的核心原理是什么？（如何动态加载的？如何避免多次加载的？如何缓存的？） 参考：http://annn.me/how-to-realize-cmd-loader/ JS模块加载器的轮子怎么造，也就是如何实现一个模块加载器？ 谈一谈你对ECMAScript6的了解？ ECMAScript6 怎么写class么，为什么会出现class这种东西? 异步加载JS的方式有哪些？ (1) defer，只支持IE (2) async： (3) 创建script，插入到DOM中，加载完毕后callBack documen.write和 innerHTML的区别 document.write只能重绘整个页面 innerHTML可以重绘页面的一部分 DOM操作——怎样添加、移除、移动、复制、创建和查找节点? （1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 （2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //在已有的子节点前插入一个新的子节点 （3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值(IE容错能力较强，会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 .call() 和 .apply() 的区别？ 例子中用 add 来替换 sub，add.call(sub,3,1) == add(3,1) ，所以运行结果为：alert(4); 注意：js 中的函数其实是对象，函数名是对 Function 对象的引用。 function add(a,b) { alert(a+b); } function sub(a,b) { alert(a-b); } add.call(sub,3,1); 数组和对象有哪些原生方法，列举一下？ JS 怎么实现一个类。怎么实例化这个类 JavaScript中的作用域与变量声明提升？ 如何编写高性能的Javascript？ 那些操作会造成内存泄漏？ JQuery的源码看过吗？能不能简单概况一下它的实现原理？ jQuery.fn的init方法返回的this指的是什么对象？为什么要返回this？ jquery中如何将数组转化为json字符串，然后再转化回来？ jQuery 的属性拷贝(extend)的实现原理是什么，如何实现深拷贝？ jquery.extend 与 jquery.fn.extend的区别？ * jquery.extend 为jquery类添加类方法，可以理解为添加静态方法 * jquery.fn.extend: 源码中jquery.fn = jquery.prototype，所以对jquery.fn的扩展，就是为jquery类添加成员函数 使用： jquery.extend扩展，需要通过jquery类来调用，而jquery.fn.extend扩展，所有jquery实例都可以直接调用。 jQuery 的队列是如何实现的？队列可以用在哪些地方？ 谈一下Jquery中的bind(),live(),delegate(),on()的区别？ JQuery一个对象可以同时绑定多个事件，这是如何实现的？ 是否知道自定义事件。jQuery里的fire函数是什么意思，什么时候用？ jQuery 是通过哪个方法和 Sizzle 选择器结合的？（jQuery.fn.find()进入Sizzle） 针对 jQuery性能的优化方法？ Jquery与jQuery UI 有啥区别？ *jQuery是一个js库，主要提供的功能是选择器，属性修改和事件绑定等等。 *jQuery UI则是在jQuery的基础上，利用jQuery的扩展性，设计的插件。 提供了一些常用的界面元素，诸如对话框、拖动行为、改变大小行为等等 JQuery的源码看过吗？能不能简单说一下它的实现原理？ jquery 中如何将数组转化为json字符串，然后再转化回来？ jQuery中没有提供这个功能，所以你需要先编写两个jQuery的扩展： $.fn.stringifyArray = function(array) { return JSON.stringify(array) } $.fn.parseArray = function(array) { return JSON.parse(array) } 然后调用： $(&quot;&quot;).stringifyArray(array) jQuery和Zepto的区别？各自的使用场景？ 针对 jQuery 的优化方法？ *基于Class的选择性的性能相对于Id选择器开销很大，因为需遍历所有DOM元素。 *频繁操作的DOM，先缓存起来再操作。用Jquery的链式调用更好。 比如：var str=$(&quot;a&quot;).attr(&quot;href&quot;); *for (var i = size; i &lt; arr.length; i++) {} for 循环每一次循环都查找了数组 (arr) 的.length 属性，在开始循环的时候设置一个变量来存储这个数字，可以让循环跑得更快： for (var i = size, length = arr.length; i &lt; length; i++) {} Zepto的点透问题如何解决？ jQueryUI如何自定义组件? 需求：实现一个页面操作不会整页刷新的网站，并且能在浏览器前进、后退时正确响应。给出你的技术实现方案？ 如何判断当前脚本运行在浏览器还是node环境中？（阿里） this === window ? &#39;browser&#39; : &#39;node&#39;; 通过判断Global对象是否为window，如果不为window，当前脚本没有运行在浏览器中 移动端最小触控区域是多大？ jQuery 的 slideUp动画 ，如果目标元素是被外部事件驱动, 当鼠标快速地连续触发外部元素事件, 动画会滞后的反复执行，该如何处理呢? jquery stop(): 如：$(&quot;#div&quot;).stop().animate({width:&quot;100px&quot;},100); 把 Script 标签 放在页面的最底部的body封闭之前 和封闭之后有什么区别？浏览器会如何解析它们？ 移动端的点击事件的有延迟，时间是多久，为什么会有？ 怎么解决这个延时？（click 有 300ms 延迟,为了实现safari的双击事件的设计，浏览器要知道你是不是要双击操作。） 知道各种JS框架(Angular, Backbone, Ember, React, Meteor, Knockout…)么? 能讲出他们各自的优点和缺点么? Underscore 对哪些 JS 原生对象进行了扩展以及提供了哪些好用的函数方法？ 解释JavaScript中的作用域与变量声明提升？ 那些操作会造成内存泄漏？ 内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） JQuery一个对象可以同时绑定多个事件，这是如何实现的？ * 多个事件同一个函数： $(&quot;div&quot;).on(&quot;click mouseover&quot;, function(){}); * 多个事件不同函数 $(&quot;div&quot;).on({ click: function(){}, mouseover: function(){} }); Node.js的适用场景？ (如果会用node)知道route, middleware, cluster, nodemon, pm2, server-side rendering么? 解释一下 Backbone 的 MVC 实现方式？ 什么是“前端路由”?什么时候适合使用“前端路由”? “前端路由”有哪些优点和缺点? 知道什么是webkit么? 知道怎么用浏览器的各种工具来调试和debug代码么? Chrome,Safari浏览器内核。 如何测试前端代码么? 知道BDD, TDD, Unit Test么? 知道怎么测试你的前端工程么(mocha, sinon, jasmin, qUnit..)? 前端templating(Mustache, underscore, handlebars)是干嘛的, 怎么用? 简述一下 Handlebars 的基本用法？ 简述一下 Handlerbars 的对模板的基本处理流程， 如何编译的？如何缓存的？ 用js实现千位分隔符?(来源：前端农民工，提示：正则+replace) 参考：http://www.tuicool.com/articles/ArQZfui function commafy(num) { return num &amp;&amp; num .toString() .replace(/(\\d)(?=(\\d{3})+\\.)/g, function($0, $1) { return $1 + &quot;,&quot;; }); } console.log(commafy(1234567.90)); //1,234,567.90 检测浏览器版本版本有哪些方式？ 功能检测、userAgent特征检测 比如：navigator.userAgent //&quot;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/41.0.2272.101 Safari/537.36&quot; What is a Polyfill? polyfill 是“在旧版浏览器上复制标准 API 的 JavaScript 补充”,可以动态地加载 JavaScript 代码或库，在不支持这些标准 API 的浏览器中模拟它们。 例如，geolocation（地理位置）polyfill 可以在 navigator 对象上添加全局的 geolocation 对象，还能添加 getCurrentPosition 函数以及“坐标”回调对象， 所有这些都是 W3C 地理位置 API 定义的对象和函数。因为 polyfill 模拟标准 API，所以能够以一种面向所有浏览器未来的方式针对这些 API 进行开发， 一旦对这些 API 的支持变成绝对大多数，则可以方便地去掉 polyfill，无需做任何额外工作。 做的项目中，有没有用过或自己实现一些 polyfill 方案（兼容性处理方案）？ 比如： html5shiv、Geolocation、Placeholder 我们给一个dom同时绑定两个点击事件，一个用捕获，一个用冒泡。会执行几次事件，会先执行冒泡还是捕获？ 使用JS实现获取文件扩展名？ function getFileExtension(filename) { return filename.slice((filename.lastIndexOf(&quot;.&quot;) - 1 &gt;&gt;&gt; 0) + 2); } String.lastIndexOf() 方法返回指定值（本例中的&#39;.&#39;）在调用该方法的字符串中最后出现的位置，如果没找到则返回 -1。 对于&#39;filename&#39;和&#39;.hiddenfile&#39;，lastIndexOf的返回值分别为0和-1无符号右移操作符(»&gt;) 将-1转换为4294967295，将-2转换为4294967294，这个方法可以保证边缘情况时文件名不变。 String.prototype.slice() 从上面计算的索引处提取文件的扩展名。如果索引比文件名的长度大，结果为&quot;&quot;。 ECMAScript6 相关 Object.is() 与原来的比较操作符“ ===”、“ ==”的区别？ 两等号判等，会在比较时进行类型转换； 三等号判等(判断严格)，比较时不进行隐式类型转换,（类型不同则会返回false）； Object.is 在三等号判等的基础上特别处理了 NaN 、-0 和 +0 ，保证 -0 和 +0 不再相同， 但 Object.is(NaN, NaN) 会返回 true. Object.is 应被认为有其特殊的用途，而不能用它认为它比其它的相等对比更宽松或严格。 前端框架相关 react-router 路由系统的实现原理？ React中如何解决第三方类库的问题? 其他问题 原来公司工作流程是怎么样的，如何与其他人协作的？如何夸部门合作的？ 你遇到过比较难的技术问题是？你是如何解决的？ 设计模式 知道什么是singleton, factory, strategy, decrator么? 常使用的库有哪些？常用的前端开发工具？开发过什么应用或组件？ 页面重构怎么操作？ 网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。 也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面 减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决) 程序的性能优化(如数据读写) 采用CDN来加速资源加载 对于JS DOM的优化 HTTP服务器的文件缓存 列举IE与其他浏览器不一样的特性？ 1、事件不同之处： 触发事件的元素被认为是目标（target）。而在 IE 中，目标包含在 event 对象的 srcElement 属性； 获取字符代码、如果按键代表一个字符（shift、ctrl、alt除外），IE 的 keyCode 会返回字符代码（Unicode），DOM 中按键的代码和字符是分离的，要获取字符代码，需要使用 charCode 属性； 阻止某个事件的默认行为，IE 中阻止某个事件的默认行为，必须将 returnValue 属性设置为 false，Mozilla 中，需要调用 preventDefault() 方法； 停止事件冒泡，IE 中阻止事件进一步冒泡，需要设置 cancelBubble 为 true，Mozzilla 中，需要调用 stopPropagation()； 99%的网站都需要被重构是那本书上写的？ 网站重构：应用web标准进行设计（第2版） 什么叫优雅降级和渐进增强？ 优雅降级：Web站点在所有新式浏览器中都能正常工作，如果用户使用的是老式浏览器，则代码会针对旧版本的IE进行降级处理了,使之在旧式浏览器上以某种形式降级体验却不至于完全不能用。 如：border-shadow 渐进增强：从被所有浏览器支持的基本功能开始，逐步地添加那些只有新版本浏览器才支持的功能,向页面增加不影响基础浏览器的额外样式和功能的。当浏览器支持时，它们会自动地呈现出来并发挥作用。 如：默认使用flash上传，但如果浏览器支持 HTML5 的文件上传功能，则使用HTML5实现更好的体验； 是否了解公钥加密和私钥加密。 一般情况下是指私钥用于对数据进行签名，公钥用于对签名进行验证; HTTP网站在浏览器端用公钥加密敏感数据，然后在服务器端再用私钥解密。 WEB应用从服务器主动推送Data到客户端有那些方式？ html5提供的Websocket 不可见的iframe WebSocket通过Flash XHR长时间连接 XHR Multipart Streaming &lt;script&gt;标签的长时间连接(可跨域) 对Node的优点和缺点提出了自己的看法？ *（优点）因为Node是基于事件驱动和无阻塞的，所以非常适合处理并发请求， 因此构建在Node上的代理服务器相比其他技术实现（如Ruby）的服务器表现要好得多。 此外，与Node代理服务器交互的客户端代码是由javascript语言编写的， 因此客户端和服务器端都用同一种语言编写，这是非常美妙的事情。 *（缺点）Node是一个相对新的开源项目，所以不太稳定，它总是一直在变， 而且缺少足够多的第三方库支持。看起来，就像是Ruby/Rails当年的样子。 你有用过哪些前端性能优化的方法？ （1） 减少http请求次数：CSS Sprites, JS、CSS源码压缩、图片大小控制合适；网页Gzip，CDN托管，data缓存 ，图片服务器。 （2） 前端模板 JS+数据，减少由于HTML标签导致的带宽浪费，前端用变量保存AJAX请求结果，每次操作本地变量，不用请求，减少请求次数 （3） 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能。 （4） 当需要设置的样式很多时设置className而不是直接操作style。 （5） 少用全局变量、缓存DOM节点查找的结果。减少IO读取操作。 （6） 避免使用CSS Expression（css表达式)又称Dynamic properties(动态属性)。 （7） 图片预加载，将样式表放在顶部，将脚本放在底部 加上时间戳。 （8） 避免在页面的主体布局中使用table，table要等其中的内容完全下载之后才会显示出来，显示比div+css布局慢。 对普通的网站有一个统一的思路，就是尽量向前端优化、减少数据库操作、减少磁盘IO。向前端优化指的是，在不影响功能和体验的情况下，能在浏览器执行的不要在服务端执行，能在缓存服务器上直接返回的不要到应用服务器，程序能直接取得的结果不要到外部取得，本机内能取得的数据不要到远程取，内存能取到的不要到磁盘取，缓存中有的不要去数据库查询。减少数据库操作指减少更新次数、缓存结果减少查询次数、将数据库执行的操作尽可能的让你的程序完成（例如join查询），减少磁盘IO指尽量不使用文件系统作为缓存、减少读写文件次数等。程序优化永远要优化慢的部分，换语言是无法“优化”的。 http状态码有那些？分别代表是什么意思？ 简单版 [ 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 ] 完整版 1**(信息类)：表示接收到请求并且继续处理 100——客户必须继续发出请求 101——客户要求服务器根据请求转换HTTP协议版本 2**(响应成功)：表示动作被成功接收、理解和接受 200——表明该请求被成功地完成，所请求的资源发送回客户端 201——提示知道新文件的URL 202——接受和处理、但处理未完成 203——返回信息不确定或不完整 204——请求收到，但返回信息为空 205——服务器完成了请求，用户代理必须复位当前已经浏览过的文件 206——服务器已经完成了部分用户的GET请求 3**(重定向类)：为了完成指定的动作，必须接受进一步处理 300——请求的资源可在多处得到 301——本网页被永久性转移到另一个URL 302——请求的网页被转移到一个新的地址，但客户访问仍继续通过原始URL地址，重定向，新的URL会在response中的Location中返回，浏览器将会使用新的URL发出新的Request。 303——建议客户访问其他URL或访问方式 304——自从上次请求后，请求的网页未修改过，服务器返回此响应时，不会返回网页内容，代表上次的文档已经被缓存了，还可以继续使用 305——请求的资源必须从服务器指定的地址得到 306——前一版本HTTP中使用的代码，现行版本中不再使用 307——申明请求的资源临时性删除 4**(客户端错误类)：请求包含错误语法或不能正确执行 400——客户端请求有语法错误，不能被服务器所理解 401——请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 HTTP 401.1 - 未授权：登录失败 HTTP 401.2 - 未授权：服务器配置问题导致登录失败 HTTP 401.3 - ACL 禁止访问资源 HTTP 401.4 - 未授权：授权被筛选器拒绝 HTTP 401.5 - 未授权：ISAPI 或 CGI 授权失败 402——保留有效ChargeTo头响应 403——禁止访问，服务器收到请求，但是拒绝提供服务 HTTP 403.1 禁止访问：禁止可执行访问 HTTP 403.2 - 禁止访问：禁止读访问 HTTP 403.3 - 禁止访问：禁止写访问 HTTP 403.4 - 禁止访问：要求 SSL HTTP 403.5 - 禁止访问：要求 SSL 128 HTTP 403.6 - 禁止访问：IP 地址被拒绝 HTTP 403.7 - 禁止访问：要求客户证书 HTTP 403.8 - 禁止访问：禁止站点访问 HTTP 403.9 - 禁止访问：连接的用户过多 HTTP 403.10 - 禁止访问：配置无效 HTTP 403.11 - 禁止访问：密码更改 HTTP 403.12 - 禁止访问：映射器拒绝访问 HTTP 403.13 - 禁止访问：客户证书已被吊销 HTTP 403.15 - 禁止访问：客户访问许可过多 HTTP 403.16 - 禁止访问：客户证书不可信或者无效 HTTP 403.17 - 禁止访问：客户证书已经到期或者尚未生效 404——一个404错误表明可连接服务器，但服务器无法取得所请求的网页，请求资源不存在。eg：输入了错误的URL 405——用户在Request-Line字段定义的方法不允许 406——根据用户发送的Accept拖，请求资源不可访问 407——类似401，用户必须首先在代理服务器上得到授权 408——客户端没有在用户指定的饿时间内完成请求 409——对当前资源状态，请求不能完成 410——服务器上不再有此资源且无进一步的参考地址 411——服务器拒绝用户定义的Content-Length属性请求 412——一个或多个请求头字段在当前请求中错误 413——请求的资源大于服务器允许的大小 414——请求的资源URL长于服务器允许的长度 415——请求资源不支持请求项目格式 416——请求中包含Range请求头字段，在当前请求资源范围内没有range指示值，请求也不包含If-Range请求头字段 417——服务器不满足请求Expect头字段指定的期望值，如果是代理服务器，可能是下一级服务器不能满足请求长。 5**(服务端错误类)：服务器不能正确执行一个正确的请求 HTTP 500 - 服务器遇到错误，无法完成请求 HTTP 500.100 - 内部服务器错误 - ASP 错误 HTTP 500-11 服务器关闭 HTTP 500-12 应用程序重新启动 HTTP 500-13 - 服务器太忙 HTTP 500-14 - 应用程序无效 HTTP 500-15 - 不允许请求 global.asa Error 501 - 未实现 HTTP 502 - 网关错误 HTTP 503：由于超载或停机维护，服务器目前无法使用，一段时间后可能恢复正常 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？（流程说的越详细越好） 注：这题胜在区分度高，知识点覆盖广，再不懂的人，也能答出几句， 而高手可以根据自己擅长的领域自由发挥，从URL规范、HTTP协议、DNS、CDN、数据库查询、 到浏览器流式解析、CSS规则构建、layout、paint、onload/domready、JS执行、JS API绑定等等； 详细版： 1、浏览器会开启一个线程来处理这个请求，对 URL 分析判断如果是 http 协议就按照 Web 方式来处理; 2、调用浏览器内核中的对应方法，比如 WebView 中的 loadUrl 方法; 3、通过DNS解析获取网址的IP地址，设置 UA 等信息发出第二个GET请求; 4、进行HTTP协议会话，客户端发送报头(请求报头); 5、进入到web服务器上的 Web Server，如 Apache、Tomcat、Node.JS 等服务器; 6、进入部署好的后端应用，如 PHP、Java、JavaScript、Python 等，找到对应的请求处理; 7、处理结束回馈报头，此处如果浏览器访问过，缓存上有对应资源，会与服务器最后修改时间对比，一致则返回304; 8、浏览器开始下载html文档(响应报头，状态码200)，同时使用缓存; 9、文档树建立，根据标记请求所需指定MIME类型的文件（比如css、js）,同时设置了cookie; 10、页面开始渲染DOM，JS根据DOM API操作DOM,执行事件绑定等，页面显示完成。 简洁版： 浏览器根据请求的URL交给DNS域名解析，找到真实IP，向服务器发起请求； 服务器交给后台处理完成后返回数据，浏览器接收文件（HTML、JS、CSS、图象等）； 浏览器对加载到的资源（HTML、JS、CSS等）进行语法解析，建立相应的内部数据结构（如HTML的DOM）； 载入解析到的资源文件，渲染页面，完成。 部分地区用户反应网站很卡，请问有哪些可能性的原因，以及解决方法？ 从打开app到刷新出内容，整个过程中都发生了什么，如果感觉慢，怎么定位问题，怎么解决? 除了前端以外还了解什么其它技术么？你最最厉害的技能是什么？ 你用的得心应手用的熟练地编辑器&amp;开发环境是什么样子？ Sublime Text 3 + 相关插件编写前端代码 Google chrome 、Mozilla Firefox浏览器 +firebug 兼容测试和预览页面UI、动画效果和交互功能 Node.js+Gulp git 用于版本控制和Code Review 对前端工程师这个职位是怎么样理解的？它的前景会怎么样？ 前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。 1、实现界面交互 2、提升用户体验 3、有了Node.js，前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好， 参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 处理hack，兼容、写出优美的代码格式； 针对服务器的优化、拥抱最新前端技术。 你怎么看待Web App 、hybrid App、Native App？ 你移动端前端开发的理解？（和 Web 前端开发的主要区别是什么？） 你对加班的看法？ 加班就像借钱，原则应当是------救急不救穷 平时如何管理你的项目？ 先期团队必须确定好全局样式（globe.css），编码模式(utf-8) 等； 编写习惯必须一致（例如都是采用继承式的写法，单样式都写成一行）； 标注样式编写人，各模块都及时标注（标注关键样式调用的地方）； 页面进行标注（例如 页面 模块 开始和结束）； CSS跟HTML 分文件夹并行存放，命名都得统一（例如style.css）； JS 分文件夹存放 命名以该JS功能为准的英文翻译。 图片采用整合的 images.png png8 格式文件使用 尽量整合在一起使用方便将来的管理 如何设计突发大规模并发架构？ 当团队人手不足，把功能代码写完已经需要加班的情况下，你会做前端代码的测试吗？ 说说最近最流行的一些东西吧？常去哪些网站？ ES6\\WebAssembly\\Node\\MVVM\\Web Components\\React\\React Native\\Webpack 组件化 知道什么是SEO并且怎么优化么? 知道各种meta data的含义么? 移动端（Android IOS）怎么做好用户体验? 清晰的视觉纵线、 信息的分组、极致的减法、 利用选择代替输入、 标签及文字的排布方式、 依靠明文确认密码、 合理的键盘利用、 简单描述一下你做过的移动APP项目研发流程？ 你在现在的团队处于什么样的角色，起到了什么明显的作用？ 你认为怎样才是全端工程师（Full Stack developer）？ 介绍一个你最得意的作品吧？ 你有自己的技术博客吗，用了哪些技术？ 对前端安全有什么看法？ 是否了解Web注入攻击，说下原理，最常见的两种攻击（XSS 和 CSRF）了解到什么程度？ 项目中遇到国哪些印象深刻的技术难题，具体是什么问题，怎么解决？。 最近在学什么东西？ 你的优点是什么？缺点是什么？ 如何管理前端团队? 最近在学什么？能谈谈你未来3，5年给自己的规划吗？ 前端学习网站推荐1. 极客标签： http://www.gbtags.com/ 2. 码农周刊： http://weekly.manong.io/issues/ 3. 前端周刊： http://www.feweekly.com/issues 4. 慕课网： http://www.imooc.com/ 5. div.io： http://div.io 6. Hacker News： https://news.ycombinator.com/news 7. InfoQ： http://www.infoq.com/ 8. w3cplus： http://www.w3cplus.com/ 9. Stack Overflow： http://stackoverflow.com/ 10.w3school： http://www.w3school.com.cn/ 11.mozilla： https://developer.mozilla.org/zh-CN/docs/Web/JavaScript 文档推荐 jQuery 基本原理 JavaScript 秘密花园 CSS参考手册 JavaScript 标准参考教程 ECMAScript 6入门 备注： 根据自己需要选择性阅读，面试题是对理论知识的总结，让自己学会应该如何表达。 资料答案不够正确和全面，欢迎欢迎Star和提交issues。 格式不断修改更新中。 在 github 项目的右上角，有三个按钮,分别是 watch、star、fork，新来的同学注意不要用错了，无休止的邮件提醒会给你造成不必要的信息干扰。 当你选择Watching，表示你以后会关注这个项目的全部动态，以后只要这个项目发生变动，被别人提交了pull request、被发起了issue等情况你都会收到邮件通知。 star相当于是点赞或收藏，方便以后查找。 fork表示你想要补充完善这个项目的内容。","tags":[{"name":"前端","slug":"前端","permalink":"https://microzz.com/tags/前端/"},{"name":"面试","slug":"面试","permalink":"https://microzz.com/tags/面试/"},{"name":"求职","slug":"求职","permalink":"https://microzz.com/tags/求职/"}]},{"title":"前端面试题(部分)","date":"2017-02-08T14:52:44.000Z","path":"2017/02/08/web-interview/","text":"原型： 我们创建的每一个函数，都可以有一个prototype属性，该属性指向一个对象。这个对象，就是原型。 当我们在创建对象时，可以根据自己的需求，选择性的将一些属性和方法通过prototype属性，挂载在原型对象上。而每一个new出来的实例，都有一个proto属性，该属性指向构造函数的原型对象，通过这个属性，让实例对象也能够访问原型对象上的方法。因此，当所有的实例都能够通过proto访问到原型对象时，原型对象的方法与属性就变成了共有方法与属性。 // 声明构造函数 function Person(name, age) { this.name = name; this.age = age; } // 通过prototye属性，将方法挂载到原型对象上 Person.prototype.getName = function() { return this.name; } var p1 = new Person(&#39;tim&#39;, 10); var p2 = new Person(&#39;jak&#39;, 22); console.log(p1.getName === p2.getName); // true 通过图示我们可以看出，构造函数的prototype与所有实例对象的proto都指向原型对象。而原型对象的constructor指向构造函数。 原型链： 我们知道所有的函数都有一个叫做toString的方法。那么这个方法到底是在哪里的呢？ 先随意声明一个函数： function foo() {} 其中foo是Function对象的实例。而Function的原型对象同时又是Object的实例。这样就构成了一条原型链。原型链的访问，其实跟作用域链有很大的相似之处，他们都是一次单向的查找过程。因此实例对象能够通过原型链，访问到处于原型链上对象的所有属性与方法。这也是foo最终能够访问到处于Object原型对象上的toString方法的原因。 闭包： 闭包 是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量另一种理解：当函数可以记住并访问所在的词法作用域时，就产生了闭包，这个函数持有对该词法作用域的引用，这个引用就叫做闭包 闭包本质还是函数，只不过这个函数绑定了上下文环境（函数内部引用的所有变量） JavaScript的作用域就是词法作用域而不是动态作用域,词法作用域最重要的特征是它的定义过程发生在代码的书写阶段动态作用域的作用域链是基于调用栈的 词法作用域的作用域链是基于代码中的作用域嵌套 闭包的缺点就是常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。 闭包可以用来管理私有变量和私有方法，将对变量（状态）的变化封装在安全的环境中，使得这些变量不能被外部随意修改，同时又可以通过指定的函数接口来操作。 闭包有三个特性：1.函数嵌套函数2.函数内部可以引用外部的参数和变量3.参数和变量不会被垃圾回收机制回收 经典栗子：在一个 ul li 列表，我想点击某个 li 然后返回对应的索引。通常的做法是 写一个 for 循环 然后给每个 li 绑定点击事件，这样就形成了一个闭包。 &lt;!DOCTYPE html&gt; &lt;html lang=&quot;en&quot;&gt; &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;闭包&lt;/title&gt; &lt;script&gt; window.onload = function(){ var aLi = document.getElementsByTagName(&#39;li&#39;); for (var i=0;i&lt;aLi.length;i++){ aLi[i].onclick = function(){ //当点击时for循环已经结束 alert(i); }; } } &lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;ul&gt; &lt;li&gt;0&lt;/li&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt; &lt;/html&gt; 我的理解是这样的：当我们给每个 li 绑定点击事件的时候，因为是事件监听，也可以说是事件驱动模式，处理事件监听的逻辑是异步执行的，当我们点击一个 li 的时候，for 循环已经结束，此时的下标索引为 li 的 length大小，所以点击任何一个 li 查找索引的时候都是查找到全局作用域，都是返回 length 大小。 解决办法：给每个 li 绑定点击事件的时候创建一个块级作用域，这样，当处理事件监听的逻辑的时候向上查找就不会查找到全局作用域。 1、定义一个立即执行函数 var aLi = document.getElementsByTagName(&#39;li&#39;); for (var i=0;i&lt;aLi.length;i++){ (function(i){ aLi[i].onclick = function(){ alert(i); }; })(i); } 2、用es6中的let替换var var aLi = document.getElementsByTagName(&#39;li&#39;); for (let i=0;i&lt;aLi.length;i++){ aLi[i].onclick = function(){ alert(i); }; } 对象： JS中的对象，可以看作是一组数据和功能的集合，带有各种属性和方法的一种数据类型。 JS中对象分为两种：1、JS的内建对象，如：String，Date，Array等等(Function、Math、Number) 2、我们自己创建的对象： 1）对象字面量 2）构造函数 调用构造函数 new 4个步骤：1、创建一个新对象2、将构造函数的作用域赋给新对象（因此this就指向了这个新对象）3、执行构造函数中的代码（为这个新对象添加属性）4、返回新对象 继承 js中的继承主要依靠原型链来实现的，通过原型链的方式实现了父类子类之间共享属性的继承以及身份确认机制。 构造函数方式实现继承在子类的构造函数内部通过 父类名.call 或 apply 来调用父类的构造函数(apply的第二个参数是一个参数数组，call的参数要全部列举出来，bind不会立即调用，其他两个会立即调用)方法都在构造函数中定义，因此函数无法复用。 组合继承使用原型链实现对原型属性和方法的继承，通过构造函数实现对实例属性的继承Sub.prototype = new Sup()子类原型覆盖掉了父类原型的某些属性（父类原型中的依然还在） 寄生组合继承es5中主流的继承方式Sub.prototype=Object.create(Sup.prototype)Sub.prototype.constructor=SubObject.create(obj)方法，该方法会对传入的obj对象进行浅拷贝。和上面组合继承的主要区别就是：将父类的原型复制给了子类原型。构造函数中继承父类属性／方法，并初始化父类。子类原型和父类原型建立联系。 es6的继承方式es6引入了class、extends、super、static(部分为ES2016标准) class A { } class B extends A { } B.__proto__ === A // true B.prototype.__proto__ === A.prototype // true 算法：数组去重：建一个空对象和空数组，循环遍历需要去重的数组，判断对象有没有此属性，没有的话就给对象添加此属性，并向空数组中push这个值。//es5 function unique(arr){ var obj = {} var result = [] for(var i in arr){ if(!obj[arr[i]]){ obj[arr[i]] = true; result.push(arr[i]); } } return result; } //es6 [...new Set(arr)] 冒泡排序：相邻两个对比，最后把最大的排到了最后，重复此过程。function bubbleSort(arr) { var len = arr.length; for (var i = 0; i &lt; len; i++) { for (var j = 0; j &lt; len - 1 - i; j++) { if (arr[j] &gt; arr[j+1]) { //相邻元素两两对比 var temp = arr[j+1]; //元素交换 arr[j+1] = arr[j]; arr[j] = temp; } } } return arr; } 选择排序：寻找最小的数，保存索引，然后与第一层循环其下标对于的值进行交换function selectionSort(arr) { var len = arr.length; var minIndex, temp; for (var i = 0; i &lt; len - 1; i++) { minIndex = i; for (var j = i + 1; j &lt; len; j++) { if (arr[j] &lt; arr[minIndex]) { //寻找最小的数 minIndex = j; //将最小数的索引保存 } } temp = arr[i]; arr[i] = arr[minIndex]; arr[minIndex] = temp; } return arr; } 快速排序：选取一个记录作为中间轴，然后将比‘这个记录值’小的移到‘记录值’之前，大的移到之后，然后递归function quickSort(arr) { if(arr.length == 0) { return []; // 返回空数组 } var cIndex = Math.floor(arr.length / 2); var c = arr.splice(cIndex, 1); var l = []; var r = []; for (var i = 0; i &lt; arr.length; i++) { if(arr[i] &lt; c) { l.push(arr[i]); } else { r.push(arr[i]); } } return quickSort(l).concat(c, quickSort(r)); } 性能优化 网页内容 减少 http请求次数 减少 DNS查询次数 避免页面跳转 缓存 Ajax 延迟加载 提前加载 减少 DOM元素数量 避免 404 服务器 使用CDN(内容分发网络) 添加Expires或Cache-Control报文头 Gzip压缩传输文件 CSS 将样式表置顶 用代替@import JavaScript 把脚本置于页面底部 使用外部JavaScript和CSS 精简JavaScript和CSS 去除重复脚本 减少DOM访问 图片 优化图像 优化CSS Spirite 不要在HTML中缩放图片 favicon.ico要小而且可缓存 问面试官 目前关注哪些最新的Web前端技术（未来的发展方向）？ 团队如何工作的（实现一个产品的流程）？ 公司的薪资结构是什么样子的？（摸清自己具体在什么层次） 公司的晋升机制具体是怎么样的？（看出你的上进心的稳定性） Event Loop、消息队列、事件轮询异步函数在执行结束后，会在事件队列中添加一个事件（回调函数）(遵循先进先出原则)，主线程中的代码执行完毕后（即一次循环结束），下一次循环开始就在事件队列中“读取”事件，然后调用它所对应的回调函数。这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环） 主线程运行的时候，产生堆（heap）和栈（stack），栈中的代码（同步任务）调用各种外部API，它们在”任务队列”中加入各种事件（click，load，done）。只要栈中的代码执行完毕，主线程就会去读取”任务队列”，依次执行那些事件所对应的回调函数。 执行栈中的代码（同步任务），总是在读取”任务队列”（异步任务）之前执行。 token、session token就是令牌,比如你授权(登录)一个程序时,他就是个依据,判断你是否已经授权该软件;cookie就是写在客户端的一个txt文件,里面包括你登录信息之类的 基于Token的身份验证的过程如下: 1.用户通过用户名和密码发送请求。 2.服务端验证。 3.服务端返回一个签名的token 给客户端。 4.客户端储存token,并且每次用于发送请求。 5.服务端验证token并返回数据。 每一次请求都需要token。 session是指一类用来在客户端与服务器之间保持状态的解决方案,也可以用来保存少量数据，但会随着会话结束而销毁。 缓存 Expires、Cache-Control、Last-Modified、 ETag 浏览器缓存（Browser Caching）是浏览器端保存数据用于快速读取或避免重复资源请求的优化机制，有效的缓存使用可以避免重复的网络请求和浏览器快速地读取本地数据， http缓存 http缓存是基于HTTP协议的浏览器文件级缓存机制。即针对文件的重复请求情况下，浏览器可以根据协议头判断从服务器端请求文件还是从本地读取文件判断expires，如果未过期，直接读取http缓存文件 indexDB 是一个在客户端存储可观数量的结构化数据,并且为这些数据添加索引进行高性能检索。 cookie 指一般网站为了辨别用户身份、储存在用户本地终端上的数据（通常经过加密）。cookie一般通过http请求中在头部一起发送到服务器端。一条cookie记录主要由键、值、域、过期时间、大小组成，一般用户保存用户的认证信息。 localstorage localStorage是h5的一种新的本地缓存方案,加快下次页面打开时的渲染速度,除非主动删除数据，否则数据是永远不会过期的。 sessionstorage 也是h5的一种本地缓存方案，数据的存储仅特定于某个会话中，也就是说数据只保持到浏览器关闭，当浏览器关闭后重新打开这个页面时， 之前的存储已经被清除。","tags":[{"name":"Web","slug":"Web","permalink":"https://microzz.com/tags/Web/"},{"name":"面试题","slug":"面试题","permalink":"https://microzz.com/tags/面试题/"}]},{"title":"ES6编程风格","date":"2017-02-06T10:00:23.000Z","path":"2017/02/06/es6-style/","text":"编程风格本章探讨如何将ES6的新语法，运用到编码实践之中，与传统的JavaScript语法结合在一起，写出合理的、易于阅读和维护的代码。 多家公司和组织已经公开了它们的风格规范，具体可参阅jscs.info，下面的内容主要参考了Airbnb的JavaScript风格规范。 块级作用域（1）let 取代 var ES6提出了两个新的声明变量的命令：let和const。其中，let完全可以取代var，因为两者语义相同，而且let没有副作用。 &#39;use strict&#39;; if (true) { let x = &#39;hello&#39;; } for (let i = 0; i &lt; 10; i++) { console.log(i); } 上面代码如果用var替代let，实际上就声明了两个全局变量，这显然不是本意。变量应该只在其声明的代码块内有效，var命令做不到这一点。 var命令存在变量提升效用，let命令没有这个问题。 &#39;use strict&#39;; if(true) { console.log(x); // ReferenceError let x = &#39;hello&#39;; } 上面代码如果使用var替代let，console.log那一行就不会报错，而是会输出undefined，因为变量声明提升到代码块的头部。这违反了变量先声明后使用的原则。 所以，建议不再使用var命令，而是使用let命令取代。 （2）全局常量和线程安全 在let和const之间，建议优先使用const，尤其是在全局环境，不应该设置变量，只应设置常量。 const优于let有几个原因。一个是const可以提醒阅读程序的人，这个变量不应该改变；另一个是const比较符合函数式编程思想，运算不改变值，只是新建值，而且这样也有利于将来的分布式运算；最后一个原因是 JavaScript 编译器会对const进行优化，所以多使用const，有利于提供程序的运行效率，也就是说let和const的本质区别，其实是编译器内部的处理不同。 // bad var a = 1, b = 2, c = 3; // good const a = 1; const b = 2; const c = 3; // best const [a, b, c] = [1, 2, 3]; const声明常量还有两个好处，一是阅读代码的人立刻会意识到不应该修改这个值，二是防止了无意间修改变量值所导致的错误。 所有的函数都应该设置为常量。 长远来看，JavaScript可能会有多线程的实现（比如Intel的River Trail那一类的项目），这时let表示的变量，只应出现在单线程运行的代码中，不能是多线程共享的，这样有利于保证线程安全。 字符串静态字符串一律使用单引号或反引号，不使用双引号。动态字符串使用反引号。 // bad const a = &quot;foobar&quot;; const b = &#39;foo&#39; + a + &#39;bar&#39;; // acceptable const c = `foobar`; // good const a = &#39;foobar&#39;; const b = `foo${a}bar`; const c = &#39;foobar&#39;; 解构赋值使用数组成员对变量赋值时，优先使用解构赋值。 const arr = [1, 2, 3, 4]; // bad const first = arr[0]; const second = arr[1]; // good const [first, second] = arr; 函数的参数如果是对象的成员，优先使用解构赋值。 // bad function getFullName(user) { const firstName = user.firstName; const lastName = user.lastName; } // good function getFullName(obj) { const { firstName, lastName } = obj; } // best function getFullName({ firstName, lastName }) { } 如果函数返回多个值，优先使用对象的解构赋值，而不是数组的解构赋值。这样便于以后添加返回值，以及更改返回值的顺序。 // bad function processInput(input) { return [left, right, top, bottom]; } // good function processInput(input) { return { left, right, top, bottom }; } const { left, right } = processInput(input); 对象单行定义的对象，最后一个成员不以逗号结尾。多行定义的对象，最后一个成员以逗号结尾。 // bad const a = { k1: v1, k2: v2, }; const b = { k1: v1, k2: v2 }; // good const a = { k1: v1, k2: v2 }; const b = { k1: v1, k2: v2, }; 对象尽量静态化，一旦定义，就不得随意添加新的属性。如果添加属性不可避免，要使用Object.assign方法。 // bad const a = {}; a.x = 3; // if reshape unavoidable const a = {}; Object.assign(a, { x: 3 }); // good const a = { x: null }; a.x = 3; 如果对象的属性名是动态的，可以在创造对象的时候，使用属性表达式定义。 // bad const obj = { id: 5, name: &#39;San Francisco&#39;, }; obj[getKey(&#39;enabled&#39;)] = true; // good const obj = { id: 5, name: &#39;San Francisco&#39;, [getKey(&#39;enabled&#39;)]: true, }; 上面代码中，对象obj的最后一个属性名，需要计算得到。这时最好采用属性表达式，在新建obj的时候，将该属性与其他属性定义在一起。这样一来，所有属性就在一个地方定义了。 另外，对象的属性和方法，尽量采用简洁表达法，这样易于描述和书写。 var ref = &#39;some value&#39;; // bad const atom = { ref: ref, value: 1, addValue: function (value) { return atom.value + value; }, }; // good const atom = { ref, value: 1, addValue(value) { return atom.value + value; }, }; 数组使用扩展运算符（…）拷贝数组。 // bad const len = items.length; const itemsCopy = []; let i; for (i = 0; i &lt; len; i++) { itemsCopy[i] = items[i]; } // good const itemsCopy = [...items]; 使用Array.from方法，将类似数组的对象转为数组。 const foo = document.querySelectorAll(&#39;.foo&#39;); const nodes = Array.from(foo); 函数立即执行函数可以写成箭头函数的形式。 (() =&gt; { console.log(&#39;Welcome to the Internet.&#39;); })(); 那些需要使用函数表达式的场合，尽量用箭头函数代替。因为这样更简洁，而且绑定了this。 // bad [1, 2, 3].map(function (x) { return x * x; }); // good [1, 2, 3].map((x) =&gt; { return x * x; }); // best [1, 2, 3].map(x =&gt; x * x); 箭头函数取代Function.prototype.bind，不应再用self/_this/that绑定 this。 // bad const self = this; const boundMethod = function(...params) { return method.apply(self, params); } // acceptable const boundMethod = method.bind(this); // best const boundMethod = (...params) =&gt; method.apply(this, params); 简单的、单行的、不会复用的函数，建议采用箭头函数。如果函数体较为复杂，行数较多，还是应该采用传统的函数写法。 所有配置项都应该集中在一个对象，放在最后一个参数，布尔值不可以直接作为参数。 // bad function divide(a, b, option = false ) { } // good function divide(a, b, { option = false } = {}) { } 不要在函数体内使用arguments变量，使用rest运算符（…）代替。因为rest运算符显式表明你想要获取参数，而且arguments是一个类似数组的对象，而rest运算符可以提供一个真正的数组。 // bad function concatenateAll() { const args = Array.prototype.slice.call(arguments); return args.join(&#39;&#39;); } // good function concatenateAll(...args) { return args.join(&#39;&#39;); } 使用默认值语法设置函数参数的默认值。 // bad function handleThings(opts) { opts = opts || {}; } // good function handleThings(opts = {}) { // ... } Map结构注意区分Object和Map，只有模拟现实世界的实体对象时，才使用Object。如果只是需要key: value的数据结构，使用Map结构。因为Map有内建的遍历机制。 let map = new Map(arr); for (let key of map.keys()) { console.log(key); } for (let value of map.values()) { console.log(value); } for (let item of map.entries()) { console.log(item[0], item[1]); } Class总是用Class，取代需要prototype的操作。因为Class的写法更简洁，更易于理解。 // bad function Queue(contents = []) { this._queue = [...contents]; } Queue.prototype.pop = function() { const value = this._queue[0]; this._queue.splice(0, 1); return value; } // good class Queue { constructor(contents = []) { this._queue = [...contents]; } pop() { const value = this._queue[0]; this._queue.splice(0, 1); return value; } } 使用extends实现继承，因为这样更简单，不会有破坏instanceof运算的危险。 // bad const inherits = require(&#39;inherits&#39;); function PeekableQueue(contents) { Queue.apply(this, contents); } inherits(PeekableQueue, Queue); PeekableQueue.prototype.peek = function() { return this._queue[0]; } // good class PeekableQueue extends Queue { peek() { return this._queue[0]; } } 模块首先，Module语法是JavaScript模块的标准写法，坚持使用这种写法。使用import取代require。 // bad const moduleA = require(&#39;moduleA&#39;); const func1 = moduleA.func1; const func2 = moduleA.func2; // good import { func1, func2 } from &#39;moduleA&#39;; 使用export取代module.exports。 // commonJS的写法 var React = require(&#39;react&#39;); var Breadcrumbs = React.createClass({ render() { return &lt;nav /&gt;; } }); module.exports = Breadcrumbs; // ES6的写法 import React from &#39;react&#39;; const Breadcrumbs = React.createClass({ render() { return &lt;nav /&gt;; } }); export default Breadcrumbs 如果模块只有一个输出值，就使用export default，如果模块有多个输出值，就不使用export default，不要export default与普通的export同时使用。 不要在模块输入中使用通配符。因为这样可以确保你的模块之中，有一个默认输出（export default）。 // bad import * as myObject &#39;./importModule&#39;; // good import myObject from &#39;./importModule&#39;; 如果模块默认输出一个函数，函数名的首字母应该小写。 function makeStyleGuide() { } export default makeStyleGuide; 如果模块默认输出一个对象，对象名的首字母应该大写。 const StyleGuide = { es6: { } }; export default StyleGuide; ESLint的使用ESLint是一个语法规则和代码风格的检查工具，可以用来保证写出语法正确、风格统一的代码。 首先，安装ESLint。 $ npm i -g eslint 然后，安装Airbnb语法规则。 $ npm i -g eslint-config-airbnb 最后，在项目的根目录下新建一个.eslintrc文件，配置ESLint。 { &quot;extends&quot;: &quot;eslint-config-airbnb&quot; } 现在就可以检查，当前项目的代码是否符合预设的规则。 index.js文件的代码如下。 var unusued = &#39;I have no purpose!&#39;; function greet() { var message = &#39;Hello, World!&#39;; alert(message); } greet(); 使用ESLint检查这个文件。 $ eslint index.js index.js 1:5 error unusued is defined but never used no-unused-vars 4:5 error Expected indentation of 2 characters but found 4 indent 5:5 error Expected indentation of 2 characters but found 4 indent ✖ 3 problems (3 errors, 0 warnings) 上面代码说明，原文件有三个错误，一个是定义了变量，却没有使用，另外两个是行首缩进为4个空格，而不是规定的2个空格。 感谢阮一峰老师的原创，本分享仅供学习交流","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"规范","slug":"规范","permalink":"https://microzz.com/tags/规范/"}]},{"title":"【开发利器】中国国内可用API合集","date":"2017-02-03T07:00:19.000Z","path":"2017/02/03/API/","text":"中国国内可用API合集目录 笔记 出行 词典 电商 地图 电影 即时通讯 开发者网站 快递查询 旅游 社交 视频 天气 团队协作 图片与图像处理 外卖 消息推送 音乐 云 语音识别 综合 笔记 OneNote - OneNote支持获取，复制，创建，更新，导入与导出笔记，支持为笔记添加多媒体内容，管理权限等。提供SDK和Demo。 为知笔记 - 为知笔记Windows客户端开放了大量的API，其中绝大部分，都通过COM提供，可以在javascript, C#, C++, Delphi等语言中使用。接口通过IDL(Interface description language)语言描述。 印象笔记 - 印象笔记提供了ActionScript 3, Android, C++, Windows, iOS, Java, JavaScript, OS X, Perl, PHP, Python, Ruby等平台的SDK和完整的API参考文档，可通过API进行认证，笔记，笔记本，附件，搜索，同步等操作，同时提供企业版和本地API。 有道云笔记 - 有道云笔记提供了Android SDK，同时Open API允许进行授权，用户，笔记本，笔记，分享，附件等方面的操作。 出行 滴滴 - 滴滴提供了iOS和Android SDK, 可实现拉起滴滴叫车等方面的操作。 神州专车 - 神州专车提供了API模式和H5模式两种接入模式，允许进行基础信息，订单，支付，充值，用户，发票，代金券，企业等方面的操作。 Uber - Uber提供了Android和iOS的SDK,允许进行乘客，行程体验，司机，派送次数等四大方面的操作。 词典 百度翻译 - 百度翻译支持多种语言互相翻译，包含PHP, JS, Python, C, Java版Demo。 必应词典 - 微软翻译API支持文字和语音两种类型，支持多种语言互相翻译，提供C#版本Demo。 金山词霸 - 金山词霸允许进行简单的翻译操作。 扇贝 - 扇贝提供了完整的API，允许进行用户，查询，添加学习记录，忘记单词，例句，笔记等方面的操作。 有道词典 - 有道词典允许进行简单的翻译操作。 电商 当当 - 当当允许商家用户和网站接入授权，可进行商品，订单，图片，问答，店铺和促销等方面的操作。 京东 - 京东提供了Java, PHP, .net的SDK，授权后可进行多种操作。 苏宁开放服务 - 苏宁提供了Java, PHP, .Net, Python版本的SDK，授权后可进行多种操作。 淘宝开放平台 - 淘宝提供了Java, .Net, PHP, Python版本的SDK，授权后提供多种操作。 亚马逊 - 亚马逊提供多种语言版本的SDK，授权后允许多种操作。 地图 百度地图 - 百度地图提供了Android, iOS版本的SDK和JavaScript API，可进行定位、地图、数据、出行、鹰眼轨迹和分析服务。 高德地图 - 高德地图提供了JavaScript和web服务API，Android和iOS SDK，支持地图，定位，搜索，路线规划，导航和室内地图等。 腾讯地图 - 腾讯地图提供了JavaScript API，Android和iOS SDK，支持定位，地图，地点搜索，路线和导航等。 天地图 - 天地图提供了H5 API和JavaScript API等web API，同时提供了Android和iOS SDK，支持基础地图服务，图层管理，地图覆盖物，地图工具，地名搜索和出行规划服务。 图吧地图 - 图吧提供了JavaScript和Flash API，Android和iOS SDK，支持定位，地址解析，位置标注，位置截图，路线规划，周边查询，兴趣点搜索和在线导航。 电影 豆瓣电影 - 豆瓣电影支持电影条目，影人条目，搜索和榜单等。 猫眼电影(非官方) - 支持查询首页电影列表，电影详情(含评论)，本地影院和影院详情，选座。 #非官方 V电影(非官方) - 支持获取V电影网站的数据。 #非官方 Time时光(非官方) - 支持获取时光网网站数据。 #非官方 即时通讯 环信 - 支持Android, iOS, WebIM, Linux, REST集成，支持多种消息类型。 融云 - 支持Android, iOS, Web, 游戏集成，支持多种消息类型。 网易云信 - 支持IM实时通讯，实时音视频，教学白班，专线电话，短信，聊天室，提供iOS, Android, Windows和Web SDK。 腾讯云通信IM - 提供iOS, Android, Windows和Web SDK，支持多种消息类型。 开发者网站 Coding - 授权后可访问coding.net网站的内容。 干货集中营 - 提供妹子图和Android, iOS, 前端，拓展资源等内容。 diycode - 授权后可访问diycode网站的内容。 开源中国 - 授权后可访问开源中国网站的内容。 Laravel China - 授权后可访问 Laravel China 网站的内容。 Ruby China - 授权后可访问Ruby China网站的内容。 V2EX - 可访问V2EX网站的内容。 快递查询 爱快递 - 爱快递支持国内90多家快递物流订单查询服务，免费版有使用次数限制，可用于电子商城单号跟踪,手机应用,微信快递接口等服务。 快递100 - 快递100支持300家国内国际快递，免费版有使用次数限制。 快递鸟 - 快递鸟支持国内外400多家快递公司，免费版有使用次数限制，包含.Net, PHP, Java版Demo。 快递网 - 快递网支持上百家快递查询服务，免费版有使用次数限制。 旅游 去哪儿 - 支持获取去哪儿网的内容。 途牛 - 支持途牛网的内容，仅开放给供应商系统。 携程 - 支持携程网的内容。 艺龙 - 支持获取产品数据，完成用户的预订，进行订单查询、更改或取消。提供在线工具，以及H5, Java, C#, PHP, Ruby版本的Demo。 12306(非官方) - 支持获取12306火车票票数、票价查询。 #非官方 社交 钉钉 - 支持免登，企业通讯录，服务窗，钉盘，地图，会话，DING，电话，音频，扫码，支付，分享等服务，提供SDK和Demo，PC版UI规范，调试工具和钉钉UI组件库。 豆瓣 - 支持图书，电影，音乐，同城，广播，用户，日记，相册，线上活动，论坛，回复和我去等功能，提供豆瓣组件，豆瓣标示和Demo。 开心网 - 支持用户信息，登录授权，好友，传播应用，支付，分享内容，消息，交互，开心网应用等内容，提供SDK，开源插件和标示素材。 QQ互联 - 支持用户资料，QQ会员信息，空间相册，腾讯微博资料，分享到腾讯微博，微博好友信息，财付通信息等内容，提供SDK, Demo, 以及设计资源。 微博 - 支持粉丝服务，微博，评论，用户，关系，账号，收藏，搜索，提醒，短链，公共服务，位置服务，地理信息，地图引擎，支付以及OAuth2.0授权等内容，提供微博标示及SDK。 微信 - 支持移动应用，网站应用，公众账号，公众号第三方平台等内容，提供SDK, Demo, 以及设计资源。 视频 爱奇艺 - 支持弹幕，全色彩播放器，高清码流，视频托管，播放爱奇艺视频，应用分发，IOCP等内容。 Bilibili(非官方) - 支持登录，我的信息，番剧专题，视频/专题收藏、关注，番剧，弹幕等。 #非官方 乐视 - 支持标准直播，标准点播，视频发行平台，移动直播等内容，提供SDK下载。 搜狐视频 - 支持一二级内容获取，内容分类获取，视频详情信息，专辑详情信息，分级列表获取，关键词搜索等内容。 土豆 - 支持视频模块，豆单模块，影视库模块，用户模块，转帖模块，字段定义模块等内容。 优酷 - 支持内容输出，视频搜索，智能推荐，用户登录，用户互动，用户信息，视频上传至优酷，视频互动等内容，提供SDK。 天气 彩云天气 - 支持全球天气数据，两种空气质量数据，天气预报，实况天气，独家降水预报，独家空气质量预报，六种天气数据，四种生活指数数据等内容，部分功能收费。 和风天气 - 支持7-10天预报，实况天气，每小时预报，生活指数，灾害预警，景点天气，历史天气，城市查询等内容，仅国内数据免费。 心知天气 - 支持天气实况，逐日预报和历史，24小时逐小时预报，过去24小时天气历史记录，气象灾害预警，空气质量实况与城市排行，逐日和逐小时空气质量预报，过去24小时空气质量历史记录，生活指数，农历、节气、生肖，机动车尾号限行，日出日落，月初月落和月像，城市搜索等内容，仅国内数据免费。 团队协作 Teambition - 支持详细的文档说明，部分平台提供demo。 图片与图像处理 Bing每日壁纸(非官方) - 支持图片URL和图片描述，可获取不同地区的数据。 #非官方 Camera360 - 支持全帧率直播美白滤镜，提供SDK和Demo。 嗨图 - 支持图片标注，仅提供iOS版本SDK。 名片全能王 - 支持精准识别几十种语言的名片，自动切边并美化名片图像，自动返回识别结果，提供多种版本SDK，收费。 企业证件识别 - 支持身份证，驾驶证，护照等，收费。 扫描全能王 - 支持图像智能剪裁，五种图像增强模式，手动调节图像细节，自动返回扫描结果等，提供iOS与Android版本SDK，收费。 我知图 - 支持相似图像搜索，图像识别匹配，图像识别关键词推荐，重复图片探测等内容。 银行卡|信用卡识别 - 提供SDK和API，收费。 外卖 百度外卖 - 支持商户，菜品，商品，订单和基础数据等内容，提供SDK和Demo。 大众点评 - 支持商户，团购，在线预定，商品点评，数据统计，元数据等内容。 饿了么 - 支持查询，预定，订单，其他订单，数据推送，支付，评价，活动，账户同步，数据落地同步等内容。 美团外卖 - 支持门店，配送范围，菜品，药品，订单，订单推送等内容。 消息推送 百度云推送 - 支持iOS, Android和服务器端，支持推送，统计，组管理等Rest API接口。服务器端支持Java, Python, PHP, REST API。提供所支持各语言版本的SDK。 华为推送 - 支持Android，提供SDK。 极光 - 支持Android, iOS, WindowsPhone, 服务器端REST API, 提供Java, Python, PHP, Ruby, C#, Node.js等版本的SDK。 LeanCloud - 支持Android, iOS, WindowsPhone和Web网页推送，使用云引擎和JavaScript创建推送，使用REST API推送消息。提供Objectvie-C(开放源码), JavaScript(开放源码), Android, Unity, .Net, WindowsPhone, Java(开放源码), Python(开放源码), PHP(开放源码), C++(开放源码), Swift(开放源码)版本SDK。同时提供Demo。 腾讯信鸽 - 支持iOS和Android平台，服务器端采用Rest API, 同时服务器端支持Java, PHP, Python等语言并提供SDK。 小米 - 支持Android和iOS平台，服务器端支持Java, Python并提供SDK。 友盟 - 支持Android和iOS平台，服务器端支持PHP, Java, Python并提供SDK。 音乐 百度音乐(非官方) - 支持频道歌曲列表，专辑的歌曲列表，歌曲的详细信息，歌手专辑信息，搜索，歌手的所有歌曲，排行榜，所有专辑，所有歌手，歌手的专辑列表，歌手信息，歌词搜索，歌曲文件详细信息。 #非官方 豆瓣音乐 - 支持音乐信息，评论信息，标签信息，搜索音乐，某个音乐中标记最多的标签，发表、修改、删除评论，用户对音乐的所有标签等内容。 考拉FM - 支持获取指定分类下列表和内容，搜索指定关键字内容，专辑/电台/直播详情，指定专辑下列表，指定电台播单，分类下专辑TOP50，指定期(碎片)所在专辑最新分页功能，分类下全部直播计划，版本升级接口，排行榜，精选，传统电台列表/详情/地区等。 酷狗音乐(非官方) - 支持搜索，各种排行榜，歌手专辑信息，下载和获取播放地址。 #非官方 企鹅FM - 支持获取电台分类列表，电台分类下的专辑信息列表，专辑下节目信息列表，电台节目播放链接，搜索关键字相关主播/专辑/节目，主播名下专辑，特定时间段内新增主播/更新的专辑/新增的专辑等。 QQ音乐(非官方) - 支持歌曲榜单，歌曲/歌词地址，歌曲图片。 #非官方 蜻蜓FM - 支持OAuth2.0授权，音频数据中心，分类，点播，直播，临时直播，排行榜，搜索，内容更新状态，主播，此刻，专题，活动等内容。 网易云音乐(非官方) - 支持获取用户歌单，歌单详情，歌曲URL。 #非官方 喜马拉雅FM - 支持Android和iOS平台，并提供相应的SDK和Demo，具体支持内容请下载相关文件查看。 云 阿里云 - 支持弹性计算，数据库，存储与CDN，网络，应用服务，域名与网站等类别的内容，并提供了相关SDK。 百度云 - 支持计算和网络，存储和CDN，数据库，安全和管理，数据分析，智能多媒体服务，物联网服务，人工智能，应用服务，网站服务，数字营销服务等内容，并提供相关的SDK。 Bmob - 支持云数据库，容器服务，消息推送，文件存储，短信验证码，及时通讯，云端逻辑，定时任务，地理位置等。 LeanCloud - 支持云存储，数据分析，用户关系，实时通讯，消息推送，移动统计等。 七牛云 - 支持对象存储，融合CDN，直播云，数据处理等。 腾讯云 - 支持计算，网络，存储与CDN，数据库，安全服务，监控与管理，域名服务，视频服务，大数据与AI等内容，提供相关SDK。 又拍云 - 支持 CDN、云存储、直播云、点播云、SSL证书服务、云处理、流量营销等。 野狗 - 支持实时数据同步，实时视频通话，及时通讯，短信，身份认证等。 语音识别 百度语音 - 支持全平台REST API, 离线在线融合模式，深度语义解析，场景识别定制，自定义上传语料、训练模型，基础服务永久免费。提供相应SDK和Demo应用。 搜狗语音云开放平台 - 支持在线/离线语音识别，在线听歌识曲，离线语音合成等内容。提供相应平台SDK。 讯飞开放平台 - 支持语音听写/转写，在线/离线命令词识别，语音唤醒等内容，平台支持广泛，提供相应SDK。 杂志 豆瓣一刻(非官方) - 支持获取指定日期文章列表，栏目总览，推荐作者，作者信息，作者更多文章信息，栏目文章列表及翻页，文章评论及热门评论列表。 #非官方 One一个(非官方) - 支持获取首页图片，文章，音乐及电影。 #非官方 知乎日报(非官方) - 支持获取界面启动图像，软件版本查询，最新消息，消息内容获取与离线下载，过往消息，新闻额外消息，新闻对应长/短评论查看，主题日报列表，主题日报内容，热门消息，栏目总览，栏目具体消息，新闻的推荐者，某个专栏之前的新闻，Editor的主页等。 #非官方 知乎专栏(非官方) - 支持获取指定专栏的信息，指定专栏的文章列表，指定的文章内容，评论列表，点赞信息。 #非官方 综合 阿凡达数据 - 支持金融股票，充值认证，便民类，新闻文章，医药交通，科教文艺，创意数据，及时通讯等内容。 阿里大于 - 支持验证码，短信通知，语音通知，流量钱包充值，私密专线，群发助手等内容。 APiX - 支持基础征信数据，信用分析服务，支付缴费接口等数据，部分免费。 百度API STORE - 支持多种类型数据，部分免费，提供SDK。 HaoService - 支持多种类型数据。 聚合数据 - 支持多种类型数据，部分免费。 通联数据 - 提供金融类数据，支持免费试用。","tags":[{"name":"API","slug":"API","permalink":"https://microzz.com/tags/API/"},{"name":"开发者","slug":"开发者","permalink":"https://microzz.com/tags/开发者/"}]},{"title":"前端面试题","date":"2017-02-01T07:26:06.000Z","path":"2017/02/01/fe-interview/","text":"前端面试题一些开放性题目1.自我介绍：除了基本个人信息以外，面试官更想听的是你与众不同的地方和你的优势。 2.项目介绍 3.如何看待前端开发？ 4.平时是如何学习前端开发的？ 5.未来三到五年的规划是怎样的？ position的值， relative和absolute分别是相对于谁进行定位的？ absolute :生成绝对定位的元素， 相对于最近一级的 定位不是 static 的父元素来进行定位。 fixed （老IE不支持）生成绝对定位的元素，通常相对于浏览器窗口或 frame 进行定位。 relative 生成相对定位的元素，相对于其在普通流中的位置进行定位。 static 默认值。没有定位，元素出现在正常的流中 sticky 生成粘性定位的元素，容器的位置根据正常文档流计算得出 如何解决跨域问题 JSONP： 原理是：动态插入script标签，通过script标签引入一个js文件，这个js文件载入成功后会执行我们在url参数中指定的函数，并且会把我们需要的json数据作为参数传入。 由于同源策略的限制，XmlHttpRequest只允许请求当前源（域名、协议、端口）的资源，为了实现跨域请求，可以通过script标签实现跨域请求，然后在服务端输出JSON数据并执行回调函数，从而解决了跨域的数据请求。 优点是兼容性好，简单易用，支持浏览器与服务器双向通信。缺点是只支持GET请求。 JSONP：json+padding（内填充），顾名思义，就是把JSON填充到一个盒子里 &lt;script&gt; function createJs(sUrl){ var oScript = document.createElement(&#39;script&#39;); oScript.type = &#39;text/javascript&#39;; oScript.src = sUrl; document.getElementsByTagName(&#39;head&#39;)[0].appendChild(oScript); } createJs(&#39;jsonp.js&#39;); box({ &#39;name&#39;: &#39;test&#39; }); function box(json){ alert(json.name); } &lt;/script&gt; CORS 服务器端对于CORS的支持，主要就是通过设置Access-Control-Allow-Origin来进行的。如果浏览器检测到相应的设置，就可以允许Ajax进行跨域的访问。 通过修改document.domain来跨子域 将子域和主域的document.domain设为同一个主域.前提条件：这两个域名必须属于同一个基础域名!而且所用的协议，端口都要一致，否则无法利用document.domain进行跨域 主域相同的使用document.domain 使用window.name来进行跨域 window对象有个name属性，该属性有个特征：即在一个窗口(window)的生命周期内,窗口载入的所有的页面都是共享一个window.name的，每个页面对window.name都有读写的权限，window.name是持久存在一个窗口载入过的所有页面中的 使用HTML5中新引进的window.postMessage方法来跨域传送数据 还有flash、在服务器上设置代理页面等跨域方式。个人认为window.name的方法既不复杂，也能兼容到几乎所有浏览器，这真是极好的一种跨域方法。 XML和JSON的区别(1).数据体积方面。 JSON相对于XML来讲，数据的体积小，传递的速度更快些。 (2).数据交互方面。 JSON与JavaScript的交互更加方便，更容易解析处理，更好的数据交互。 (3).数据描述方面。 JSON对数据的描述性比XML较差。 (4).传输速度方面。 JSON的速度要远远快于XML。 谈谈你对webpack的看法WebPack 是一个模块打包工具，你可以使用WebPack管理你的模块依赖，并编绎输出模块们所需的静态文件。它能够很好地管理、打包Web开发中所用到的HTML、Javascript、CSS以及各种静态文件（图片、字体等），让开发过程更加高效。对于不同类型的资源，webpack有对应的模块加载器。webpack模块打包器会分析模块间的依赖关系，最后 生成了优化且合并后的静态资源。 webpack的两大特色： 1.code splitting（可以自动完成） 2.loader 可以处理各种类型的静态文件，并且支持串联操作 webpack 是以commonJS的形式来书写脚本滴，但对 AMD/CMD 的支持也很全面，方便旧项目进行代码迁移。 webpack具有requireJs和browserify的功能，但仍有很多自己的新特性： 1. 对 CommonJS 、 AMD 、ES6的语法做了兼容 2. 对js、css、图片等资源文件都支持打包 3. 串联式模块加载器以及插件机制，让其具有更好的灵活性和扩展性，例如提供对CoffeeScript、ES6的支持 4. 有独立的配置文件webpack.config.js 5. 可以将代码切割成不同的chunk，实现按需加载，降低了初始化时间 6. 支持 SourceUrls 和 SourceMaps，易于调试 7. 具有强大的Plugin接口，大多是内部插件，使用起来比较灵活 8.webpack 使用异步 IO 并具有多级缓存。这使得 webpack 很快且在增量编译上更加快 说说TCP传输的三次握手四次挥手策略 为了准确无误地把数据送达目标处，TCP协议采用了三次握手策略。用TCP协议把数据包送出去后，TCP不会对传送 后的情况置之不理，它一定会向对方确认是否成功送达。握手过程中使用了TCP的标志：SYN和ACK。 发送端首先发送一个带SYN标志的数据包给对方。接收端收到后，回传一个带有SYN/ACK标志的数据包以示传达确认信息。最后，发送端再回传一个带ACK标志的数据包，代表“握手”结束。若在握手过程中某个阶段莫名中断，TCP协议会再次以相同的顺序发送相同的数据包。 断开一个TCP连接则需要“四次握手”： 第一次挥手：主动关闭方发送一个FIN，用来关闭主动方到被动关闭方的数据传送，也就是主动关闭方告诉被动关闭方：我已经不 会再给你发数据了(当然，在fin包之前发送出去的数据，如果没有收到对应的ack确认报文，主动关闭方依然会重发这些数据)，但是，此时主动关闭方还可 以接受数据。 第二次挥手：被动关闭方收到FIN包后，发送一个ACK给对方，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号）。 第三次挥手：被动关闭方发送一个FIN，用来关闭被动关闭方到主动关闭方的数据传送，也就是告诉主动关闭方，我的数据也发送完了，不会再给你发数据了。 第四次挥手：主动关闭方收到FIN后，发送一个ACK给被动关闭方，确认序号为收到序号+1，至此，完成四次挥手。 TCP和UDP的区别TCP（Transmission Control Protocol，传输控制协议）是基于连接的协议，也就是说，在正式收发数据前，必须和对方建立可靠的连接。一个TCP连接必须要经过三次“对话”才能建立起来 UDP（User Data Protocol，用户数据报协议）是与TCP相对应的协议。它是面向非连接的协议，它不与对方建立连接，而是直接就把数据包发送过去！ UDP适用于一次只传送少量数据、对可靠性要求不高的应用环境。 说说你对作用域链的理解作用域链的作用是保证执行环境里有权访问的变量和函数是有序的，作用域链的变量只能向上访问，变量访问到window对象即被终止，作用域链向下访问变量是不被允许的。 创建ajax过程(1)创建XMLHttpRequest对象,也就是创建一个异步调用对象. (2)创建一个新的HTTP请求,并指定该HTTP请求的方法、URL及验证信息. (3)设置响应HTTP请求状态变化的函数. (4)发送HTTP请求. (5)获取异步调用返回的数据. (6)使用JavaScript和DOM实现局部刷新. 渐进增强和优雅降级渐进增强 ：针对低版本浏览器进行构建页面，保证最基本的功能，然后再针对高级浏览器进行效果、交互等改进和追加功能达到更好的用户体验。 优雅降级 ：一开始就构建完整的功能，然后再针对低版本浏览器进行兼容。 常见web安全及防护原理 sql注入原理 就是通过把SQL命令插入到Web表单递交或输入域名或页面请求的查询字符串，最终达到欺骗服务器执行恶意的SQL命令。 总的来说有以下几点： 1.永远不要信任用户的输入，要对用户的输入进行校验，可以通过正则表达式，或限制长度，对单引号和双&quot;-&quot;进行转换等。 2.永远不要使用动态拼装SQL，可以使用参数化的SQL或者直接使用存储过程进行数据查询存取。 3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。 4.不要把机密信息明文存放，请加密或者hash掉密码和敏感的信息。 XSS原理及防范 Xss(cross-site scripting)攻击指的是攻击者往Web页面里插入恶意 html标签或者javascript代码。比如：攻击者在论坛中放一个 看似安全的链接，骗取用户点击后，窃取cookie中的用户私密信息；或者攻击者在论坛中加一个恶意表单， 当用户提交表单的时候，却把信息传送到攻击者的服务器中，而不是用户原本以为的信任站点。 XSS防范方法 首先代码里对用户输入的地方和变量都需要仔细检查长度和对”&lt;”,”&gt;”,”;”,”’”等字符做过滤；其次任何内容写到页面之前都必须加以encode，避免不小心把html tag 弄出来。这一个层面做好，至少可以堵住超过一半的XSS 攻击。 首先，避免直接在cookie 中泄露用户隐私，例如email、密码等等。 其次，通过使cookie 和系统ip 绑定来降低cookie 泄露后的危险。这样攻击者得到的cookie 没有实际价值，不可能拿来重放。 如果网站不需要再浏览器端对cookie 进行操作，可以在Set-Cookie 末尾加上HttpOnly 来防止javascript 代码直接获取cookie 。 尽量采用POST 而非GET 提交表单 XSS与CSRF有什么区别吗？ XSS是获取信息，不需要提前知道其他用户页面的代码和数据包。CSRF是代替用户完成指定的动作，需要知道其他用户页面的代码和数据包。 要完成一次CSRF攻击，受害者必须依次完成两个步骤： 登录受信任网站A，并在本地生成Cookie。 在不登出A的情况下，访问危险网站B。 CSRF的防御 服务端的CSRF方式方法很多样，但总的思想都是一致的，就是在客户端页面增加伪随机数。 通过验证码的方法 Web Worker 和webSocket worker主线程: 1.通过 worker = new Worker( url ) 加载一个JS文件来创建一个worker，同时返回一个worker实例。 2.通过worker.postMessage( data ) 方法来向worker发送数据。 3.绑定worker.onmessage方法来接收worker发送过来的数据。 4.可以使用 worker.terminate() 来终止一个worker的执行。 WebSocket是Web应用程序的传输协议，它提供了双向的，按序到达的数据流。他是一个HTML5协议，WebSocket的连接是持久的，他通过在客户端和服务器之间保持双工连接，服务器的更新可以被及时推送给客户端，而不需要客户端以一定时间间隔去轮询。 HTTP和HTTPSHTTP协议通常承载于TCP协议之上，在HTTP和TCP之间添加一个安全协议层（SSL或TSL），这个时候，就成了我们常说的HTTPS。 默认HTTP的端口号为80，HTTPS的端口号为443。 为什么HTTPS安全因为网络请求需要中间有很多的服务器路由器的转发。中间的节点都可能篡改信息，而如果使用HTTPS，密钥在你和终点站才有。https之所以比http安全，是因为他利用ssl/tls协议传输。它包含证书，卸载，流量转发，负载均衡，页面适配，浏览器适配，refer传递等。保障了传输过程的安全性 对前端模块化的认识 AMD 是 RequireJS 在推广过程中对模块定义的规范化产出。 CMD 是 SeaJS 在推广过程中对模块定义的规范化产出。 AMD 是提前执行，CMD 是延迟执行。 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。 CMD模块方式 define(function(require, exports, module) { // 模块代码 }); Javascript垃圾回收方法 标记清除（mark and sweep） 这是JavaScript最常见的垃圾回收方式，当变量进入执行环境的时候，比如函数中声明一个变量，垃圾回收器将其标记为“进入环境”，当变量离开环境的时候（函数执行结束）将其标记为“离开环境”。 垃圾回收器会在运行的时候给存储在内存中的所有变量加上标记，然后去掉环境中的变量以及被环境中变量所引用的变量（闭包），在这些完成之后仍存在标记的就是要删除的变量了 引用计数(reference counting) 在低版本IE中经常会出现内存泄露，很多时候就是因为其采用引用计数方式进行垃圾回收。引用计数的策略是跟踪记录每个值被使用的次数，当声明了一个 变量并将一个引用类型赋值给该变量的时候这个值的引用次数就加1，如果该变量的值变成了另外一个，则这个值得引用次数减1，当这个值的引用次数变为0的时 候，说明没有变量在使用，这个值没法被访问了，因此可以将其占用的空间回收，这样垃圾回收器会在运行的时候清理掉引用次数为0的值占用的空间。 在IE中虽然JavaScript对象通过标记清除的方式进行垃圾回收，但BOM与DOM对象却是通过引用计数回收垃圾的，也就是说只要涉及BOM及DOM就会出现循环引用问题。 你觉得前端工程的价值体现在哪为简化用户使用提供技术支持（交互部分） 为多个浏览器兼容性提供支持 为提高用户浏览速度（浏览器性能）提供支持 为跨平台或者其他基于webkit或其他渲染引擎的应用提供支持 为展示数据提供支持（数据接口） 谈谈性能优化问题代码层面：避免使用css表达式，避免使用高级选择器，通配选择器。 缓存利用：缓存Ajax，使用CDN，使用外部js和css文件以便缓存，添加Expires头，服务端配置Etag，减少DNS查找等 请求数量：合并样式和脚本，使用css图片精灵，初始首屏之外的图片资源按需加载，静态资源延迟加载。 请求带宽：压缩文件，开启GZIP， 代码层面的优化 用hash-table来优化查找 少用全局变量 用innerHTML代替DOM操作，减少DOM操作次数，优化javascript性能 用setTimeout来避免页面失去响应 缓存DOM节点查找的结果 避免使用CSS Expression 避免全局查询 避免使用with(with会创建自己的作用域，会增加作用域链长度) 多个变量声明合并 避免图片和iFrame等的空Src。空Src会重新加载当前页面，影响速度和效率 尽量避免写在HTML标签中写Style属性 移动端性能优化 尽量使用css3动画，开启硬件加速。 适当使用touch事件代替click事件。 避免使用css3渐变阴影效果。 可以用transform: translateZ(0)来开启硬件加速。 不滥用Float。Float在渲染时计算量比较大，尽量减少使用 不滥用Web字体。Web字体需要下载，解析，重绘当前页面，尽量减少使用。 合理使用requestAnimationFrame动画代替setTimeout CSS中的属性（CSS3 transitions、CSS3 3D transforms、Opacity、Canvas、WebGL、Video）会触发GPU渲染，请合理使用。过渡使用会引发手机过耗电增加 PC端的在移动端同样适用 相关阅读：如何做到一秒渲染一个移动页面 什么是Etag当发送一个服务器请求时，浏览器首先会进行缓存过期判断。浏览器根据缓存过期时间判断缓存文件是否过期。 情景一：若没有过期，则不向服务器发送请求，直接使用缓存中的结果，此时我们在浏览器控制台中可以看到 200 OK(from cache) ，此时的情况就是完全使用缓存，浏览器和服务器没有任何交互的。 情景二：若已过期，则向服务器发送请求，此时请求中会带上①中设置的文件修改时间，和Etag 然后，进行资源更新判断。服务器根据浏览器传过来的文件修改时间，判断自浏览器上一次请求之后，文件是不是没有被修改过；根据Etag，判断文件内容自上一次请求之后，有没有发生变化 情形一：若两种判断的结论都是文件没有被修改过，则服务器就不给浏览器发index.html的内容了，直接告诉它，文件没有被修改过，你用你那边的缓存吧—— 304 Not Modified，此时浏览器就会从本地缓存中获取index.html的内容。此时的情况叫协议缓存，浏览器和服务器之间有一次请求交互。 情形二：若修改时间和文件内容判断有任意一个没有通过，则服务器会受理此次请求，之后的操作同① ① 只有get请求会被缓存，post请求不会 Expires和Cache-ControlExpires要求客户端和服务端的时钟严格同步。HTTP1.1引入Cache-Control来克服Expires头的限制。如果max-age和Expires同时出现，则max-age有更高的优先级。 Cache-Control: no-cache, private, max-age=0 ETag: abcde Expires: Thu, 15 Apr 201420180515 20:00:00 GMT Pragma: private Last-Modified: $now // RFC1123 format ETag应用:Etag由服务器端生成，客户端通过If-Match或者说If-None-Match这个条件判断请求来验证资源是否修改。常见的是使用If-None-Match。请求一个文件的流程可能如下： ====第一次请求=== 1.客户端发起 HTTP GET 请求一个文件； 2.服务器处理请求，返回文件内容和一堆Header，当然包括Etag(例如&quot;2e681a-6-5d044840&quot;)(假设服务器支持Etag生成和已经开启了Etag).状态码200 ====第二次请求=== 客户端发起 HTTP GET 请求一个文件，注意这个时候客户端同时发送一个If-None-Match头，这个头的内容就是第一次请求时服务器返回的Etag：2e681a-6-5d0448402.服务器判断发送过来的Etag和计算出来的Etag匹配，因此If-None-Match为False，不返回200，返回304，客户端继续使用本地缓存；流程很简单，问题是，如果服务器又设置了Cache-Control:max-age和Expires呢，怎么办 答案是同时使用，也就是说在完全匹配If-Modified-Since和If-None-Match即检查完修改时间和Etag之后， 服务器才能返回304.(不要陷入到底使用谁的问题怪圈) 为什么使用Etag请求头? Etag 主要为了解决 Last-Modified 无法解决的一些问题。 栈和队列的区别栈的插入和删除操作都是在一端进行的，而队列的操作却是在两端进行的。 队列先进先出，栈先进后出。 栈只允许在表尾一端进行插入和删除，而队列只允许在表尾一端进行插入，在表头一端进行删除 栈和堆的区别栈区（stack）— 由编译器自动分配释放 ，存放函数的参数值，局部变量的值等。 堆区（heap） — 一般由程序员分配释放， 若程序员不释放，程序结束时可能由OS回收。 堆（数据结构）：堆可以被看成是一棵树，如：堆排序； 栈（数据结构）：一种先进后出的数据结构。 快速 排序的思想并实现一个快排“快速排序”的思想很简单，整个排序过程只需要三步： （1）在数据集之中，找一个基准点 （2）建立两个数组，分别存储左边和右边的数组 （3）利用递归进行下次比较 &lt;script type=&quot;text/javascript&quot;&gt; function quickSort(arr){ if(arr.length&lt;=1){ return arr;//如果数组只有一个数，就直接返回； } var num = Math.floor(arr.length/2);//找到中间数的索引值，如果是浮点数，则向下取整 var numValue = arr.splice(num,1);//找到中间数的值 var left = []; var right = []; for(var i=0;i&lt;arr.length;i++){ if(arr[i]&lt;numValue){ left.push(arr[i]);//基准点的左边的数传到左边数组 } else{ right.push(arr[i]);//基准点的右边的数传到右边数组 } } return quickSort(left).concat([numValue],quickSort(right));//递归不断重复比较 } alert(quickSort([32,45,37,16,2,87]));//弹出“2,16,32,37,45,87” &lt;/script&gt; 你觉得jQuery或zepto源码有哪些写的好的地方(答案仅供参考) jquery源码封装在一个匿名函数的自执行环境中，有助于防止变量的全局污染，然后通过传入window对象参数，可以使window对象作为局部变量使用，好处是当jquery中访问window对象的时候，就不用将作用域链退回到顶层作用域了，从而可以更快的访问window对象。同样，传入undefined参数，可以缩短查找undefined时的作用域链。 (function( window, undefined ) { //用一个函数域包起来，就是所谓的沙箱 //在这里边var定义的变量，属于这个函数域内的局部变量，避免污染全局 //把当前沙箱需要的外部变量通过函数参数引入进来 //只要保证参数对内提供的接口的一致性，你还可以随意替换传进来的这个参数 window.jQuery = window.$ = jQuery; })( window ); jquery将一些原型属性和方法封装在了jquery.prototype中，为了缩短名称，又赋值给了jquery.fn，这是很形象的写法。 有一些数组或对象的方法经常能使用到，jQuery将其保存为局部变量以提高访问速度。 jquery实现的链式调用可以节约代码，所返回的都是同一个对象，可以提高代码效率。 ES6的了解新增模板字符串（为JavaScript提供了简单的字符串插值功能）、箭头函数（操作符左边为输入的参数，而右边则是进行的操作以及返回的值Inputs=&gt;outputs。）、for-of（用来遍历数据—例如数组中的值。）arguments对象可被不定参数和默认参数完美代替。ES6将promise对象纳入规范，提供了原生的Promise对象。增加了let和const命令，用来声明变量。增加了块级作用域。let命令实际上就增加了块级作用域。ES6规定，var命令和function命令声明的全局变量，属于全局对象的属性；let命令、const命令、class命令声明的全局变量，不属于全局对象的属性。。还有就是引入module模块的概念 js继承方式及其优缺点 原型链继承的缺点 一是字面量重写原型会中断关系，使用引用类型的原型，并且子类型还无法给超类型传递参数。 借用构造函数（类式继承） 借用构造函数虽然解决了刚才两种问题，但没有原型，则复用无从谈起。所以我们需要原型链+借用构造函数的模式，这种模式称为组合继承 组合式继承 组合式继承是比较常用的一种继承方法，其背后的思路是 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现对实例属性的继承。这样，既通过在原型上定义方法实现了函数复用，又保证每个实例都有它自己的属性。 具体请看：JavaScript继承方式详解 关于Http 2.0 你知道多少HTTP/2引入了“服务端推（server push）”的概念，它允许服务端在客户端需要数据之前就主动地将数据发送到客户端缓存中，从而提高性能。 HTTP/2提供更多的加密支持 HTTP/2使用多路技术，允许多个消息在一个连接上同时交差。 它增加了头压缩（header compression），因此即使非常小的请求，其请求和响应的header都只会占用很小比例的带宽。 defer和async defer并行加载js文件，会按照页面上script标签的顺序执行async并行加载js文件，下载完成立即执行，不会按照页面上script标签的顺序执行 谈谈浮动和清除浮动浮动的框可以向左或向右移动，直到他的外边缘碰到包含框或另一个浮动框的边框为止。由于浮动框不在文档的普通流中，所以文档的普通流的块框表现得就像浮动框不存在一样。浮动的块框会漂浮在文档普通流的块框上。 如何评价AngularJS和BackboneJSbackbone具有依赖性，依赖underscore.js。Backbone + Underscore + jQuery(or Zepto) 就比一个AngularJS 多出了2 次HTTP请求. Backbone的Model没有与UI视图数据绑定，而是需要在View中自行操作DOM来更新或读取UI数据。AngularJS与此相反，Model直接与UI视图绑定，Model与UI视图的关系，通过directive封装，AngularJS内置的通用directive，就能实现大部分操作了，也就是说，基本不必关心Model与UI视图的关系，直接操作Model就行了，UI视图自动更新。 AngularJS的directive，你输入特定数据，他就能输出相应UI视图。是一个比较完善的前端MVW框架，包含模板，数据双向绑定，路由，模块化，服务，依赖注入等所有功能，模板功能强大丰富，并且是声明式的，自带了丰富的 Angular 指令。 用过哪些设计模式 工厂模式： 主要好处就是可以消除对象间的耦合，通过使用工程方法而不是new关键字。将所有实例化的代码集中在一个位置防止代码重复。 工厂模式解决了重复实例化的问题 ，但还有一个问题,那就是识别问题，因为根本无法 搞清楚他们到底是哪个对象的实例。 function createObject(name,age,profession){//集中实例化的函数var obj = new Object(); obj.name = name; obj.age = age; obj.profession = profession; obj.move = function () { return this.name + &#39; at &#39; + this.age + &#39; engaged in &#39; + this.profession; }; return obj; } var test1 = createObject(&#39;trigkit4&#39;,22,&#39;programmer&#39;);//第一个实例var test2 = createObject(&#39;mike&#39;,25,&#39;engineer&#39;);//第二个实例 构造函数模式 使用构造函数的方法 ，即解决了重复实例化的问题 ，又解决了对象识别的问题，该模式与工厂模式的不同之处在于： 1.构造函数方法没有显示的创建对象 (new Object()); 2.直接将属性和方法赋值给 this 对象; 3.没有 renturn 语句。 说说你对闭包的理解使用闭包主要是为了设计私有的方法和变量。闭包的优点是可以避免全局变量的污染，缺点是闭包会常驻内存，会增大内存使用量，使用不当很容易造成内存泄露。在js中，函数即闭包，只有函数才会产生作用域的概念 闭包有三个特性： 1.函数嵌套函数 2.函数内部可以引用外部的参数和变量 3.参数和变量不会被垃圾回收机制回收 具体请看：详解js闭包 请你谈谈Cookie的弊端cookie虽然在持久保存客户端数据提供了方便，分担了服务器存储的负担，但还是有很多局限性的。 第一：每个特定的域名下最多生成20个cookie 1.IE6或更低版本最多20个cookie 2.IE7和之后的版本最后可以有50个cookie。 3.Firefox最多50个cookie 4.chrome和Safari没有做硬性限制 IE和Opera 会清理近期最少使用的cookie，Firefox会随机清理cookie。 cookie的最大大约为4096字节，为了兼容性，一般不能超过4095字节。 IE 提供了一种存储可以持久化用户数据，叫做userdata，从IE5.0就开始支持。每个数据最多128K，每个域名下最多1M。这个持久化数据放在缓存中，如果缓存没有清理，那么会一直存在。 优点：极高的扩展性和可用性 1.通过良好的编程，控制保存在cookie中的session对象的大小。 2.通过加密和安全传输技术（SSL），减少cookie被破解的可能性。 3.只在cookie中存放不敏感数据，即使被盗也不会有重大损失。 4.控制cookie的生命期，使之不会永远有效。偷盗者很可能拿到一个过期的cookie。 缺点： 1.`Cookie`数量和长度的限制。每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉. 2.安全性问题。如果cookie被人拦截了，那人就可以取得所有的session信息。即使加密也与事无补，因为拦截者并不需要知道cookie的意义，他只要原样转发cookie就可以达到目的了。 3.有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它起不到任何作用。 浏览器本地存储在较高版本的浏览器中，js提供了sessionStorage和globalStorage。在HTML5中提供了localStorage来取代globalStorage。 html5中的Web Storage包括了两种存储方式：sessionStorage和localStorage。 sessionStorage用于本地存储一个会话（session）中的数据，这些数据只有在同一个会话中的页面才能访问并且当会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 而localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 web storage和cookie的区别Web Storage的概念和cookie相似，区别是它是为了更大容量存储设计的。Cookie的大小是受限的，并且每次你请求一个新的页面的时候Cookie都会被发送过去，这样无形中浪费了带宽，另外cookie还需要指定作用域，不可以跨域调用。 除此之外，Web Storage拥有setItem,getItem,removeItem,clear等方法，不像cookie需要前端开发者自己封装setCookie，getCookie。 但是cookie也是不可以或缺的：cookie的作用是与服务器进行交互，作为HTTP规范的一部分而存在 ，而Web Storage仅仅是为了在本地“存储”数据而生 浏览器的支持除了IE７及以下不支持外，其他标准浏览器都完全支持(ie及FF需在web服务器里运行)，值得一提的是IE总是办好事，例如IE7、IE6中的userData其实就是javascript本地存储的解决方案。通过简单的代码封装可以统一到所有的浏览器都支持web storage。 localStorage和sessionStorage都具有相同的操作方法，例如setItem、getItem和removeItem等 cookie 和session 的区别： 1、cookie数据存放在客户的浏览器上，session数据放在服务器上。 2、cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗 考虑到安全应当使用session。 3、session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能 考虑到减轻服务器性能方面，应当使用COOKIE。 4、单个cookie保存的数据不能超过4K，很多浏览器都限制一个站点最多保存20个cookie。 5、所以个人建议： 将登陆信息等重要信息存放为SESSION 其他信息如果需要保留，可以放在COOKIE中 display:none和visibility:hidden的区别？ display:none 隐藏对应的元素，在文档布局中不再给它分配空间，它各边的元素会合拢，就当他从来不存在。 visibility:hidden 隐藏对应的元素，但是在文档布局中仍保留原来的空间。 CSS中link 和@import的区别是？ (1) link属于HTML标签，而@import是CSS提供的; (2) 页面被加载的时，link会同时被加载，而@import被引用的CSS会等到引用它的CSS文件被加载完再加载; (3) import只在IE5以上才能识别，而link是HTML标签，无兼容问题; (4) link方式的样式的权重 高于@import的权重. position:absolute和float属性的异同 共同点：对内联元素设置float和absolute属性，可以让元素脱离文档流，并且可以设置其宽高。 不同点：float仍会占据位置，absolute会覆盖文档流中的其他元素。 介绍一下box-sizing属性？ box-sizing属性主要用来控制元素的盒模型的解析模式。默认值是content-box。 content-box：让元素维持W3C的标准盒模型。元素的宽度/高度由border + padding + content的宽度/高度决定，设置width/height属性指的是content部分的宽/高 border-box：让元素维持IE传统盒模型（IE6以下版本和IE6~7的怪异模式）。设置width/height属性指的是border + padding + content 标准浏览器下，按照W3C规范对盒模型解析，一旦修改了元素的边框或内距，就会影响元素的盒子尺寸，就不得不重新计算元素的盒子尺寸，从而影响整个页面的布局。 CSS 选择符有哪些？哪些属性可以继承？优先级算法如何计算？ CSS3新增伪类有那些？ 1.id选择器（ # myid） 2.类选择器（.myclassname） 3.标签选择器（div, h1, p） 4.相邻选择器（h1 + p） 5.子选择器（ul &gt; li） 6.后代选择器（li a） 7.通配符选择器（ * ） 8.属性选择器（a[rel = &quot;external&quot;]） 9.伪类选择器（a: hover, li:nth-child） 优先级为: !important &gt; id &gt; class &gt; tag important 比 内联优先级高,但内联比 id 要高 CSS3新增伪类举例： p:first-of-type 选择属于其父元素的首个 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:last-of-type 选择属于其父元素的最后 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-of-type 选择属于其父元素唯一的 &lt;p&gt; 元素的每个 &lt;p&gt; 元素。 p:only-child 选择属于其父元素的唯一子元素的每个 &lt;p&gt; 元素。 p:nth-child(2) 选择属于其父元素的第二个子元素的每个 &lt;p&gt; 元素。 :enabled :disabled 控制表单控件的禁用状态。 :checked 单选框或复选框被选中。 CSS3有哪些新特性？ CSS3实现圆角（border-radius），阴影（box-shadow）， 对文字加特效（text-shadow、），线性渐变（gradient），旋转（transform） transform:rotate(9deg) scale(0.85,0.90) translate(0px,-30px) skew(-9deg,0deg);//旋转,缩放,定位,倾斜 增加了更多的CSS选择器 多背景 rgba 在CSS3中唯一引入的伪元素是::selection. 媒体查询，多栏布局 border-image CSS3中新增了一种盒模型计算方式：box-sizing。盒模型默认的值是content-box, 新增的值是padding-box和border-box，几种盒模型计算元素宽高的区别如下： content-box（默认）布局所占宽度Width： Width = width + padding-left + padding-right + border-left + border-right 布局所占高度Height: Height = height + padding-top + padding-bottom + border-top + border-bottom padding-box布局所占宽度Width： Width = width(包含padding-left + padding-right) + border-top + border-bottom 布局所占高度Height: Height = height(包含padding-top + padding-bottom) + border-top + border-bottom border-box布局所占宽度Width： Width = width(包含padding-left + padding-right + border-left + border-right) 布局所占高度Height: Height = height(包含padding-top + padding-bottom + border-top + border-bottom) 对BFC规范的理解？ BFC，块级格式化上下文，一个创建了新的BFC的盒子是独立布局的，盒子里面的子元素的样式不会影响到外面的元素。在同一个BFC中的两个毗邻的块级盒在垂直方向（和布局方向有关系）的margin会发生折叠。 （W3C CSS 2.1 规范中的一个概念，它决定了元素如何对其内容进行布局，以及与其他元素的关系和相互作用。 说说你对语义化的理解1，去掉或者丢失样式的时候能够让页面呈现出清晰的结构 2，有利于SEO：和搜索引擎建立良好沟通，有助于爬虫抓取更多的有效信息：爬虫依赖于标签来确定上下文和各个关键字的权重； 3，方便其他设备解析（如屏幕阅读器、盲人阅读器、移动设备）以意义的方式来渲染网页； 4，便于团队开发和维护，语义化更具可读性，是下一步吧网页的重要动向，遵循W3C标准的团队都遵循这个标准，可以减少差异化。 Doctype作用? 严格模式与混杂模式如何区分？它们有何意义?1）、&lt;!DOCTYPE&gt; 声明位于文档中的最前面，处于 &lt;html&gt; 标签之前。告知浏览器以何种模式来渲染文档。 2）、严格模式的排版和 JS 运作模式是 以该浏览器支持的最高标准运行。 3）、在混杂模式中，页面以宽松的向后兼容的方式显示。模拟老式浏览器的行为以防止站点无法工作。 4）、DOCTYPE不存在或格式不正确会导致文档以混杂模式呈现。 你知道多少种Doctype文档类型？ 该标签可声明三种 DTD 类型，分别表示严格版本、过渡版本以及基于框架的 HTML 文档。 HTML 4.01 规定了三种文档类型：Strict、Transitional 以及 Frameset。 XHTML 1.0 规定了三种 XML 文档类型：Strict、Transitional 以及 Frameset。 Standards （标准）模式（也就是严格呈现模式）用于呈现遵循最新标准的网页，而 Quirks （包容）模式（也就是松散呈现模式或者兼容模式）用于呈现为传统浏览器而设计的网页。 HTML与XHTML——二者有什么区别区别： 1.所有的标记都必须要有一个相应的结束标记 2.所有标签的元素和属性的名字都必须使用小写 3.所有的XML标记都必须合理嵌套 4.所有的属性必须用引号&quot;&quot;括起来 5.把所有&lt;和&amp;特殊符号用编码表示 6.给所有属性赋一个值 7.不要在注释内容中使“--” 8.图片必须有说明文字 常见兼容性问题png24位的图片在iE6浏览器上出现背景，解决方案是做成PNG8.也可以引用一段脚本处理. 浏览器默认的margin和padding不同。解决方案是加一个全局的*{margin:0;padding:0;}来统一。 IE6双边距bug:块属性标签float后，又有横行的margin情况下，在ie6显示margin比设置的大。 浮动ie产生的双倍距离（IE6双边距问题：在IE6下，如果对元素设置了浮动，同时又设置了margin-left或margin-right，margin值会加倍。） #box{ float:left; width:10px; margin:0 0 0 100px;} 这种情况之下IE会产生20px的距离，解决方案是在float的标签样式控制中加入 _display:inline;将其转化为行内属性。(_这个符号只有ie6会识别) 渐进识别的方式，从总体中逐渐排除局部。 首先，巧妙的使用“\\9”这一标记，将IE游览器从所有情况中分离出来。 接着，再次使用“+”将IE8和IE7、IE6分离开来，这样IE8已经独立识别。 css .bb{ background-color:#f1ee18;/*所有识别*/ .background-color:#00deff\\9; /*IE6、7、8识别*/ +background-color:#a200ff;/*IE6、7识别*/ _background-color:#1e0bd1;/*IE6识别*/ } 怪异模式问题：漏写DTD声明，Firefox仍然会按照标准模式来解析网页，但在IE中会触发 怪异模式。为避免怪异模式给我们带来不必要的麻烦，最好养成书写DTD声明的好习惯。现在 可以使用[html5](http://www.w3.org/TR/html5/single-page.html)推荐的写法：`&lt;doctype html&gt;` 上下margin重合问题 ie和ff都存在，相邻的两个div的margin-left和margin-right不会重合，但是margin-top和margin-bottom却会发生重合。 解决方法，养成良好的代码编写习惯，同时采用margin-top或者同时采用margin-bottom。 解释下浮动和它的工作原理？清除浮动的技巧浮动元素脱离文档流，不占据空间。浮动元素碰到包含它的边框或者浮动元素的边框停留。 1.使用空标签清除浮动。 这种方法是在所有浮动标签后面添加一个空标签 定义css clear:both. 弊端就是增加了无意义标签。 2.使用overflow。 给包含浮动元素的父标签添加css属性 overflow:auto; zoom:1; zoom:1用于兼容IE6。 3.使用after伪对象清除浮动。 该方法只适用于非IE浏览器。具体写法可参照以下示例。使用中需注意以下几点。一、该方法中必须为需要清除浮动元素的伪对象中设置 height:0，否则该元素会比实际高出若干像素； 浮动元素引起的问题和解决办法？浮动元素引起的问题： （1）父元素的高度无法被撑开，影响与父元素同级的元素 （2）与浮动元素同级的非浮动元素（内联元素）会跟随其后 （3）若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 解决方法： 使用CSS中的clear:both;属性来清除元素的浮动可解决2、3问题，对于问题1，添加如下样式，给父元素添加clearfix样式： .clearfix:after{content: &quot;.&quot;;display: block;height: 0;clear: both;visibility: hidden;} .clearfix{display: inline-block;} /* for IE/Mac */ 清除浮动的几种方法： 1，额外标签法，&lt;div style=&quot;clear:both;&quot;&gt;&lt;/div&gt;（缺点：不过这个办法会增加额外的标签使HTML结构看起来不够简洁。） 2，使用after伪类 #parent:after{ content:&quot;.&quot;; height:0; visibility:hidden; display:block; clear:both; } 3,浮动外部元素 4,设置overflow为hidden或者auto DOM操作——怎样添加、移除、移动、复制、创建和查找节点。 1）创建新节点 createDocumentFragment() //创建一个DOM片段 createElement() //创建一个具体的元素 createTextNode() //创建一个文本节点 2）添加、移除、替换、插入 appendChild() removeChild() replaceChild() insertBefore() //并没有insertAfter() 3）查找 getElementsByTagName() //通过标签名称 getElementsByName() //通过元素的Name属性的值(IE容错能力较强， 会得到一个数组，其中包括id等于name值的) getElementById() //通过元素Id，唯一性 html5有哪些新特性、移除了那些元素？如何处理HTML5新标签的浏览器兼容问题？如何区分 HTML 和 HTML5？ HTML5 现在已经不是 SGML 的子集，主要是关于图像，位置，存储，多任务等功能的增加。 拖拽释放(Drag and drop) API 语义化更好的内容标签（header,nav,footer,aside,article,section） 音频、视频API(audio,video) 画布(Canvas) API 地理(Geolocation) API 本地离线存储 localStorage 长期存储数据，浏览器关闭后数据不丢失； sessionStorage 的数据在浏览器关闭后自动删除 表单控件，calendar、date、time、email、url、search 新的技术webworker, websocket, Geolocation 移除的元素 纯表现的元素：basefont，big，center，font, s，strike，tt，u； 对可用性产生负面影响的元素：frame，frameset，noframes； 支持HTML5新标签： IE8/IE7/IE6支持通过document.createElement方法产生的标签， 可以利用这一特性让这些浏览器支持HTML5新标签， 当然最好的方式是直接使用成熟的框架、使用最多的是html5shim框架 &lt;!--[if lt IE 9]&gt; &lt;script&gt; src=&quot;http://html5shim.googlecode.com/svn/trunk/html5.js&quot;&lt;/script&gt; &lt;![endif]--&gt; 如何区分： DOCTYPE声明\\新增的结构元素\\功能元素 如何实现浏览器内多个标签页之间的通信? 调用localstorge、cookies等本地存储方式 什么是 FOUC（无样式内容闪烁）？你如何来避免 FOUC？ FOUC - Flash Of Unstyled Content 文档样式闪烁 &lt;style type=&quot;text/css&quot; media=&quot;all&quot;&gt;@import &quot;../fouc.css&quot;;&lt;/style&gt; 而引用CSS文件的@import就是造成这个问题的罪魁祸首。IE会先加载整个HTML文档的DOM，然后再去导入外部的CSS文件，因此，在页面DOM加载完成到CSS导入完成中间会有一段时间页面上的内容是没有样式的，这段时间的长短跟网速，电脑速度都有关系。 解决方法简单的出奇，只要在&lt;head&gt;之间加入一个&lt;link&gt;或者&lt;script&gt;元素就可以了。 null和undefined的区别null是一个表示”无”的对象，转为数值时为0；undefined是一个表示”无”的原始值，转为数值时为NaN。 当声明的变量还未被初始化时，变量的默认值为undefined。 null用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。 undefined表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是： （1）变量被声明了，但没有赋值时，就等于undefined。 （2) 调用函数时，应该提供的参数没有提供，该参数等于undefined。 （3）对象没有赋值的属性，该属性的值为undefined。 （4）函数没有返回值时，默认返回undefined。 null表示”没有对象”，即该处不应该有值。典型用法是： （1） 作为函数的参数，表示该函数的参数不是对象。 （2） 作为对象原型链的终点。 new操作符具体干了什么呢 1、创建一个空对象，并且 this 变量引用该对象，同时还继承了该函数的原型。 2、属性和方法被加入到 this 引用的对象中。 3、新创建的对象由 this 所引用，并且最后隐式的返回 this 。 var obj = {}; obj.__proto__ = Base.prototype; Base.call(obj); js延迟加载的方式有哪些？defer和async、动态创建DOM方式（创建script，插入到DOM中，加载完毕后callBack）、按需异步载入js call() 和 apply()的区别和作用？作用：动态改变某个类的某个方法的运行环境（执行上下文）。 区别参见：[JavaScript学习总结（四）function函数部分][3] 哪些操作会造成内存泄漏？内存泄漏指任何对象在您不再拥有或需要它之后仍然存在。 垃圾回收器定期扫描对象，并计算引用了每个对象的其他对象的数量。如果一个对象的引用数量为 0（没有其他对象引用过该对象），或对该对象的惟一引用是循环的，那么该对象的内存即可回收。 setTimeout 的第一个参数使用字符串而非函数的话，会引发内存泄漏。 闭包、控制台日志、循环（在两个对象彼此引用且彼此保留时，就会产生一个循环） 详见：[详解js变量、作用域及内存][4] 列举IE 与其他浏览器不一样的特性？ IE支持currentStyle，FIrefox使用getComputStyle IE 使用innerText，Firefox使用textContent 滤镜方面：IE:filter:alpha(opacity= num)；Firefox：-moz-opacity:num 事件方面：IE：attachEvent：火狐是addEventListener 鼠标位置：IE是event.clientX；火狐是event.pageX IE使用event.srcElement；Firefox使用event.target IE中消除list的原点仅需margin:0即可达到最终效果；FIrefox需要设置margin:0;padding:0以及list-style:none CSS圆角：ie7以下不支持圆角 WEB应用从服务器主动推送Data到客户端有那些方式？Javascript数据推送 Commet：基于HTTP长连接的服务器推送技术 基于WebSocket的推送方案 SSE（Server-Send Event）：服务器推送数据新方式 对前端界面工程师这个职位是怎么样理解的？它的前景会怎么样？前端是最贴近用户的程序员，比后端、数据库、产品经理、运营、安全都近。 1、实现界面交互 2、提升用户体验 3、有了Node.js，前端可以实现服务端的一些事情 前端是最贴近用户的程序员，前端的能力就是能让产品从 90分进化到 100 分，甚至更好， 参与项目，快速高质量完成实现效果图，精确到1px； 与团队成员，UI设计，产品经理的沟通； 做好的页面结构，页面重构和用户体验； 处理hack，兼容、写出优美的代码格式； 针对服务器的优化、拥抱最新前端技术。 一个页面从输入 URL 到页面加载显示完成，这个过程中都发生了什么？ 分为4个步骤： （1），当发送一个URL请求时，不管这个URL是Web页面的URL还是Web页面上每个资源的URL，浏览器都会开启一个线程来处理这个请求，同时在远程DNS服务器上启动一个DNS查询。这能使浏览器获得请求对应的IP地址。 （2）， 浏览器与远程`Web`服务器通过`TCP`三次握手协商来建立一个`TCP/IP`连接。该握手包括一个同步报文，一个同步-应答报文和一个应答报文，这三个报文在 浏览器和服务器之间传递。该握手首先由客户端尝试建立起通信，而后服务器应答并接受客户端的请求，最后由客户端发出该请求已经被接受的报文。 （3），一旦`TCP/IP`连接建立，浏览器会通过该连接向远程服务器发送`HTTP`的`GET`请求。远程服务器找到资源并使用HTTP响应返回该资源，值为200的HTTP响应状态表示一个正确的响应。 （4），此时，`Web`服务器提供资源服务，客户端开始下载资源。 请求返回后，便进入了我们关注的前端模块 简单来说，浏览器会解析`HTML`生成`DOM Tree`，其次会根据CSS生成CSS Rule Tree，而`javascript`又可以根据`DOM API`操作`DOM` 详情：[从输入 URL 到浏览器接收的过程中发生了什么事情？][8] javascript对象的几种创建方式1，工厂模式 2，构造函数模式 3，原型模式 4，混合构造函数和原型模式 5，动态原型模式 6，寄生构造函数模式 7，稳妥构造函数模式 javascript继承的6种方法1，原型链继承 2，借用构造函数继承 3，组合继承(原型+借用构造) 4，原型式继承 5，寄生式继承 6，寄生组合式继承 详情：[JavaScript继承方式详解][9] 创建ajax的过程 (1)创建`XMLHttpRequest`对象,也就是创建一个异步调用对象. (2)创建一个新的`HTTP`请求,并指定该`HTTP`请求的方法、`URL`及验证信息. (3)设置响应`HTTP`请求状态变化的函数. (4)发送`HTTP`请求. (5)获取异步调用返回的数据. (6)使用JavaScript和DOM实现局部刷新. var xmlHttp = new XMLHttpRequest(); xmlHttp.open(&#39;GET&#39;,&#39;demo.php&#39;,&#39;true&#39;); xmlHttp.send() xmlHttp.onreadystatechange = function(){ if(xmlHttp.readyState === 4 &amp; xmlHttp.status === 200){ } } 详情：[JavaScript学习总结（七）Ajax和Http状态字][10] 异步加载和延迟加载1.异步加载的方案： 动态插入script标签 2.通过ajax去获取js代码，然后通过eval执行 3.script标签上添加defer或者async属性 4.创建并插入iframe，让它异步执行js 5.延迟加载：有些 js 代码并不是页面初始化的时候就立刻需要的，而稍后的某些情况才需要的。 ie各版本和chrome可以并行下载多少个资源IE6 两个并发，iE7升级之后的6个并发，之后版本也是6个 Firefox，chrome也是6个 Flash、Ajax各自的优缺点，在使用中如何取舍？ Flash适合处理多媒体、矢量图形、访问机器；对CSS、处理文本上不足，不容易被搜索。 -Ajax对CSS、文本支持很好，支持搜索；多媒体、矢量图形、机器访问不足。 共同点：与服务器的无刷新传递消息、用户离线和在线状态、操作DOM 请解释一下 JavaScript 的同源策略。概念:同源策略是客户端脚本（尤其是Javascript）的重要的安全度量标准。它最早出自Netscape Navigator2.0，其目的是防止某个文档或脚本从多个不同源装载。 这里的同源策略指的是：协议，域名，端口相同，同源策略是一种安全协议。 指一段脚本只能读取来自同一来源的窗口和文档的属性。 为什么要有同源限制 我们举例说明：比如一个黑客程序，他利用Iframe把真正的银行登录页面嵌到他的页面上，当你使用真实的用户名，密码登录时，他的页面就可以通过Javascript读取到你的表单中input中的内容，这样用户名，密码就轻松到手了。 缺点： 现在网站的JS 都会进行压缩，一些文件用了严格模式，而另一些没有。这时这些本来是严格模式的文件，被 merge 后，这个串就到了文件的中间，不仅没有指示严格模式，反而在压缩后浪费了字节。 GET和POST的区别，何时使用POST？ GET：一般用于信息获取，使用URL传递参数，对所发送信息的数量也有限制，一般在2000个字符 POST：一般用于修改服务器上的资源，对所发送的信息没有限制。 GET方式需要使用Request.QueryString来取得变量的值，而POST方式通过Request.Form来获取变量的值， 也就是说Get是通过地址栏来传值，而Post是通过提交表单来传值。 然而，在以下情况中，请使用 POST 请求： 无法使用缓存文件（更新服务器上的文件或数据库） 向服务器发送大量数据（POST 没有数据量限制） 发送包含未知字符的用户输入时，POST 比 GET 更稳定也更可靠 事件、IE与火狐的事件机制有什么区别？ 如何阻止冒泡？ 1. 我们在网页中的某个操作（有的操作对应多个事件）。例如：当我们点击一个按钮就会产生一个事件。是可以被 JavaScript 侦测到的行为。 2. 事件处理机制：IE是事件冒泡、firefox同时支持两种事件模型，也就是：捕获型事件和冒泡型事件。； 3. `ev.stopPropagation()`;注意旧ie的方法 `ev.cancelBubble = true`; ajax的缺点和在IE下的问题？详情请见：[JavaScript学习总结（七）Ajax和Http状态字][14] ajax的缺点 1、ajax不支持浏览器back按钮。 2、安全问题 AJAX暴露了与服务器交互的细节。 3、对搜索引擎的支持比较弱。 4、破坏了程序的异常机制。 5、不容易调试。 IE缓存问题 在IE浏览器下，如果请求的方法是GET，并且请求的URL不变，那么这个请求的结果就会被缓存。解决这个问题的办法可以通过实时改变请求的URL，只要URL改变，就不会被缓存，可以通过在URL末尾添加上随机的时间戳参数(&#39;t&#39;= + new Date().getTime()) 或者： open(&#39;GET&#39;,&#39;demo.php?rand=+Math.random()&#39;,true);// Ajax请求的页面历史记录状态问题 可以通过锚点来记录状态，location.hash。让浏览器记录Ajax请求时页面状态的变化。 还可以通过HTML5的history.pushState，来实现浏览器地址栏的无刷新改变 谈谈你对重构的理解网站重构：在不改变外部行为的前提下，简化结构、添加可读性，而在网站前端保持一致的行为。也就是说是在不改变UI的情况下，对网站进行优化，在扩展的同时保持一致的UI。 对于传统的网站来说重构通常是： 表格(table)布局改为DIV+CSS 使网站前端兼容于现代浏览器(针对于不合规范的CSS、如对IE6有效的) 对于移动平台的优化 针对于SEO进行优化 深层次的网站重构应该考虑的方面 减少代码间的耦合 让代码保持弹性 严格按规范编写代码 设计可扩展的API 代替旧有的框架、语言(如VB) 增强用户体验 通常来说对于速度的优化也包含在重构中 压缩JS、CSS、image等前端资源(通常是由服务器来解决) 程序的性能优化(如数据读写) 采用CDN来加速资源加载 对于JS DOM的优化 HTTP服务器的文件缓存 HTTP状态码 100 Continue 继续，一般在发送post请求时，已发送了http header之后服务端将返回此信息，表示确认，之后发送具体参数信息 200 OK 正常返回信息 201 Created 请求成功并且服务器创建了新的资源 202 Accepted 服务器已接受请求，但尚未处理 301 Moved Permanently 请求的网页已永久移动到新位置。 302 Found 临时性重定向。 303 See Other 临时性重定向，且总是使用 GET 请求新的 URI。 304 Not Modified 自从上次请求后，请求的网页未修改过。 400 Bad Request 服务器无法理解请求的格式，客户端不应当尝试再次使用相同的内容发起请求。 401 Unauthorized 请求未授权。 403 Forbidden 禁止访问。 404 Not Found 找不到如何与 URI 相匹配的资源。 500 Internal Server Error 最常见的服务器端错误。 503 Service Unavailable 服务器端暂时无法处理请求（可能是过载或维护）。 说说你对Promise的理解依照 Promise/A+ 的定义，Promise 有四种状态： pending: 初始状态, 非 fulfilled 或 rejected. fulfilled: 成功的操作. rejected: 失败的操作. settled: Promise已被fulfilled或rejected，且不是pending 另外， fulfilled 与 rejected 一起合称 settled。 Promise 对象用来进行延迟(deferred) 和异步(asynchronous ) 计算。 Promise 的构造函数 构造一个 Promise，最基本的用法如下： var promise = new Promise(function(resolve, reject) { if (...) { // succeed resolve(result); } else { // fails reject(Error(errMessage)); } }); Promise 实例拥有 then 方法（具有 then 方法的对象，通常被称为 thenable）。它的使用方法如下： promise.then(onFulfilled, onRejected) 接收两个函数作为参数，一个在 fulfilled 的时候被调用，一个在 rejected 的时候被调用，接收参数就是 future，onFulfilled 对应 resolve, onRejected 对应 reject。 说说你对前端架构师的理解负责前端团队的管理及与其他团队的协调工作，提升团队成员能力和整体效率；带领团队完成研发工具及平台前端部分的设计、研发和维护；带领团队进行前端领域前沿技术研究及新技术调研，保证团队的技术领先负责前端开发规范制定、功能模块化设计、公共组件搭建等工作，并组织培训。 实现一个函数clone，可以对JavaScript中的5种主要的数据类型（包括Number、String、Object、Array、Boolean）进行值复制 Object.prototype.clone = function(){ var o = this.constructor === Array ? [] : {}; for(var e in this){ o[e] = typeof this[e] === &quot;object&quot; ? this[e].clone() : this[e]; } return o; } 说说严格模式的限制严格模式主要有以下限制： 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 设立”严格模式”的目的，主要有以下几个： 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为; 消除代码运行的一些不安全之处，保证代码运行的安全； 提高编译器效率，增加运行速度； 为未来新版本的Javascript做好铺垫。 注：经过测试IE6,7,8,9均不支持严格模式。 如何删除一个cookie 1.将时间设为当前时间往前一点。 var date = new Date(); date.setDate(date.getDate() - 1);//真正的删除 setDate()方法用于设置一个月的某一天。 2.expires的设置 document.cookie = &#39;user=&#39;+ encodeURIComponent(&#39;name&#39;) + &#39;;expires = &#39; + new Date(0) ，和，标签&lt;strong&gt; 标签和 &lt;em&gt; 标签一样，用于强调文本，但它强调的程度更强一些。 em 是 斜体强调标签，更强烈强调，表示内容的强调点。相当于html元素中的 &lt;i&gt;...&lt;/i&gt;; &lt; b &gt; &lt; i &gt;是视觉要素，分别表示无意义的加粗，无意义的斜体。 em 和 strong 是表达要素(phrase elements)。 对AMD和Commonjs的理解CommonJS是服务器端模块的规范，Node.js采用了这个规范。CommonJS规范加载模块是同步的，也就是说，只有加载完成，才能执行后面的操作。AMD规范则是非同步加载模块，允许指定回调函数。 AMD推荐的风格通过返回一个对象做为模块对象，CommonJS的风格通过对module.exports或exports的属性赋值来达到暴露模块对象的目的。 详情：也谈webpack及其开发模式 document.write()的用法document.write()方法可以用在两个方面：页面载入过程中用实时脚本创建页面内容，以及用延时脚本创建本窗口或新窗口的内容。 document.write只能重绘整个页面。innerHTML可以重绘页面的一部分 编写一个方法 求一个字符串的字节长度假设：一个英文字符占用一个字节，一个中文字符占用两个字节 function GetBytes(str){ var len = str.length; var bytes = len; for(var i=0; i&lt;len; i++){ if (str.charCodeAt(i) &gt; 255) bytes++; } return bytes; } alert(GetBytes(&quot;你好,as&quot;)); git fetch和git pull的区别git pull：相当于是从远程获取最新版本并merge到本地 git fetch：相当于是从远程获取最新版本到本地，不会自动merge 说说你对MVC和MVVM的理解 MVC View 传送指令到 Controller Controller 完成业务逻辑后，要求 Model 改变状态 Model 将新的数据发送到 View，用户得到反馈 所有通信都是单向的。 Angular它采用双向绑定（data-binding）：View的变动，自动反映在 ViewModel，反之亦然。 组成部分Model、View、ViewModel View：UI界面 ViewModel：它是View的抽象，负责View与Model之间信息转换，将View的Command传送到Model； Model：数据访问层 请解释什么是事件代理事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。使用事件代理的好处是可以提高性能。 attribute和property的区别是什么？attribute是dom元素在文档中作为html标签拥有的属性； property就是dom元素在js中作为对象拥有的属性。 所以： 对于html的标准属性来说，attribute和property是同步的，是会自动更新的， 但是对于自定义的属性来说，他们是不同步的， 说说网络分层里七层模型是哪七层 应用层：应用层、表示层、会话层（从上往下）（HTTP、FTP、SMTP、DNS） 传输层（TCP和UDP） 网络层（IP） 物理和数据链路层（以太网） 每一层的作用如下： 物理层：通过媒介传输比特,确定机械及电气规范（比特Bit） 数据链路层：将比特组装成帧和点到点的传递（帧Frame） 网络层：负责数据包从源到宿的传递和网际互连（包PackeT） 传输层：提供端到端的可靠报文传递和错误恢复（段Segment） 会话层：建立、管理和终止会话（会话协议数据单元SPDU） 表示层：对数据进行翻译、加密和压缩（表示协议数据单元PPDU） 应用层：允许访问OSI环境的手段（应用协议数据单元APDU） 各种协议 ICMP协议： 因特网控制报文协议。它是TCP/IP协议族的一个子协议，用于在IP主机、路由器之间传递控制消息。TFTP协议： 是TCP/IP协议族中的一个用来在客户机与服务器之间进行简单文件传输的协议，提供不复杂、开销不大的文件传输服务。HTTP协议： 超文本传输协议，是一个属于应用层的面向对象的协议，由于其简捷、快速的方式，适用于分布式超媒体信息系统。DHCP协议： 动态主机配置协议，是一种让系统得以连接到网络上，并获取所需要的配置参数手段。 说说mongoDB和MySQL的区别MySQL是传统的关系型数据库，MongoDB则是非关系型数据库 mongodb以BSON结构（二进制）进行存储，对海量数据存储有着很明显的优势。 对比传统关系型数据库,NoSQL有着非常显著的性能和扩展性优势，与关系型数据库相比，MongoDB的优点有：①弱一致性（最终一致），更能保证用户的访问速度：②文档结构的存储方式，能够更便捷的获取数据。 304缓存的原理服务器首先产生ETag，服务器可在稍后使用它来判断页面是否已经被修改。本质上，客户端通过将该记号传回服务器要求服务器验证其（客户端）缓存。 304是HTTP状态码，服务器用来标识这个文件没修改，不返回内容，浏览器在接收到个状态码后，会使用浏览器已缓存的文件 客户端请求一个页面（A）。 服务器返回页面A，并在给A加上一个ETag。 客户端展现该页面，并将页面连同ETag一起缓存。 客户再次请求页面A，并将上次请求时服务器返回的ETag一起传递给服务器。 服务器检查该ETag，并判断出该页面自上次客户端请求之后还未被修改，直接返回响应304（未修改——Not Modified）和一个空的响应体。 什么样的前端代码是好高复用低耦合，这样文件小，好维护，而且好扩展。 本文旨在加深对前端知识点的理解，资料来源于网络,感谢每一个贡献者。 更多👉前端开发面试题集锦👉GitHub：https://github.com/microzz","tags":[{"name":"前端","slug":"前端","permalink":"https://microzz.com/tags/前端/"},{"name":"面试","slug":"面试","permalink":"https://microzz.com/tags/面试/"},{"name":"求职","slug":"求职","permalink":"https://microzz.com/tags/求职/"}]},{"title":"JavaScript中手动模拟创建Iterators迭代器(遍历器)","date":"2017-01-29T12:58:35.000Z","path":"2017/01/29/iterators-test/","text":"&nbsp;&nbsp;&nbsp;Generator函数是ES6提供的一种异步编程解决方案，具体请看Generator函数教程。Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。&nbsp;&nbsp;&nbsp;执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。 JavaScript中如何手动模拟创建Iterators迭代器(遍历器)通过代码实现，具体如下/** * JavaScript中手动模拟创建Iterators迭代器 */ function Iterators(args) { let i = 0; return { next() { let done = (i &gt;= args.length - 1); let value = args[i++]; return { value: value, done: done } } } } //进行测试验证结果 let test = Iterators([&#39;microzz&#39;, &#39;涵月天&#39;, &#39;IT技术分享&#39;]); console.log(test.next()); // { value: &#39;microzz&#39;, done: false } console.log(test.next()); // { value: &#39;涵月天&#39;, done: false } console.log(test.next()); // { value: &#39;IT技术分享&#39;, done: true } console.log(test.next()); // { value: undefined, done: true }","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Iterators","slug":"Iterators","permalink":"https://microzz.com/tags/Iterators/"}]},{"title":"JavaScript自定义方法实现复杂对象的深拷贝","date":"2017-01-26T11:11:02.000Z","path":"2017/01/26/deep-copy/","text":"JavaScript自定义方法实现复杂对象的深拷贝ES6中的Object.assign方法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ES6中新增Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 ❗️注意点: &nbsp;&nbsp;&nbsp;&nbsp;Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 实现所以我们可以自己动手来手工实现复杂对象的深拷贝方法，具体实现有如下两种方法： 方法1⃣️/** * 自定义方法实现复杂对象的深拷贝 */ function deepCopy(obj) { let copy = {}; // 如果是基本类型直接赋值， // 如果是数组则拷贝， // 其他对象则递归调用deepCopy方法 Object.keys(obj).forEach(key =&gt; { if (obj[key] instanceof Array) { copy[key] = Array.from(obj[key]); } else if (typeof obj[key] === &#39;object&#39;) { copy[key] = deepCopy(obj[key]); } else { copy[key] = obj[key]; } }) return copy; } 方法2⃣️function deepCopy(obj) { return JSON.parse(JSON.stringify(obj)); } 验证&nbsp;&nbsp;以上通过两种方法实现了对象的深拷贝，下面通过数据进行简单验证: //自定义一个复杂数据对象 let data = { name: &#39;Zhao&#39;, age: 22, url: &#39;https://microzz.com&#39;, scores:{ math: 66, java: 88, test: [1, 2, 3] }, skills: [&#39;Node.js&#39;, &#39;ReactJS&#39;, &#39;ES6&#39;], say() { console.log(`My name is ${this.name}`) } } //进行深拷贝，把数据保存在copyData let copyData = deepCopy(data); //对copyData进行修改，看是否对原数据有影响 copyData.name = &#39;Hui&#39;; copyData.scores.math = 99; copyData.scores.test[1] = 100; copyData.skills[2] = &#39;ES5&#39;; copyData.say = function () { console.log(`Copy: My name is ${this.name}`); } //打印输出查看结果进行验证 console.log(data); /* { name: &#39;Zhao&#39;, age: 22, url: &#39;http://microzz.com&#39;, scores: { math: 66, java: 88, test: [ 1, 2, 3 ] }, skills: [ &#39;Node.js&#39;, &#39;ReactJS&#39;, &#39;ES6&#39; ], say: [Function: say] } */ console.log(copyData); /* { name: &#39;Hui&#39;, age: 22, url: &#39;http://microzz.com&#39;, scores: { math: 99, java: 88, test: [ 1, 100, 3 ] }, skills: [ &#39;Node.js&#39;, &#39;ReactJS&#39;, &#39;ES5&#39; ], say: [Function] } */ data.say(); // My name is Zhao copyData.say(); // Copy: My name is Hui &nbsp;&nbsp;&nbsp;&nbsp;两种方法的结果均一致，实现了对象的深拷贝，但是第二种方法通过原生的JSON.parse和JSON.stringify方法更为简单易懂。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"深拷贝","slug":"深拷贝","permalink":"https://microzz.com/tags/深拷贝/"}]},{"title":"ES6中嵌套的对象如何解构(Destructuring)","date":"2017-01-24T11:17:51.000Z","path":"2017/01/24/destructuringTest/","text":"ES6中嵌套的对象如何解构 对于普通对象的解构大家应该没什么问题(详细学习ES6的解构知识请看这里👉 变量的解构赋值(Destructuring) )，但是遇到复杂对象结构的应该如何处理呢？可以看下面的示例。 //声明一个对象保存信息 let jsonData = { name: &#39;Zhao&#39;, age: 22, score: { Chinese: 77, math: 99 } } //对嵌套结构的对象进行解构1 let {name, age, score:{Chinese, math}} = jsonData; console.log(`name is ${name}`); //name is Zhao console.log(`age is ${age}`); //age is 22 console.log(`Chinese score is ${Chinese}`); //Chinese score is 77 console.log(`math score is ${math}`); //math score is 99 //另外一个例子😄 let obj = { p: [ &#39;Hello&#39;, { y: &#39;World&#39; } ] }; //对嵌套结构的对象进行解构2 let { p: [x, { y }] } = obj; console.log(`x is ${x}`); // x is Hello console.log(`y is ${y}`); // y is World","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Destructuring","slug":"Destructuring","permalink":"https://microzz.com/tags/Destructuring/"}]},{"title":"JavaScript通过原型设计一个事件对象","date":"2017-01-21T14:13:02.000Z","path":"2017/01/21/listener-event/","text":"JavaScript通过原型设计一个事件对象实现以下功能： 添加监听者 移除监听者 清空监听者 发起事件信号 设计思路如下： 定义一个对象，包含一个实例成员listeners，用于记录所有的监听者为对象的原型增加，新增、删除、清空和执行四个成员具体代码可以参见下面示例 代码实现function myEvent(){ this.listeners = []; //监听者列表 } //添加一个监听者 myEvent.prototype.addListener = function(fn){ this.listeners.push(fn); }; //除移一个监听者 myEvent.prototype.removeListener = function(fn){ var index = this.listeners.indexOf(fn); this.listeners.splice(index,1); }; //清除所有监听者 myEvent.prototype.clearListeners = function(){ this.listeners = []; }; //发出执行信号，并告之所有监听者 myEvent.prototype.raise = function(e){ var l = this.listeners.length; for(var i = 0; i &lt; l; i++){ this.listeners[i](e); //执行所有监听方法 } }; var me = new myEvent(); //事件fun1 function fun1(e) { console.log(&#39;fun1: &#39; + e); } //事件fun2 function fun2(e) { console.log(&#39;fun2: &#39; + e); } //调用相关方法进行测试 me.addListener(fun1); me.addListener(fun2); me.removeListener(fun1) //me.clearListeners(); me.raise(&quot;a&quot;);","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"事件","slug":"事件","permalink":"https://microzz.com/tags/事件/"},{"name":"event","slug":"event","permalink":"https://microzz.com/tags/event/"},{"name":"原型","slug":"原型","permalink":"https://microzz.com/tags/原型/"}]},{"title":"ES6 Module","date":"2017-01-18T09:01:23.000Z","path":"2017/01/18/module/","text":"Module历史上，JavaScript 一直没有模块（module）体系，无法将一个大程序拆分成互相依赖的小文件，再用简单的方法拼装起来。其他语言都有这项功能，比如 Ruby 的require、Python 的import，甚至就连 CSS 都有@import，但是 JavaScript 任何这方面的支持都没有，这对开发大型的、复杂的项目形成了巨大障碍。 在 ES6 之前，社区制定了一些模块加载方案，最主要的有 CommonJS 和 AMD 两种。前者用于服务器，后者用于浏览器。ES6 在语言标准的层面上，实现了模块功能，而且实现得相当简单，完全可以取代现有的 CommonJS 和 AMD 规范，成为浏览器和服务器通用的模块解决方案。 ES6 模块的设计思想，是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的变量。CommonJS 和 AMD 模块，都只能在运行时确定这些东西。比如，CommonJS 模块就是对象，输入时必须查找对象属性。 // CommonJS模块 let { stat, exists, readFile } = require(&#39;fs&#39;); // 等同于 let _fs = require(&#39;fs&#39;); let stat = _fs.stat, exists = _fs.exists, readfile = _fs.readfile; 上面代码的实质是整体加载fs模块（即加载fs的所有方法），生成一个对象（_fs），然后再从这个对象上面读取3个方法。这种加载称为“运行时加载”，因为只有运行时才能得到这个对象，导致完全没办法在编译时做“静态优化”。 ES6 模块不是对象，而是通过export命令显式指定输出的代码，再通过import命令输入。 // ES6模块 import { stat, exists, readFile } from &#39;fs&#39;; 上面代码的实质是从fs模块加载3个方法，其他方法不加载。这种加载称为“编译时加载”或者静态加载，即 ES6 可以在编译时就完成模块加载，效率要比 CommonJS 模块的加载方式高。当然，这也导致了没法引用 ES6 模块本身，因为它不是对象。 由于 ES6 模块是编译时加载，使得静态分析成为可能。有了它，就能进一步拓宽 JavaScript 的语法，比如引入宏（macro）和类型检验（type system）这些只能靠静态分析实现的功能。 除了静态加载带来的各种好处，ES6 模块还有以下好处。 不再需要UMD模块格式了，将来服务器和浏览器都会支持 ES6 模块格式。目前，通过各种工具库，其实已经做到了这一点。 将来浏览器的新 API 就能用模块格式提供，不再必须做成全局变量或者navigator对象的属性。 不再需要对象作为命名空间（比如Math对象），未来这些功能可以通过模块提供。 严格模式ES6 的模块自动采用严格模式，不管你有没有在模块头部加上&quot;use strict&quot;;。 严格模式主要有以下限制。 变量必须声明后再使用 函数的参数不能有同名属性，否则报错 不能使用with语句 不能对只读属性赋值，否则报错 不能使用前缀0表示八进制数，否则报错 不能删除不可删除的属性，否则报错 不能删除变量delete prop，会报错，只能删除属性delete global[prop] eval不会在它的外层作用域引入变量 eval和arguments不能被重新赋值 arguments不会自动反映函数参数的变化 不能使用arguments.callee 不能使用arguments.caller 禁止this指向全局对象 不能使用fn.caller和fn.arguments获取函数调用的堆栈 增加了保留字（比如protected、static和interface） 上面这些限制，模块都必须遵守。由于严格模式是 ES5 引入的，不属于 ES6，所以请参阅相关 ES5 书籍，本书不再详细介绍了。 export 命令模块功能主要由两个命令构成：export和import。export命令用于规定模块的对外接口，import命令用于输入其他模块提供的功能。 一个模块就是一个独立的文件。该文件内部的所有变量，外部无法获取。如果你希望外部能够读取模块内部的某个变量，就必须使用export关键字输出该变量。下面是一个 JS 文件，里面使用export命令输出变量。 // profile.js export var firstName = &#39;Michael&#39;; export var lastName = &#39;Jackson&#39;; export var year = 1958; 上面代码是profile.js文件，保存了用户信息。ES6将其视为一个模块，里面用export命令对外部输出了三个变量。 export的写法，除了像上面这样，还有另外一种。 // profile.js var firstName = &#39;Michael&#39;; var lastName = &#39;Jackson&#39;; var year = 1958; export {firstName, lastName, year}; 上面代码在export命令后面，使用大括号指定所要输出的一组变量。它与前一种写法（直接放置在var语句前）是等价的，但是应该优先考虑使用这种写法。因为这样就可以在脚本尾部，一眼看清楚输出了哪些变量。 export命令除了输出变量，还可以输出函数或类（class）。 export function multiply(x, y) { return x * y; }; 上面代码对外输出一个函数multiply。 通常情况下，export输出的变量就是本来的名字，但是可以使用as关键字重命名。 function v1() { ... } function v2() { ... } export { v1 as streamV1, v2 as streamV2, v2 as streamLatestVersion }; 上面代码使用as关键字，重命名了函数v1和v2的对外接口。重命名后，v2可以用不同的名字输出两次。 需要特别注意的是，export命令规定的是对外的接口，必须与模块内部的变量建立一一对应关系。 // 报错 export 1; // 报错 var m = 1; export m; 上面两种写法都会报错，因为没有提供对外的接口。第一种写法直接输出1，第二种写法通过变量m，还是直接输出1。1只是一个值，不是接口。正确的写法是下面这样。 // 写法一 export var m = 1; // 写法二 var m = 1; export {m}; // 写法三 var n = 1; export {n as m}; 上面三种写法都是正确的，规定了对外的接口m。其他脚本可以通过这个接口，取到值1。它们的实质是，在接口名与模块内部变量之间，建立了一一对应的关系。 同样的，function和class的输出，也必须遵守这样的写法。 // 报错 function f() {} export f; // 正确 export function f() {}; // 正确 function f() {} export {f}; 另外，export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。 export var foo = &#39;bar&#39;; setTimeout(() =&gt; foo = &#39;baz&#39;, 500); 上面代码输出变量foo，值为bar，500毫秒之后变成baz。 这一点与CommonJS规范完全不同。CommonJS模块输出的是值的缓存，不存在动态更新，详见下文《ES6模块加载的实质》一节。 最后，export命令可以出现在模块的任何位置，只要处于模块顶层就可以。如果处于块级作用域内，就会报错，下一节的import命令也是如此。这是因为处于条件代码块之中，就没法做静态优化了，违背了ES6模块的设计初衷。 function foo() { export default &#39;bar&#39; // SyntaxError } foo() 上面代码中，export语句放在函数之中，结果报错。 import 命令使用export命令定义了模块的对外接口以后，其他 JS 文件就可以通过import命令加载这个模块。 // main.js import {firstName, lastName, year} from &#39;./profile&#39;; function setName(element) { element.textContent = firstName + &#39; &#39; + lastName; } 上面代码的import命令，用于加载profile.js文件，并从中输入变量。import命令接受一对大括号，里面指定要从其他模块导入的变量名。大括号里面的变量名，必须与被导入模块（profile.js）对外接口的名称相同。 如果想为输入的变量重新取一个名字，import命令要使用as关键字，将输入的变量重命名。 import { lastName as surname } from &#39;./profile&#39;; import后面的from指定模块文件的位置，可以是相对路径，也可以是绝对路径，.js路径可以省略。如果只是模块名，不带有路径，那么必须有配置文件，告诉 JavaScript 引擎该模块的位置。 import {myMethod} from &#39;util&#39;; 上面代码中，util是模块文件名，由于不带有路径，必须通过配置，告诉引擎怎么取到这个模块。 注意，import命令具有提升效果，会提升到整个模块的头部，首先执行。 foo(); import { foo } from &#39;my_module&#39;; 上面的代码不会报错，因为import的执行早于foo的调用。这种行为的本质是，import命令是编译阶段执行的，在代码运行之前。 由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。 // 报错 import { &#39;f&#39; + &#39;oo&#39; } from &#39;my_module&#39;; // 报错 let module = &#39;my_module&#39;; import { foo } from module; // 报错 if (x === 1) { import { foo } from &#39;module1&#39;; } else { import { foo } from &#39;module2&#39;; } 上面三种写法都会报错，因为它们用到了表达式、变量和if结构。在静态分析阶段，这些语法都是没法得到值的。 最后，import语句会执行所加载的模块，因此可以有下面的写法。 import &#39;lodash&#39;; 上面代码仅仅执行lodash模块，但是不输入任何值。 如果多次重复执行同一句import语句，那么只会执行一次，而不会执行多次。 import &#39;lodash&#39;; import &#39;lodash&#39;; 上面代码加载了两次lodash，但是只会执行一次。 import { foo } from &#39;my_module&#39;; import { bar } from &#39;my_module&#39;; // 等同于 import { foo, bar } from &#39;my_module&#39;; 上面代码中，虽然foo和bar在两个语句中加载，但是它们对应的是同一个my_module实例。也就是说，import语句是 Singleton 模式。 模块的整体加载除了指定加载某个输出值，还可以使用整体加载，即用星号（*）指定一个对象，所有输出值都加载在这个对象上面。 下面是一个circle.js文件，它输出两个方法area和circumference。 // circle.js export function area(radius) { return Math.PI * radius * radius; } export function circumference(radius) { return 2 * Math.PI * radius; } 现在，加载这个模块。 // main.js import { area, circumference } from &#39;./circle&#39;; console.log(&#39;圆面积：&#39; + area(4)); console.log(&#39;圆周长：&#39; + circumference(14)); 上面写法是逐一指定要加载的方法，整体加载的写法如下。 import * as circle from &#39;./circle&#39;; console.log(&#39;圆面积：&#39; + circle.area(4)); console.log(&#39;圆周长：&#39; + circle.circumference(14)); export default 命令从前面的例子可以看出，使用import命令的时候，用户需要知道所要加载的变量名或函数名，否则无法加载。但是，用户肯定希望快速上手，未必愿意阅读文档，去了解模块有哪些属性和方法。 为了给用户提供方便，让他们不用阅读文档就能加载模块，就要用到export default命令，为模块指定默认输出。 // export-default.js export default function () { console.log(&#39;foo&#39;); } 上面代码是一个模块文件export-default.js，它的默认输出是一个函数。 其他模块加载该模块时，import命令可以为该匿名函数指定任意名字。 // import-default.js import customName from &#39;./export-default&#39;; customName(); // &#39;foo&#39; 上面代码的import命令，可以用任意名称指向export-default.js输出的方法，这时就不需要知道原模块输出的函数名。需要注意的是，这时import命令后面，不使用大括号。 export default命令用在非匿名函数前，也是可以的。 // export-default.js export default function foo() { console.log(&#39;foo&#39;); } // 或者写成 function foo() { console.log(&#39;foo&#39;); } export default foo; 上面代码中，foo函数的函数名foo，在模块外部是无效的。加载的时候，视同匿名函数加载。 下面比较一下默认输出和正常输出。 // 第一组 export default function crc32() { // 输出 // ... } import crc32 from &#39;crc32&#39;; // 输入 // 第二组 export function crc32() { // 输出 // ... }; import {crc32} from &#39;crc32&#39;; // 输入 上面代码的两组写法，第一组是使用export default时，对应的import语句不需要使用大括号；第二组是不使用export default时，对应的import语句需要使用大括号。 export default命令用于指定模块的默认输出。显然，一个模块只能有一个默认输出，因此export default命令只能使用一次。所以，import命令后面才不用加大括号，因为只可能对应一个方法。 本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字。所以，下面的写法是有效的。 // modules.js function add(x, y) { return x * y; } export {add as default}; // 等同于 // export default add; // app.js import { default as xxx } from &#39;modules&#39;; // 等同于 // import xxx from &#39;modules&#39;; 正是因为export default命令其实只是输出一个叫做default的变量，所以它后面不能跟变量声明语句。 // 正确 export var a = 1; // 正确 var a = 1; export default a; // 错误 export default var a = 1; 上面代码中，export default a的含义是将变量a的值赋给变量default。所以，最后一种写法会报错。 有了export default命令，输入模块时就非常直观了，以输入 lodash 模块为例。 import _ from &#39;lodash&#39;; 如果想在一条import语句中，同时输入默认方法和其他变量，可以写成下面这样。 import _, { each } from &#39;lodash&#39;; 对应上面代码的export语句如下。 export default function (obj) { // ··· } export function each(obj, iterator, context) { // ··· } export { each as forEach }; 上面代码的最后一行的意思是，暴露出forEach接口，默认指向each接口，即forEach和each指向同一个方法。 如果要输出默认的值，只需将值跟在export default之后即可。 export default 42; export default也可以用来输出类。 // MyClass.js export default class { ... } // main.js import MyClass from &#39;MyClass&#39;; let o = new MyClass(); export 与 import 的复合写法如果在一个模块之中，先输入后输出同一个模块，import语句可以与export语句写在一起。 export { foo, bar } from &#39;my_module&#39;; // 等同于 import { foo, bar } from &#39;my_module&#39;; export { foo, bar }; 上面代码中，export和import语句可以结合在一起，写成一行。 模块的接口改名和整体输出，也可以采用这种写法。 // 接口改名 export { foo as myFoo } from &#39;my_module&#39;; // 整体输出 export * from &#39;my_module&#39;; 默认接口的写法如下。 export { default } from &#39;foo&#39;; 具名接口改为默认接口的写法如下。 export { es6 as default } from &#39;./someModule&#39;; // 等同于 import { es6 } from &#39;./someModule&#39;; export default es6; 同样地，默认接口也可以改名为具名接口。 export { default as es6 } from &#39;./someModule&#39;; 另外，ES7有一个提案，简化先输入后输出的写法，拿掉输出时的大括号。 // 现行的写法 export {v} from &#39;mod&#39;; // 提案的写法 export v from &#39;mod&#39;; 模块的继承模块之间也可以继承。 假设有一个circleplus模块，继承了circle模块。 // circleplus.js export * from &#39;circle&#39;; export var e = 2.71828182846; export default function(x) { return Math.exp(x); } 上面代码中的export *，表示再输出circle模块的所有属性和方法。注意，export *命令会忽略circle模块的default方法。然后，上面代码又输出了自定义的e变量和默认方法。 这时，也可以将circle的属性或方法，改名后再输出。 // circleplus.js export { area as circleArea } from &#39;circle&#39;; 上面代码表示，只输出circle模块的area方法，且将其改名为circleArea。 加载上面模块的写法如下。 // main.js import * as math from &#39;circleplus&#39;; import exp from &#39;circleplus&#39;; console.log(exp(math.e)); 上面代码中的import exp表示，将circleplus模块的默认方法加载为exp方法。 ES6模块加载的实质ES6模块加载的机制，与CommonJS模块完全不同。CommonJS模块输出的是一个值的拷贝，而ES6模块输出的是值的引用。 CommonJS模块输出的是被输出值的拷贝，也就是说，一旦输出一个值，模块内部的变化就影响不到这个值。请看下面这个模块文件lib.js的例子。 // lib.js var counter = 3; function incCounter() { counter++; } module.exports = { counter: counter, incCounter: incCounter, }; 上面代码输出内部变量counter和改写这个变量的内部方法incCounter。然后，在main.js里面加载这个模块。 // main.js var mod = require(&#39;./lib&#39;); console.log(mod.counter); // 3 mod.incCounter(); console.log(mod.counter); // 3 上面代码说明，lib.js模块加载以后，它的内部变化就影响不到输出的mod.counter了。这是因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。 // lib.js var counter = 3; function incCounter() { counter++; } module.exports = { get counter() { return counter }, incCounter: incCounter, }; 上面代码中，输出的counter属性实际上是一个取值器函数。现在再执行main.js，就可以正确读取内部变量counter的变动了。 $ node main.js 3 4 ES6模块的运行机制与CommonJS不一样，它遇到模块加载命令import时，不会去执行模块，而是只生成一个动态的只读引用。等到真的需要用到时，再到模块里面去取值，换句话说，ES6的输入有点像Unix系统的“符号连接”，原始值变了，import输入的值也会跟着变。因此，ES6模块是动态引用，并且不会缓存值，模块里面的变量绑定其所在的模块。 还是举上面的例子。 // lib.js export let counter = 3; export function incCounter() { counter++; } // main.js import { counter, incCounter } from &#39;./lib&#39;; console.log(counter); // 3 incCounter(); console.log(counter); // 4 上面代码说明，ES6模块输入的变量counter是活的，完全反应其所在模块lib.js内部的变化。 再举一个出现在export一节中的例子。 // m1.js export var foo = &#39;bar&#39;; setTimeout(() =&gt; foo = &#39;baz&#39;, 500); // m2.js import {foo} from &#39;./m1.js&#39;; console.log(foo); setTimeout(() =&gt; console.log(foo), 500); 上面代码中，m1.js的变量foo，在刚加载时等于bar，过了500毫秒，又变为等于baz。 让我们看看，m2.js能否正确读取这个变化。 $ babel-node m2.js bar baz 上面代码表明，ES6模块不会缓存运行结果，而是动态地去被加载的模块取值，并且变量总是绑定其所在的模块。 由于ES6输入的模块变量，只是一个“符号连接”，所以这个变量是只读的，对它进行重新赋值会报错。 // lib.js export let obj = {}; // main.js import { obj } from &#39;./lib&#39;; obj.prop = 123; // OK obj = {}; // TypeError 上面代码中，main.js从lib.js输入变量obj，可以对obj添加属性，但是重新赋值就会报错。因为变量obj指向的地址是只读的，不能重新赋值，这就好比main.js创造了一个名为obj的const变量。 最后，export通过接口，输出的是同一个值。不同的脚本加载这个接口，得到的都是同样的实例。 // mod.js function C() { this.sum = 0; this.add = function () { this.sum += 1; }; this.show = function () { console.log(this.sum); }; } export let c = new C(); 上面的脚本mod.js，输出的是一个C的实例。不同的脚本加载这个模块，得到的都是同一个实例。 // x.js import {c} from &#39;./mod&#39;; c.add(); // y.js import {c} from &#39;./mod&#39;; c.show(); // main.js import &#39;./x&#39;; import &#39;./y&#39;; 现在执行main.js，输出的是1。 $ babel-node main.js 1 这就证明了x.js和y.js加载的都是C的同一个实例。 浏览器的模块加载浏览器使用 ES6 模块的语法如下。 &lt;script type=&quot;module&quot; src=&quot;foo.js&quot;&gt;&lt;/script&gt; 上面代码在网页中插入一个模块foo.js，由于type属性设为module，所以浏览器知道这是一个 ES6 模块。 浏览器对于带有type=&quot;module&quot;的&lt;script&gt;，都是异步加载外部脚本，不会造成堵塞浏览器。 对于外部的模块脚本（上例是foo.js），有几点需要注意。 该脚本自动采用严格模块。 该脚本内部的顶层变量，都只在该脚本内部有效，外部不可见。 该脚本内部的顶层的this关键字，返回undefined，而不是指向window。 循环加载“循环加载”（circular dependency）指的是，a脚本的执行依赖b脚本，而b脚本的执行又依赖a脚本。 // a.js var b = require(&#39;b&#39;); // b.js var a = require(&#39;a&#39;); 通常，“循环加载”表示存在强耦合，如果处理不好，还可能导致递归加载，使得程序无法执行，因此应该避免出现。 但是实际上，这是很难避免的，尤其是依赖关系复杂的大项目，很容易出现a依赖b，b依赖c，c又依赖a这样的情况。这意味着，模块加载机制必须考虑“循环加载”的情况。 对于JavaScript语言来说，目前最常见的两种模块格式CommonJS和ES6，处理“循环加载”的方法是不一样的，返回的结果也不一样。 CommonJS模块的加载原理介绍ES6如何处理”循环加载”之前，先介绍目前最流行的CommonJS模块格式的加载原理。 CommonJS的一个模块，就是一个脚本文件。require命令第一次加载该脚本，就会执行整个脚本，然后在内存生成一个对象。 { id: &#39;...&#39;, exports: { ... }, loaded: true, ... } 上面代码就是Node内部加载模块后生成的一个对象。该对象的id属性是模块名，exports属性是模块输出的各个接口，loaded属性是一个布尔值，表示该模块的脚本是否执行完毕。其他还有很多属性，这里都省略了。 以后需要用到这个模块的时候，就会到exports属性上面取值。即使再次执行require命令，也不会再次执行该模块，而是到缓存之中取值。也就是说，CommonJS模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。 CommonJS模块的循环加载CommonJS模块的重要特性是加载时执行，即脚本代码在require的时候，就会全部执行。一旦出现某个模块被”循环加载”，就只输出已经执行的部分，还未执行的部分不会输出。 让我们来看，Node官方文档里面的例子。脚本文件a.js代码如下。 exports.done = false; var b = require(&#39;./b.js&#39;); console.log(&#39;在 a.js 之中，b.done = %j&#39;, b.done); exports.done = true; console.log(&#39;a.js 执行完毕&#39;); 上面代码之中，a.js脚本先输出一个done变量，然后加载另一个脚本文件b.js。注意，此时a.js代码就停在这里，等待b.js执行完毕，再往下执行。 再看b.js的代码。 exports.done = false; var a = require(&#39;./a.js&#39;); console.log(&#39;在 b.js 之中，a.done = %j&#39;, a.done); exports.done = true; console.log(&#39;b.js 执行完毕&#39;); 上面代码之中，b.js执行到第二行，就会去加载a.js，这时，就发生了“循环加载”。系统会去a.js模块对应对象的exports属性取值，可是因为a.js还没有执行完，从exports属性只能取回已经执行的部分，而不是最后的值。 a.js已经执行的部分，只有一行。 exports.done = false; 因此，对于b.js来说，它从a.js只输入一个变量done，值为false。 然后，b.js接着往下执行，等到全部执行完毕，再把执行权交还给a.js。于是，a.js接着往下执行，直到执行完毕。我们写一个脚本main.js，验证这个过程。 var a = require(&#39;./a.js&#39;); var b = require(&#39;./b.js&#39;); console.log(&#39;在 main.js 之中, a.done=%j, b.done=%j&#39;, a.done, b.done); 执行main.js，运行结果如下。 $ node main.js 在 b.js 之中，a.done = false b.js 执行完毕 在 a.js 之中，b.done = true a.js 执行完毕 在 main.js 之中, a.done=true, b.done=true 上面的代码证明了两件事。一是，在b.js之中，a.js没有执行完毕，只执行了第一行。二是，main.js执行到第二行时，不会再次执行b.js，而是输出缓存的b.js的执行结果，即它的第四行。 exports.done = true; 总之，CommonJS输入的是被输出值的拷贝，不是引用。 另外，由于CommonJS模块遇到循环加载时，返回的是当前已经执行的部分的值，而不是代码全部执行后的值，两者可能会有差异。所以，输入变量的时候，必须非常小心。 var a = require(&#39;a&#39;); // 安全的写法 var foo = require(&#39;a&#39;).foo; // 危险的写法 exports.good = function (arg) { return a.foo(&#39;good&#39;, arg); // 使用的是 a.foo 的最新值 }; exports.bad = function (arg) { return foo(&#39;bad&#39;, arg); // 使用的是一个部分加载时的值 }; 上面代码中，如果发生循环加载，require(&#39;a&#39;).foo的值很可能后面会被改写，改用require(&#39;a&#39;)会更保险一点。 ES6模块的循环加载ES6处理“循环加载”与CommonJS有本质的不同。ES6模块是动态引用，如果使用import从一个模块加载变量（即import foo from &#39;foo&#39;），那些变量不会被缓存，而是成为一个指向被加载模块的引用，需要开发者自己保证，真正取值的时候能够取到值。 请看下面这个例子。 // a.js如下 import {bar} from &#39;./b.js&#39;; console.log(&#39;a.js&#39;); console.log(bar); export let foo = &#39;foo&#39;; // b.js import {foo} from &#39;./a.js&#39;; console.log(&#39;b.js&#39;); console.log(foo); export let bar = &#39;bar&#39;; 上面代码中，a.js加载b.js，b.js又加载a.js，构成循环加载。执行a.js，结果如下。 $ babel-node a.js b.js undefined a.js bar 上面代码中，由于a.js的第一行是加载b.js，所以先执行的是b.js。而b.js的第一行又是加载a.js，这时由于a.js已经开始执行了，所以不会重复执行，而是继续往下执行b.js，所以第一行输出的是b.js。 接着，b.js要打印变量foo，这时a.js还没执行完，取不到foo的值，导致打印出来是undefined。b.js执行完，开始执行a.js，这时就一切正常了。 再看一个稍微复杂的例子（摘自 Dr. Axel Rauschmayer 的《Exploring ES6》）。 // a.js import {bar} from &#39;./b.js&#39;; export function foo() { console.log(&#39;foo&#39;); bar(); console.log(&#39;执行完毕&#39;); } foo(); // b.js import {foo} from &#39;./a.js&#39;; export function bar() { console.log(&#39;bar&#39;); if (Math.random() &gt; 0.5) { foo(); } } 按照CommonJS规范，上面的代码是没法执行的。a先加载b，然后b又加载a，这时a还没有任何执行结果，所以输出结果为null，即对于b.js来说，变量foo的值等于null，后面的foo()就会报错。 但是，ES6可以执行上面的代码。 $ babel-node a.js foo bar 执行完毕 // 执行结果也有可能是 foo bar foo bar 执行完毕 执行完毕 上面代码中，a.js之所以能够执行，原因就在于ES6加载的变量，都是动态引用其所在的模块。只要引用存在，代码就能执行。 下面，我们详细分析这段代码的运行过程。 // a.js // 这一行建立一个引用， // 从`b.js`引用`bar` import {bar} from &#39;./b.js&#39;; export function foo() { // 执行时第一行输出 foo console.log(&#39;foo&#39;); // 到 b.js 执行 bar bar(); console.log(&#39;执行完毕&#39;); } foo(); // b.js // 建立`a.js`的`foo`引用 import {foo} from &#39;./a.js&#39;; export function bar() { // 执行时，第二行输出 bar console.log(&#39;bar&#39;); // 递归执行 foo，一旦随机数 // 小于等于0.5，就停止执行 if (Math.random() &gt; 0.5) { foo(); } } 我们再来看ES6模块加载器SystemJS给出的一个例子。 // even.js import { odd } from &#39;./odd&#39; export var counter = 0; export function even(n) { counter++; return n == 0 || odd(n - 1); } // odd.js import { even } from &#39;./even&#39;; export function odd(n) { return n != 0 &amp;&amp; even(n - 1); } 上面代码中，even.js里面的函数even有一个参数n，只要不等于0，就会减去1，传入加载的odd()。odd.js也会做类似操作。 运行上面这段代码，结果如下。 $ babel-node &gt; import * as m from &#39;./even.js&#39;; &gt; m.even(10); true &gt; m.counter 6 &gt; m.even(20) true &gt; m.counter 17 上面代码中，参数n从10变为0的过程中，even()一共会执行6次，所以变量counter等于6。第二次调用even()时，参数n从20变为0，even()一共会执行11次，加上前面的6次，所以变量counter等于17。 这个例子要是改写成CommonJS，就根本无法执行，会报错。 // even.js var odd = require(&#39;./odd&#39;); var counter = 0; exports.counter = counter; exports.even = function(n) { counter++; return n == 0 || odd(n - 1); } // odd.js var even = require(&#39;./even&#39;).even; module.exports = function(n) { return n != 0 &amp;&amp; even(n - 1); } 上面代码中，even.js加载odd.js，而odd.js又去加载even.js，形成“循环加载”。这时，执行引擎就会输出even.js已经执行的部分（不存在任何结果），所以在odd.js之中，变量even等于null，等到后面调用even(n-1)就会报错。 $ node &gt; var m = require(&#39;./even&#39;); &gt; m.even(10) TypeError: even is not a function 跨模块常量本书介绍const命令的时候说过，const声明的常量只在当前代码块有效。如果想设置跨模块的常量（即跨多个文件），可以采用下面的写法。 // constants.js 模块 export const A = 1; export const B = 3; export const C = 4; // test1.js 模块 import * as constants from &#39;./constants&#39;; console.log(constants.A); // 1 console.log(constants.B); // 3 // test2.js 模块 import {A, B} from &#39;./constants&#39;; console.log(A); // 1 console.log(B); // 3 如果要使用的常量非常多，可以建一个专门的constants目录，将各种常量写在不同的文件里面，保存在该目录下。 // constants/db.js export const db = { url: &#39;http://my.couchdbserver.local:5984&#39;, admin_username: &#39;admin&#39;, admin_password: &#39;admin password&#39; }; // constants/user.js export const users = [&#39;root&#39;, &#39;admin&#39;, &#39;staff&#39;, &#39;ceo&#39;, &#39;chief&#39;, &#39;moderator&#39;]; 然后，将这些文件输出的常量，合并在index.js里面。 // constants/index.js export {db} from &#39;./db&#39;; export {users} from &#39;./users&#39;; 使用的时候，直接加载index.js就可以了。 // script.js import {db, users} from &#39;./constants&#39;; import()上面说过了，import语句会被JavaScript引擎静态分析，先于模块内的其他模块执行（叫做”连接“更合适）。所以，下面的代码会报错。 // 报错 if (x === 2) { import MyModual from &#39;./myModual&#39;; } 上面代码中，引擎处理import语句是在执行之前，所以import语句放在if代码块之中毫无意义，因此会报句法错误，而不是执行时错误。 这样的设计，固然有利于编译器提高效率，但也导致无法在运行时加载模块。从长远来看，import语句会取代 Node 的require方法，但是require是运行时加载模块，import语句显然无法取代这种动态加载功能。 const path = &#39;./&#39; + fileName; const myModual = require(path); 上面的语句就是动态加载，require到底加载哪一个模块，只有运行时才知道。import语句做不到这一点。 因此，有一个提案，建议引入import()函数，完成动态加载。 import(specifier) 上面代码中，import函数的参数specifier，指定所要加载的模块的位置。import语句能够接受什么参数，import()函数就能接受什么参数，两者区别主要是后者为动态加载。 import()返回一个 Promise 对象。下面是一个例子。 const main = document.querySelector(&#39;main&#39;); import(`./section-modules/${someVariable}.js`) .then(module =&gt; { module.loadPageInto(main); }) .catch(err =&gt; { main.textContent = err.message; }); import()函数可以用在任何地方，不仅仅是模块，非模块的脚本也可以使用。它是运行时执行，也就是说，什么时候运行到这一句，也会加载指定的模块。另外，import()函数与所加载的模块没有静态连接关系，这点也是与import语句不相同。 import()类似于 Node 的require方法，区别主要是前者是异步加载，后者是同步加载。 ES6模块的转码浏览器目前还不支持ES6模块，为了现在就能使用，可以将转为ES5的写法。除了Babel可以用来转码之外，还有以下两个方法，也可以用来转码。 ES6 module transpilerES6 module transpiler是 square 公司开源的一个转码器，可以将 ES6 模块转为 CommonJS 模块或 AMD 模块的写法，从而在浏览器中使用。 首先，安装这个转玛器。 $ npm install -g es6-module-transpiler 然后，使用compile-modules convert命令，将 ES6 模块文件转码。 $ compile-modules convert file1.js file2.js -o参数可以指定转码后的文件名。 $ compile-modules convert -o out.js file1.js SystemJS另一种解决方法是使用 SystemJS。它是一个垫片库（polyfill），可以在浏览器内加载 ES6 模块、AMD 模块和 CommonJS 模块，将其转为 ES5 格式。它在后台调用的是 Google 的 Traceur 转码器。 使用时，先在网页内载入system.js文件。 &lt;script src=&quot;system.js&quot;&gt;&lt;/script&gt; 然后，使用System.import方法加载模块文件。 &lt;script&gt; System.import(&#39;./app.js&#39;); &lt;/script&gt; 上面代码中的./app，指的是当前目录下的app.js文件。它可以是ES6模块文件，System.import会自动将其转码。 需要注意的是，System.import使用异步加载，返回一个 Promise 对象，可以针对这个对象编程。下面是一个模块文件。 // app/es6-file.js: export class q { constructor() { this.es6 = &#39;hello&#39;; } } 然后，在网页内加载这个模块文件。 &lt;script&gt; System.import(&#39;app/es6-file&#39;).then(function(m) { console.log(new m.q().es6); // hello }); &lt;/script&gt; 上面代码中，System.import方法返回的是一个 Promise 对象，所以可以用then方法指定回调函数。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Module","slug":"Module","permalink":"https://microzz.com/tags/Module/"}]},{"title":"ES6中Decorator修饰器","date":"2017-01-17T08:00:53.000Z","path":"2017/01/17/decorator/","text":"修饰器类的修饰修饰器（Decorator）是一个函数，用来修改类的行为。这是ES7的一个提案，目前Babel转码器已经支持。 修饰器对类的行为的改变，是代码编译时发生的，而不是在运行时。这意味着，修饰器能在编译阶段运行代码。 function testable(target) { target.isTestable = true; } @testable class MyTestableClass {} console.log(MyTestableClass.isTestable) // true 上面代码中，@testable就是一个修饰器。它修改了MyTestableClass这个类的行为，为它加上了静态属性isTestable。 基本上，修饰器的行为就是下面这样。 @decorator class A {} // 等同于 class A {} A = decorator(A) || A; 也就是说，修饰器本质就是编译时执行的函数。 修饰器函数的第一个参数，就是所要修饰的目标类。 function testable(target) { // ... } 上面代码中，testable函数的参数target，就是会被修饰的类。 如果觉得一个参数不够用，可以在修饰器外面再封装一层函数。 function testable(isTestable) { return function(target) { target.isTestable = isTestable; } } @testable(true) class MyTestableClass {} MyTestableClass.isTestable // true @testable(false) class MyClass {} MyClass.isTestable // false 上面代码中，修饰器testable可以接受参数，这就等于可以修改修饰器的行为。 前面的例子是为类添加一个静态属性，如果想添加实例属性，可以通过目标类的prototype对象操作。 function testable(target) { target.prototype.isTestable = true; } @testable class MyTestableClass {} let obj = new MyTestableClass(); obj.isTestable // true 上面代码中，修饰器函数testable是在目标类的prototype对象上添加属性，因此就可以在实例上调用。 下面是另外一个例子。 // mixins.js export function mixins(...list) { return function (target) { Object.assign(target.prototype, ...list) } } // main.js import { mixins } from &#39;./mixins&#39; const Foo = { foo() { console.log(&#39;foo&#39;) } }; @mixins(Foo) class MyClass {} let obj = new MyClass(); obj.foo() // &#39;foo&#39; 上面代码通过修饰器mixins，把Foo类的方法添加到了MyClass的实例上面。可以用Object.assign()模拟这个功能。 const Foo = { foo() { console.log(&#39;foo&#39;) } }; class MyClass {} Object.assign(MyClass.prototype, Foo); let obj = new MyClass(); obj.foo() // &#39;foo&#39; 方法的修饰修饰器不仅可以修饰类，还可以修饰类的属性。 class Person { @readonly name() { return `${this.first} ${this.last}` } } 上面代码中，修饰器readonly用来修饰“类”的name方法。 此时，修饰器函数一共可以接受三个参数，第一个参数是所要修饰的目标对象，第二个参数是所要修饰的属性名，第三个参数是该属性的描述对象。 function readonly(target, name, descriptor){ // descriptor对象原来的值如下 // { // value: specifiedFunction, // enumerable: false, // configurable: true, // writable: true // }; descriptor.writable = false; return descriptor; } readonly(Person.prototype, &#39;name&#39;, descriptor); // 类似于 Object.defineProperty(Person.prototype, &#39;name&#39;, descriptor); 上面代码说明，修饰器（readonly）会修改属性的描述对象（descriptor），然后被修改的描述对象再用来定义属性。 下面是另一个例子，修改属性描述对象的enumerable属性，使得该属性不可遍历。 class Person { @nonenumerable get kidCount() { return this.children.length; } } function nonenumerable(target, name, descriptor) { descriptor.enumerable = false; return descriptor; } 下面的@log修饰器，可以起到输出日志的作用。 class Math { @log add(a, b) { return a + b; } } function log(target, name, descriptor) { var oldValue = descriptor.value; descriptor.value = function() { console.log(`Calling &quot;${name}&quot; with`, arguments); return oldValue.apply(null, arguments); }; return descriptor; } const math = new Math(); // passed parameters should get logged now math.add(2, 4); 上面代码中，@log修饰器的作用就是在执行原始的操作之前，执行一次console.log，从而达到输出日志的目的。 修饰器有注释的作用。 @testable class Person { @readonly @nonenumerable name() { return `${this.first} ${this.last}` } } 从上面代码中，我们一眼就能看出，Person类是可测试的，而name方法是只读和不可枚举的。 如果同一个方法有多个修饰器，会像剥洋葱一样，先从外到内进入，然后由内向外执行。 function dec(id){ console.log(&#39;evaluated&#39;, id); return (target, property, descriptor) =&gt; console.log(&#39;executed&#39;, id); } class Example { @dec(1) @dec(2) method(){} } // evaluated 1 // evaluated 2 // executed 2 // executed 1 上面代码中，外层修饰器@dec(1)先进入，但是内层修饰器@dec(2)先执行。 除了注释，修饰器还能用来类型检查。所以，对于类来说，这项功能相当有用。从长期来看，它将是JavaScript代码静态分析的重要工具。 为什么修饰器不能用于函数？修饰器只能用于类和类的方法，不能用于函数，因为存在函数提升。 var counter = 0; var add = function () { counter++; }; @add function foo() { } 上面的代码，意图是执行后counter等于1，但是实际上结果是counter等于0。因为函数提升，使得实际执行的代码是下面这样。 @add function foo() { } var counter; var add; counter = 0; add = function () { counter++; }; 下面是另一个例子。 var readOnly = require(&quot;some-decorator&quot;); @readOnly function foo() { } 上面代码也有问题，因为实际执行是下面这样。 var readOnly; @readOnly function foo() { } readOnly = require(&quot;some-decorator&quot;); 总之，由于存在函数提升，使得修饰器不能用于函数。类是不会提升的，所以就没有这方面的问题。 core-decorators.jscore-decorators.js是一个第三方模块，提供了几个常见的修饰器，通过它可以更好地理解修饰器。 （1）@autobind autobind修饰器使得方法中的this对象，绑定原始对象。 import { autobind } from &#39;core-decorators&#39;; class Person { @autobind getPerson() { return this; } } let person = new Person(); let getPerson = person.getPerson; getPerson() === person; // true （2）@readonly readonly修饰器使得属性或方法不可写。 import { readonly } from &#39;core-decorators&#39;; class Meal { @readonly entree = &#39;steak&#39;; } var dinner = new Meal(); dinner.entree = &#39;salmon&#39;; // Cannot assign to read only property &#39;entree&#39; of [object Object] （3）@override override修饰器检查子类的方法，是否正确覆盖了父类的同名方法，如果不正确会报错。 import { override } from &#39;core-decorators&#39;; class Parent { speak(first, second) {} } class Child extends Parent { @override speak() {} // SyntaxError: Child#speak() does not properly override Parent#speak(first, second) } // or class Child extends Parent { @override speaks() {} // SyntaxError: No descriptor matching Child#speaks() was found on the prototype chain. // // Did you mean &quot;speak&quot;? } （4）@deprecate (别名@deprecated) deprecate或deprecated修饰器在控制台显示一条警告，表示该方法将废除。 import { deprecate } from &#39;core-decorators&#39;; class Person { @deprecate facepalm() {} @deprecate(&#39;We stopped facepalming&#39;) facepalmHard() {} @deprecate(&#39;We stopped facepalming&#39;, { url: &#39;http://knowyourmeme.com/memes/facepalm&#39; }) facepalmHarder() {} } let person = new Person(); person.facepalm(); // DEPRECATION Person#facepalm: This function will be removed in future versions. person.facepalmHard(); // DEPRECATION Person#facepalmHard: We stopped facepalming person.facepalmHarder(); // DEPRECATION Person#facepalmHarder: We stopped facepalming // // See http://knowyourmeme.com/memes/facepalm for more details. // （5）@suppressWarnings suppressWarnings修饰器抑制decorated修饰器导致的console.warn()调用。但是，异步代码发出的调用除外。 import { suppressWarnings } from &#39;core-decorators&#39;; class Person { @deprecated facepalm() {} @suppressWarnings facepalmWithoutWarning() { this.facepalm(); } } let person = new Person(); person.facepalmWithoutWarning(); // no warning is logged 使用修饰器实现自动发布事件我们可以使用修饰器，使得对象的方法被调用时，自动发出一个事件。 import postal from &quot;postal/lib/postal.lodash&quot;; export default function publish(topic, channel) { return function(target, name, descriptor) { const fn = descriptor.value; descriptor.value = function() { let value = fn.apply(this, arguments); postal.channel(channel || target.channel || &quot;/&quot;).publish(topic, value); }; }; } 上面代码定义了一个名为publish的修饰器，它通过改写descriptor.value，使得原方法被调用时，会自动发出一个事件。它使用的事件“发布/订阅”库是Postal.js。 它的用法如下。 import publish from &quot;path/to/decorators/publish&quot;; class FooComponent { @publish(&quot;foo.some.message&quot;, &quot;component&quot;) someMethod() { return { my: &quot;data&quot; }; } @publish(&quot;foo.some.other&quot;) anotherMethod() { // ... } } 以后，只要调用someMethod或者anotherMethod，就会自动发出一个事件。 let foo = new FooComponent(); foo.someMethod() // 在&quot;component&quot;频道发布&quot;foo.some.message&quot;事件，附带的数据是{ my: &quot;data&quot; } foo.anotherMethod() // 在&quot;/&quot;频道发布&quot;foo.some.other&quot;事件，不附带数据 Mixin在修饰器的基础上，可以实现Mixin模式。所谓Mixin模式，就是对象继承的一种替代方案，中文译为“混入”（mix in），意为在一个对象之中混入另外一个对象的方法。 请看下面的例子。 const Foo = { foo() { console.log(&#39;foo&#39;) } }; class MyClass {} Object.assign(MyClass.prototype, Foo); let obj = new MyClass(); obj.foo() // &#39;foo&#39; 上面代码之中，对象Foo有一个foo方法，通过Object.assign方法，可以将foo方法“混入”MyClass类，导致MyClass的实例obj对象都具有foo方法。这就是“混入”模式的一个简单实现。 下面，我们部署一个通用脚本mixins.js，将mixin写成一个修饰器。 export function mixins(...list) { return function (target) { Object.assign(target.prototype, ...list); }; } 然后，就可以使用上面这个修饰器，为类“混入”各种方法。 import { mixins } from &#39;./mixins&#39;; const Foo = { foo() { console.log(&#39;foo&#39;) } }; @mixins(Foo) class MyClass {} let obj = new MyClass(); obj.foo() // &quot;foo&quot; 通过mixins这个修饰器，实现了在MyClass类上面“混入”Foo对象的foo方法。 不过，上面的方法会改写MyClass类的prototype对象，如果不喜欢这一点，也可以通过类的继承实现mixin。 class MyClass extends MyBaseClass { /* ... */ } 上面代码中，MyClass继承了MyBaseClass。如果我们想在MyClass里面“混入”一个foo方法，一个办法是在MyClass和MyBaseClass之间插入一个混入类，这个类具有foo方法，并且继承了MyBaseClass的所有方法，然后MyClass再继承这个类。 let MyMixin = (superclass) =&gt; class extends superclass { foo() { console.log(&#39;foo from MyMixin&#39;); } }; 上面代码中，MyMixin是一个混入类生成器，接受superclass作为参数，然后返回一个继承superclass的子类，该子类包含一个foo方法。 接着，目标类再去继承这个混入类，就达到了“混入”foo方法的目的。 class MyClass extends MyMixin(MyBaseClass) { /* ... */ } let c = new MyClass(); c.foo(); // &quot;foo from MyMixin&quot; 如果需要“混入”多个方法，就生成多个混入类。 class MyClass extends Mixin1(Mixin2(MyBaseClass)) { /* ... */ } 这种写法的一个好处，是可以调用super，因此可以避免在“混入”过程中覆盖父类的同名方法。 let Mixin1 = (superclass) =&gt; class extends superclass { foo() { console.log(&#39;foo from Mixin1&#39;); if (super.foo) super.foo(); } }; let Mixin2 = (superclass) =&gt; class extends superclass { foo() { console.log(&#39;foo from Mixin2&#39;); if (super.foo) super.foo(); } }; class S { foo() { console.log(&#39;foo from S&#39;); } } class C extends Mixin1(Mixin2(S)) { foo() { console.log(&#39;foo from C&#39;); super.foo(); } } 上面代码中，每一次混入发生时，都调用了父类的super.foo方法，导致父类的同名方法没有被覆盖，行为被保留了下来。 new C().foo() // foo from C // foo from Mixin1 // foo from Mixin2 // foo from S TraitTrait也是一种修饰器，效果与Mixin类似，但是提供更多功能，比如防止同名方法的冲突、排除混入某些方法、为混入的方法起别名等等。 下面采用traits-decorator这个第三方模块作为例子。这个模块提供的traits修饰器，不仅可以接受对象，还可以接受ES6类作为参数。 import { traits } from &#39;traits-decorator&#39;; class TFoo { foo() { console.log(&#39;foo&#39;) } } const TBar = { bar() { console.log(&#39;bar&#39;) } }; @traits(TFoo, TBar) class MyClass { } let obj = new MyClass(); obj.foo() // foo obj.bar() // bar 上面代码中，通过traits修饰器，在MyClass类上面“混入”了TFoo类的foo方法和TBar对象的bar方法。 Trait不允许“混入”同名方法。 import { traits } from &#39;traits-decorator&#39;; class TFoo { foo() { console.log(&#39;foo&#39;) } } const TBar = { bar() { console.log(&#39;bar&#39;) }, foo() { console.log(&#39;foo&#39;) } }; @traits(TFoo, TBar) class MyClass { } // 报错 // throw new Error(&#39;Method named: &#39; + methodName + &#39; is defined twice.&#39;); // ^ // Error: Method named: foo is defined twice. 上面代码中，TFoo和TBar都有foo方法，结果traits修饰器报错。 一种解决方法是排除TBar的foo方法。 import { traits, excludes } from &#39;traits-decorator&#39;; class TFoo { foo() { console.log(&#39;foo&#39;) } } const TBar = { bar() { console.log(&#39;bar&#39;) }, foo() { console.log(&#39;foo&#39;) } }; @traits(TFoo, TBar::excludes(&#39;foo&#39;)) class MyClass { } let obj = new MyClass(); obj.foo() // foo obj.bar() // bar 上面代码使用绑定运算符（::）在TBar上排除foo方法，混入时就不会报错了。 另一种方法是为TBar的foo方法起一个别名。 import { traits, alias } from &#39;traits-decorator&#39;; class TFoo { foo() { console.log(&#39;foo&#39;) } } const TBar = { bar() { console.log(&#39;bar&#39;) }, foo() { console.log(&#39;foo&#39;) } }; @traits(TFoo, TBar::alias({foo: &#39;aliasFoo&#39;})) class MyClass { } let obj = new MyClass(); obj.foo() // foo obj.aliasFoo() // foo obj.bar() // bar 上面代码为TBar的foo方法起了别名aliasFoo，于是MyClass也可以混入TBar的foo方法了。 alias和excludes方法，可以结合起来使用。 @traits(TExample::excludes(&#39;foo&#39;,&#39;bar&#39;)::alias({baz:&#39;exampleBaz&#39;})) class MyClass {} 上面代码排除了TExample的foo方法和bar方法，为baz方法起了别名exampleBaz。 as方法则为上面的代码提供了另一种写法。 @traits(TExample::as({excludes:[&#39;foo&#39;, &#39;bar&#39;], alias: {baz: &#39;exampleBaz&#39;}})) class MyClass {} Babel转码器的支持目前，Babel转码器已经支持Decorator。 首先，安装babel-core和babel-plugin-transform-decorators。由于后者包括在babel-preset-stage-0之中，所以改为安装babel-preset-stage-0亦可。 $ npm install babel-core babel-plugin-transform-decorators 然后，设置配置文件.babelrc。 { &quot;plugins&quot;: [&quot;transform-decorators&quot;] } 这时，Babel就可以对Decorator转码了。 脚本中打开的命令如下。 babel.transform(&quot;code&quot;, {plugins: [&quot;transform-decorators&quot;]}) Babel的官方网站提供一个在线转码器，只要勾选Experimental，就能支持Decorator的在线转码。 感谢阮一峰老师的原创，本分享仅供学习交流","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Decorator","slug":"Decorator","permalink":"https://microzz.com/tags/Decorator/"}]},{"title":"ES6中的Class","date":"2017-01-16T08:40:45.000Z","path":"2017/01/16/class/","text":"ClassClass基本语法概述JavaScript语言的传统方法是通过构造函数，定义并生成新对象。下面是一个例子。 function Point(x, y) { this.x = x; this.y = y; } Point.prototype.toString = function () { return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;; }; var p = new Point(1, 2); 上面这种写法跟传统的面向对象语言（比如C++和Java）差异很大，很容易让新学习这门语言的程序员感到困惑。 ES6提供了更接近传统语言的写法，引入了Class（类）这个概念，作为对象的模板。通过class关键字，可以定义类。基本上，ES6的class可以看作只是一个语法糖，它的绝大部分功能，ES5都可以做到，新的class写法只是让对象原型的写法更加清晰、更像面向对象编程的语法而已。上面的代码用ES6的“类”改写，就是下面这样。 //定义类 class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;; } } 上面代码定义了一个“类”，可以看到里面有一个constructor方法，这就是构造方法，而this关键字则代表实例对象。也就是说，ES5的构造函数Point，对应ES6的Point类的构造方法。 Point类除了构造方法，还定义了一个toString方法。注意，定义“类”的方法的时候，前面不需要加上function这个关键字，直接把函数定义放进去了就可以了。另外，方法之间不需要逗号分隔，加了会报错。 ES6的类，完全可以看作构造函数的另一种写法。 class Point { // ... } typeof Point // &quot;function&quot; Point === Point.prototype.constructor // true 上面代码表明，类的数据类型就是函数，类本身就指向构造函数。 使用的时候，也是直接对类使用new命令，跟构造函数的用法完全一致。 class Bar { doStuff() { console.log(&#39;stuff&#39;); } } var b = new Bar(); b.doStuff() // &quot;stuff&quot; 构造函数的prototype属性，在ES6的“类”上面继续存在。事实上，类的所有方法都定义在类的prototype属性上面。 class Point { constructor(){ // ... } toString(){ // ... } toValue(){ // ... } } // 等同于 Point.prototype = { toString(){}, toValue(){} }; 在类的实例上面调用方法，其实就是调用原型上的方法。 class B {} let b = new B(); b.constructor === B.prototype.constructor // true 上面代码中，b是B类的实例，它的constructor方法就是B类原型的constructor方法。 由于类的方法都定义在prototype对象上面，所以类的新方法可以添加在prototype对象上面。Object.assign方法可以很方便地一次向类添加多个方法。 class Point { constructor(){ // ... } } Object.assign(Point.prototype, { toString(){}, toValue(){} }); prototype对象的constructor属性，直接指向“类”的本身，这与ES5的行为是一致的。 Point.prototype.constructor === Point // true 另外，类的内部所有定义的方法，都是不可枚举的（non-enumerable）。 class Point { constructor(x, y) { // ... } toString() { // ... } } Object.keys(Point.prototype) // [] Object.getOwnPropertyNames(Point.prototype) // [&quot;constructor&quot;,&quot;toString&quot;] 上面代码中，toString方法是Point类内部定义的方法，它是不可枚举的。这一点与ES5的行为不一致。 var Point = function (x, y) { // ... }; Point.prototype.toString = function() { // ... }; Object.keys(Point.prototype) // [&quot;toString&quot;] Object.getOwnPropertyNames(Point.prototype) // [&quot;constructor&quot;,&quot;toString&quot;] 上面代码采用ES5的写法，toString方法就是可枚举的。 类的属性名，可以采用表达式。 let methodName = &quot;getArea&quot;; class Square{ constructor(length) { // ... } [methodName]() { // ... } } 上面代码中，Square类的方法名getArea，是从表达式得到的。 constructor方法constructor方法是类的默认方法，通过new命令生成对象实例时，自动调用该方法。一个类必须有constructor方法，如果没有显式定义，一个空的constructor方法会被默认添加。 constructor() {} constructor方法默认返回实例对象（即this），完全可以指定返回另外一个对象。 class Foo { constructor() { return Object.create(null); } } new Foo() instanceof Foo // false 上面代码中，constructor函数返回一个全新的对象，结果导致实例对象不是Foo类的实例。 类的构造函数，不使用new是没法调用的，会报错。这是它跟普通构造函数的一个主要区别，后者不用new也可以执行。 class Foo { constructor() { return Object.create(null); } } Foo() // TypeError: Class constructor Foo cannot be invoked without &#39;new&#39; 类的实例对象生成类的实例对象的写法，与ES5完全一样，也是使用new命令。如果忘记加上new，像函数那样调用Class，将会报错。 // 报错 var point = Point(2, 3); // 正确 var point = new Point(2, 3); 与ES5一样，实例的属性除非显式定义在其本身（即定义在this对象上），否则都是定义在原型上（即定义在class上）。 //定义类 class Point { constructor(x, y) { this.x = x; this.y = y; } toString() { return &#39;(&#39; + this.x + &#39;, &#39; + this.y + &#39;)&#39;; } } var point = new Point(2, 3); point.toString() // (2, 3) point.hasOwnProperty(&#39;x&#39;) // true point.hasOwnProperty(&#39;y&#39;) // true point.hasOwnProperty(&#39;toString&#39;) // false point.__proto__.hasOwnProperty(&#39;toString&#39;) // true 上面代码中，x和y都是实例对象point自身的属性（因为定义在this变量上），所以hasOwnProperty方法返回true，而toString是原型对象的属性（因为定义在Point类上），所以hasOwnProperty方法返回false。这些都与ES5的行为保持一致。 与ES5一样，类的所有实例共享一个原型对象。 var p1 = new Point(2,3); var p2 = new Point(3,2); p1.__proto__ === p2.__proto__ //true 上面代码中，p1和p2都是Point的实例，它们的原型都是Point.prototype，所以__proto__属性是相等的。 这也意味着，可以通过实例的__proto__属性为Class添加方法。 var p1 = new Point(2,3); var p2 = new Point(3,2); p1.__proto__.printName = function () { return &#39;Oops&#39; }; p1.printName() // &quot;Oops&quot; p2.printName() // &quot;Oops&quot; var p3 = new Point(4,2); p3.printName() // &quot;Oops&quot; 上面代码在p1的原型上添加了一个printName方法，由于p1的原型就是p2的原型，因此p2也可以调用这个方法。而且，此后新建的实例p3也可以调用这个方法。这意味着，使用实例的__proto__属性改写原型，必须相当谨慎，不推荐使用，因为这会改变Class的原始定义，影响到所有实例。 不存在变量提升Class不存在变量提升（hoist），这一点与ES5完全不同。 new Foo(); // ReferenceError class Foo {} 上面代码中，Foo类使用在前，定义在后，这样会报错，因为ES6不会把类的声明提升到代码头部。这种规定的原因与下文要提到的继承有关，必须保证子类在父类之后定义。 { let Foo = class {}; class Bar extends Foo { } } 上面的代码不会报错，因为Bar继承Foo的时候，Foo已经有定义了。但是，如果存在class的提升，上面代码就会报错，因为class会被提升到代码头部，而let命令是不提升的，所以导致Bar继承Foo的时候，Foo还没有定义。 Class表达式与函数一样，类也可以使用表达式的形式定义。 const MyClass = class Me { getClassName() { return Me.name; } }; 上面代码使用表达式定义了一个类。需要注意的是，这个类的名字是MyClass而不是Me，Me只在Class的内部代码可用，指代当前类。 let inst = new MyClass(); inst.getClassName() // Me Me.name // ReferenceError: Me is not defined 上面代码表示，Me只在Class内部有定义。 如果类的内部没用到的话，可以省略Me，也就是可以写成下面的形式。 const MyClass = class { /* ... */ }; 采用Class表达式，可以写出立即执行的Class。 let person = new class { constructor(name) { this.name = name; } sayName() { console.log(this.name); } }(&#39;张三&#39;); person.sayName(); // &quot;张三&quot; 上面代码中，person是一个立即执行的类的实例。 私有方法私有方法是常见需求，但ES6不提供，只能通过变通方法模拟实现。 一种做法是在命名上加以区别。 class Widget { // 公有方法 foo (baz) { this._bar(baz); } // 私有方法 _bar(baz) { return this.snaf = baz; } // ... } 上面代码中，_bar方法前面的下划线，表示这是一个只限于内部使用的私有方法。但是，这种命名是不保险的，在类的外部，还是可以调用到这个方法。 另一种方法就是索性将私有方法移出模块，因为模块内部的所有方法都是对外可见的。 class Widget { foo (baz) { bar.call(this, baz); } // ... } function bar(baz) { return this.snaf = baz; } 上面代码中，foo是公有方法，内部调用了bar.call(this, baz)。这使得bar实际上成为了当前模块的私有方法。 还有一种方法是利用Symbol值的唯一性，将私有方法的名字命名为一个Symbol值。 const bar = Symbol(&#39;bar&#39;); const snaf = Symbol(&#39;snaf&#39;); export default class myClass{ // 公有方法 foo(baz) { this[bar](baz); } // 私有方法 [bar](baz) { return this[snaf] = baz; } // ... }; 上面代码中，bar和snaf都是Symbol值，导致第三方无法获取到它们，因此达到了私有方法和私有属性的效果。 this的指向类的方法内部如果含有this，它默认指向类的实例。但是，必须非常小心，一旦单独使用该方法，很可能报错。 class Logger { printName(name = &#39;there&#39;) { this.print(`Hello ${name}`); } print(text) { console.log(text); } } const logger = new Logger(); const { printName } = logger; printName(); // TypeError: Cannot read property &#39;print&#39; of undefined 上面代码中，printName方法中的this，默认指向Logger类的实例。但是，如果将这个方法提取出来单独使用，this会指向该方法运行时所在的环境，因为找不到print方法而导致报错。 一个比较简单的解决方法是，在构造方法中绑定this，这样就不会找不到print方法了。 class Logger { constructor() { this.printName = this.printName.bind(this); } // ... } 另一种解决方法是使用箭头函数。 class Logger { constructor() { this.printName = (name = &#39;there&#39;) =&gt; { this.print(`Hello ${name}`); }; } // ... } 还有一种解决方法是使用Proxy，获取方法的时候，自动绑定this。 function selfish (target) { const cache = new WeakMap(); const handler = { get (target, key) { const value = Reflect.get(target, key); if (typeof value !== &#39;function&#39;) { return value; } if (!cache.has(value)) { cache.set(value, value.bind(target)); } return cache.get(value); } }; const proxy = new Proxy(target, handler); return proxy; } const logger = selfish(new Logger()); 严格模式类和模块的内部，默认就是严格模式，所以不需要使用use strict指定运行模式。只要你的代码写在类或模块之中，就只有严格模式可用。 考虑到未来所有的代码，其实都是运行在模块之中，所以ES6实际上把整个语言升级到了严格模式。 name属性由于本质上，ES6的类只是ES5的构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。 class Point {} Point.name // &quot;Point&quot; name属性总是返回紧跟在class关键字后面的类名。 Class的继承基本用法Class之间可以通过extends关键字实现继承，这比ES5的通过修改原型链实现继承，要清晰和方便很多。 class ColorPoint extends Point {} 上面代码定义了一个ColorPoint类，该类通过extends关键字，继承了Point类的所有属性和方法。但是由于没有部署任何代码，所以这两个类完全一样，等于复制了一个Point类。下面，我们在ColorPoint内部加上代码。 class ColorPoint extends Point { constructor(x, y, color) { super(x, y); // 调用父类的constructor(x, y) this.color = color; } toString() { return this.color + &#39; &#39; + super.toString(); // 调用父类的toString() } } 上面代码中，constructor方法和toString方法之中，都出现了super关键字，它在这里表示父类的构造函数，用来新建父类的this对象。 子类必须在constructor方法中调用super方法，否则新建实例时会报错。这是因为子类没有自己的this对象，而是继承父类的this对象，然后对其进行加工。如果不调用super方法，子类就得不到this对象。 class Point { /* ... */ } class ColorPoint extends Point { constructor() { } } let cp = new ColorPoint(); // ReferenceError 上面代码中，ColorPoint继承了父类Point，但是它的构造函数没有调用super方法，导致新建实例时报错。 ES5的继承，实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）。ES6的继承机制完全不同，实质是先创造父类的实例对象this（所以必须先调用super方法），然后再用子类的构造函数修改this。 如果子类没有定义constructor方法，这个方法会被默认添加，代码如下。也就是说，不管有没有显式定义，任何一个子类都有constructor方法。 constructor(...args) { super(...args); } 另一个需要注意的地方是，在子类的构造函数中，只有调用super之后，才可以使用this关键字，否则会报错。这是因为子类实例的构建，是基于对父类实例加工，只有super方法才能返回父类实例。 class Point { constructor(x, y) { this.x = x; this.y = y; } } class ColorPoint extends Point { constructor(x, y, color) { this.color = color; // ReferenceError super(x, y); this.color = color; // 正确 } } 上面代码中，子类的constructor方法没有调用super之前，就使用this关键字，结果报错，而放在super方法之后就是正确的。 下面是生成子类实例的代码。 let cp = new ColorPoint(25, 8, &#39;green&#39;); cp instanceof ColorPoint // true cp instanceof Point // true 上面代码中，实例对象cp同时是ColorPoint和Point两个类的实例，这与ES5的行为完全一致。 类的prototype属性和__proto__属性大多数浏览器的ES5实现之中，每一个对象都有__proto__属性，指向对应的构造函数的prototype属性。Class作为构造函数的语法糖，同时有prototype属性和__proto__属性，因此同时存在两条继承链。 （1）子类的__proto__属性，表示构造函数的继承，总是指向父类。 （2）子类prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。 class A { } class B extends A { } B.__proto__ === A // true B.prototype.__proto__ === A.prototype // true 上面代码中，子类B的__proto__属性指向父类A，子类B的prototype属性的__proto__属性指向父类A的prototype属性。 这样的结果是因为，类的继承是按照下面的模式实现的。 class A { } class B { } // B的实例继承A的实例 Object.setPrototypeOf(B.prototype, A.prototype); const b = new B(); // B的实例继承A的静态属性 Object.setPrototypeOf(B, A); const b = new B(); 《对象的扩展》一章给出过Object.setPrototypeOf方法的实现。 Object.setPrototypeOf = function (obj, proto) { obj.__proto__ = proto; return obj; } 因此，就得到了上面的结果。 Object.setPrototypeOf(B.prototype, A.prototype); // 等同于 B.prototype.__proto__ = A.prototype; Object.setPrototypeOf(B, A); // 等同于 B.__proto__ = A; 这两条继承链，可以这样理解：作为一个对象，子类（B）的原型（__proto__属性）是父类（A）；作为一个构造函数，子类（B）的原型（prototype属性）是父类的实例。 Object.create(A.prototype); // 等同于 B.prototype.__proto__ = A.prototype; Extends 的继承目标extends关键字后面可以跟多种类型的值。 class B extends A { } 上面代码的A，只要是一个有prototype属性的函数，就能被B继承。由于函数都有prototype属性（除了Function.prototype函数），因此A可以是任意函数。 下面，讨论三种特殊情况。 第一种特殊情况，子类继承Object类。 class A extends Object { } A.__proto__ === Object // true A.prototype.__proto__ === Object.prototype // true 这种情况下，A其实就是构造函数Object的复制，A的实例就是Object的实例。 第二种特殊情况，不存在任何继承。 class A { } A.__proto__ === Function.prototype // true A.prototype.__proto__ === Object.prototype // true 这种情况下，A作为一个基类（即不存在任何继承），就是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回一个空对象（即Object实例），所以A.prototype.__proto__指向构造函数（Object）的prototype属性。 第三种特殊情况，子类继承null。 class A extends null { } A.__proto__ === Function.prototype // true A.prototype.__proto__ === undefined // true 这种情况与第二种情况非常像。A也是一个普通函数，所以直接继承Funciton.prototype。但是，A调用后返回的对象不继承任何方法，所以它的__proto__指向Function.prototype，即实质上执行了下面的代码。 class C extends null { constructor() { return Object.create(null); } } Object.getPrototypeOf()Object.getPrototypeOf方法可以用来从子类上获取父类。 Object.getPrototypeOf(ColorPoint) === Point // true 因此，可以使用这个方法判断，一个类是否继承了另一个类。 super 关键字super这个关键字，既可以当作函数使用，也可以当作对象使用。在这两种情况下，它的用法完全不同。 第一种情况，super作为函数调用时，代表父类的构造函数。ES6 要求，子类的构造函数必须执行一次super函数。 class A {} class B extends A { constructor() { super(); } } 上面代码中，子类B的构造函数之中的super()，代表调用父类的构造函数。这是必须的，否则 JavaScript 引擎会报错。 注意，super虽然代表了父类A的构造函数，但是返回的是子类B的实例，即super内部的this指的是B，因此super()在这里相当于A.prototype.constructor.call(this)。 class A { constructor() { console.log(new.target.name); } } class B extends A { constructor() { super(); } } new A() // A new B() // B 上面代码中，new.target指向当前正在执行的函数。可以看到，在super()执行时，它指向的是子类B的构造函数，而不是父类A的构造函数。也就是说，super()内部的this指向的是B。 作为函数时，super()只能用在子类的构造函数之中，用在其他地方就会报错。 class A {} class B extends A { m() { super(); // 报错 } } 上面代码中，super()用在B类的m方法之中，就会造成句法错误。 第二种情况，super作为对象时，指向父类的原型对象。 class A { p() { return 2; } } class B extends A { constructor() { super(); console.log(super.p()); // 2 } } let b = new B(); 上面代码中，子类B当中的super.p()，就是将super当作一个对象使用。这时，super指向A.prototype，所以super.p()就相当于A.prototype.p()。 这里需要注意，由于super指向父类的原型对象，所以定义在父类实例上的方法或属性，是无法通过super调用的。 class A { constructor() { this.p = 2; } } class B extends A { get m() { return super.p; } } let b = new B(); b.m // undefined 上面代码中，p是父类A实例的属性，super.p就引用不到它。 如果属性定义在父类的原型对象上，super就可以取到。 class A {} A.prototype.x = 2; class B extends A { constructor() { super(); console.log(super.x) // 2 } } let b = new B(); 上面代码中，属性x是定义在A.prototype上面的，所以super.x可以取到它的值。 ES6 规定，通过super调用父类的方法时，super会绑定子类的this。 class A { constructor() { this.x = 1; } print() { console.log(this.x); } } class B extends A { constructor() { super(); this.x = 2; } m() { super.print(); } } let b = new B(); b.m() // 2 上面代码中，super.print()虽然调用的是A.prototype.print()，但是A.prototype.print()会绑定子类B的this，导致输出的是2，而不是1。也就是说，实际上执行的是super.print.call(this)。 由于绑定子类的this，所以如果通过super对某个属性赋值，这时super就是this，赋值的属性会变成子类实例的属性。 class A { constructor() { this.x = 1; } } class B extends A { constructor() { super(); this.x = 2; super.x = 3; console.log(super.x); // undefined console.log(this.x); // 3 } } let b = new B(); 上面代码中，super.x赋值为3，这时等同于对this.x赋值为3。而当读取super.x的时候，读的是A.prototype.x，所以返回undefined。 注意，使用super的时候，必须显式指定是作为函数、还是作为对象使用，否则会报错。 class A {} class B extends A { constructor() { super(); console.log(super); // 报错 } } 上面代码中，console.log(super)当中的super，无法看出是作为函数使用，还是作为对象使用，所以 JavaScript 引擎解析代码的时候就会报错。这时，如果能清晰地表明super的数据类型，就不会报错。 class A {} class B extends A { constructor() { super(); console.log(super.valueOf() instanceof B); // true } } let b = new B(); 上面代码中，super.valueOf()表明super是一个对象，因此就不会报错。同时，由于super绑定B的this，所以super.valueOf()返回的是一个B的实例。 最后，由于对象总是继承其他对象的，所以可以在任意一个对象中，使用super关键字。 var obj = { toString() { return &quot;MyObject: &quot; + super.toString(); } }; obj.toString(); // MyObject: [object Object] 实例的__proto__属性子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__属性。也就是说，子类的原型的原型，是父类的原型。 var p1 = new Point(2, 3); var p2 = new ColorPoint(2, 3, &#39;red&#39;); p2.__proto__ === p1.__proto__ // false p2.__proto__.__proto__ === p1.__proto__ // true 上面代码中，ColorPoint继承了Point，导致前者原型的原型是后者的原型。 因此，通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。 p2.__proto__.__proto__.printName = function () { console.log(&#39;Ha&#39;); }; p1.printName() // &quot;Ha&quot; 上面代码在ColorPoint的实例p2上向Point类添加方法，结果影响到了Point的实例p1。 原生构造函数的继承原生构造函数是指语言内置的构造函数，通常用来生成数据结构。ECMAScript的原生构造函数大致有下面这些。 Boolean() Number() String() Array() Date() Function() RegExp() Error() Object() 以前，这些原生构造函数是无法继承的，比如，不能自己定义一个Array的子类。 function MyArray() { Array.apply(this, arguments); } MyArray.prototype = Object.create(Array.prototype, { constructor: { value: MyArray, writable: true, configurable: true, enumerable: true } }); 上面代码定义了一个继承Array的MyArray类。但是，这个类的行为与Array完全不一致。 var colors = new MyArray(); colors[0] = &quot;red&quot;; colors.length // 0 colors.length = 0; colors[0] // &quot;red&quot; 之所以会发生这种情况，是因为子类无法获得原生构造函数的内部属性，通过Array.apply()或者分配给原型对象都不行。原生构造函数会忽略apply方法传入的this，也就是说，原生构造函数的this无法绑定，导致拿不到内部属性。 ES5是先新建子类的实例对象this，再将父类的属性添加到子类上，由于父类的内部属性无法获取，导致无法继承原生的构造函数。比如，Array构造函数有一个内部属性[[DefineOwnProperty]]，用来定义新属性时，更新length属性，这个内部属性无法在子类获取，导致子类的length属性行为不正常。 下面的例子中，我们想让一个普通对象继承Error对象。 var e = {}; Object.getOwnPropertyNames(Error.call(e)) // [ &#39;stack&#39; ] Object.getOwnPropertyNames(e) // [] 上面代码中，我们想通过Error.call(e)这种写法，让普通对象e具有Error对象的实例属性。但是，Error.call()完全忽略传入的第一个参数，而是返回一个新对象，e本身没有任何变化。这证明了Error.call(e)这种写法，无法继承原生构造函数。 ES6允许继承原生构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修饰this，使得父类的所有行为都可以继承。下面是一个继承Array的例子。 class MyArray extends Array { constructor(...args) { super(...args); } } var arr = new MyArray(); arr[0] = 12; arr.length // 1 arr.length = 0; arr[0] // undefined 上面代码定义了一个MyArray类，继承了Array构造函数，因此就可以从MyArray生成数组的实例。这意味着，ES6可以自定义原生数据结构（比如Array、String等）的子类，这是ES5无法做到的。 上面这个例子也说明，extends关键字不仅可以用来继承类，还可以用来继承原生的构造函数。因此可以在原生数据结构的基础上，定义自己的数据结构。下面就是定义了一个带版本功能的数组。 class VersionedArray extends Array { constructor() { super(); this.history = [[]]; } commit() { this.history.push(this.slice()); } revert() { this.splice(0, this.length, ...this.history[this.history.length - 1]); } } var x = new VersionedArray(); x.push(1); x.push(2); x // [1, 2] x.history // [[]] x.commit(); x.history // [[], [1, 2]] x.push(3); x // [1, 2, 3] x.revert(); x // [1, 2] 上面代码中，VersionedArray结构会通过commit方法，将自己的当前状态存入history属性，然后通过revert方法，可以撤销当前版本，回到上一个版本。除此之外，VersionedArray依然是一个数组，所有原生的数组方法都可以在它上面调用。 下面是一个自定义Error子类的例子。 class ExtendableError extends Error { constructor(message) { super(); this.message = message; this.stack = (new Error()).stack; this.name = this.constructor.name; } } class MyError extends ExtendableError { constructor(m) { super(m); } } var myerror = new MyError(&#39;ll&#39;); myerror.message // &quot;ll&quot; myerror instanceof Error // true myerror.name // &quot;MyError&quot; myerror.stack // Error // at MyError.ExtendableError // ... 注意，继承Object的子类，有一个行为差异。 class NewObj extends Object{ constructor(){ super(...arguments); } } var o = new NewObj({attr: true}); console.log(o.attr === true); // false 上面代码中，NewObj继承了Object，但是无法通过super方法向父类Object传参。这是因为ES6改变了Object构造函数的行为，一旦发现Object方法不是通过new Object()这种形式调用，ES6规定Object构造函数会忽略参数。 Class的取值函数（getter）和存值函数（setter）与ES5一样，在Class内部可以使用get和set关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。 class MyClass { constructor() { // ... } get prop() { return &#39;getter&#39;; } set prop(value) { console.log(&#39;setter: &#39;+value); } } let inst = new MyClass(); inst.prop = 123; // setter: 123 inst.prop // &#39;getter&#39; 上面代码中，prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。 存值函数和取值函数是设置在属性的descriptor对象上的。 class CustomHTMLElement { constructor(element) { this.element = element; } get html() { return this.element.innerHTML; } set html(value) { this.element.innerHTML = value; } } var descriptor = Object.getOwnPropertyDescriptor( CustomHTMLElement.prototype, &quot;html&quot;); &quot;get&quot; in descriptor // true &quot;set&quot; in descriptor // true 上面代码中，存值函数和取值函数是定义在html属性的描述对象上面，这与ES5完全一致。 Class的Generator方法如果某个方法之前加上星号（*），就表示该方法是一个Generator函数。 class Foo { constructor(...args) { this.args = args; } * [Symbol.iterator]() { for (let arg of this.args) { yield arg; } } } for (let x of new Foo(&#39;hello&#39;, &#39;world&#39;)) { console.log(x); } // hello // world 上面代码中，Foo类的Symbol.iterator方法前有一个星号，表示该方法是一个Generator函数。Symbol.iterator方法返回一个Foo类的默认遍历器，for…of循环会自动调用这个遍历器。 Class的静态方法类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前，加上static关键字，就表示该方法不会被实例继承，而是直接通过类来调用，这就称为“静态方法”。 class Foo { static classMethod() { return &#39;hello&#39;; } } Foo.classMethod() // &#39;hello&#39; var foo = new Foo(); foo.classMethod() // TypeError: foo.classMethod is not a function 上面代码中，Foo类的classMethod方法前有static关键字，表明该方法是一个静态方法，可以直接在Foo类上调用（Foo.classMethod()），而不是在Foo类的实例上调用。如果在实例上调用静态方法，会抛出一个错误，表示不存在该方法。 父类的静态方法，可以被子类继承。 class Foo { static classMethod() { return &#39;hello&#39;; } } class Bar extends Foo { } Bar.classMethod(); // &#39;hello&#39; 上面代码中，父类Foo有一个静态方法，子类Bar可以调用这个方法。 静态方法也是可以从super对象上调用的。 class Foo { static classMethod() { return &#39;hello&#39;; } } class Bar extends Foo { static classMethod() { return super.classMethod() + &#39;, too&#39;; } } Bar.classMethod(); Class的静态属性和实例属性静态属性指的是Class本身的属性，即Class.propname，而不是定义在实例对象（this）上的属性。 class Foo { } Foo.prop = 1; Foo.prop // 1 上面的写法为Foo类定义了一个静态属性prop。 目前，只有这种写法可行，因为ES6明确规定，Class内部只有静态方法，没有静态属性。 // 以下两种写法都无效 class Foo { // 写法一 prop: 2 // 写法二 static prop: 2 } Foo.prop // undefined ES7有一个静态属性的提案，目前Babel转码器支持。 这个提案对实例属性和静态属性，都规定了新的写法。 （1）类的实例属性 类的实例属性可以用等式，写入类的定义之中。 class MyClass { myProp = 42; constructor() { console.log(this.myProp); // 42 } } 上面代码中，myProp就是MyClass的实例属性。在MyClass的实例上，可以读取这个属性。 以前，我们定义实例属性，只能写在类的constructor方法里面。 class ReactCounter extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } } 上面代码中，构造方法constructor里面，定义了this.state属性。 有了新的写法以后，可以不在constructor方法里面定义。 class ReactCounter extends React.Component { state = { count: 0 }; } 这种写法比以前更清晰。 为了可读性的目的，对于那些在constructor里面已经定义的实例属性，新写法允许直接列出。 class ReactCounter extends React.Component { constructor(props) { super(props); this.state = { count: 0 }; } state; } （2）类的静态属性 类的静态属性只要在上面的实例属性写法前面，加上static关键字就可以了。 class MyClass { static myStaticProp = 42; constructor() { console.log(MyClass.myProp); // 42 } } 同样的，这个新写法大大方便了静态属性的表达。 // 老写法 class Foo { } Foo.prop = 1; // 新写法 class Foo { static prop = 1; } 上面代码中，老写法的静态属性定义在类的外部。整个类生成以后，再生成静态属性。这样让人很容易忽略这个静态属性，也不符合相关代码应该放在一起的代码组织原则。另外，新写法是显式声明（declarative），而不是赋值处理，语义更好。 new.target属性new是从构造函数生成实例的命令。ES6为new命令引入了一个new.target属性，（在构造函数中）返回new命令作用于的那个构造函数。如果构造函数不是通过new命令调用的，new.target会返回undefined，因此这个属性可以用来确定构造函数是怎么调用的。 function Person(name) { if (new.target !== undefined) { this.name = name; } else { throw new Error(&#39;必须使用new生成实例&#39;); } } // 另一种写法 function Person(name) { if (new.target === Person) { this.name = name; } else { throw new Error(&#39;必须使用new生成实例&#39;); } } var person = new Person(&#39;张三&#39;); // 正确 var notAPerson = Person.call(person, &#39;张三&#39;); // 报错 上面代码确保构造函数只能通过new命令调用。 Class内部调用new.target，返回当前Class。 class Rectangle { constructor(length, width) { console.log(new.target === Rectangle); this.length = length; this.width = width; } } var obj = new Rectangle(3, 4); // 输出 true 需要注意的是，子类继承父类时，new.target会返回子类。 class Rectangle { constructor(length, width) { console.log(new.target === Rectangle); // ... } } class Square extends Rectangle { constructor(length) { super(length, length); } } var obj = new Square(3); // 输出 false 上面代码中，new.target会返回子类。 利用这个特点，可以写出不能独立使用、必须继承后才能使用的类。 class Shape { constructor() { if (new.target === Shape) { throw new Error(&#39;本类不能实例化&#39;); } } } class Rectangle extends Shape { constructor(length, width) { super(); // ... } } var x = new Shape(); // 报错 var y = new Rectangle(3, 4); // 正确 上面代码中，Shape类不能被实例化，只能用于继承。 注意，在函数外部，使用new.target会报错。 Mixin模式的实现Mixin模式指的是，将多个类的接口“混入”（mix in）另一个类。它在ES6的实现如下。 function mix(...mixins) { class Mix {} for (let mixin of mixins) { copyProperties(Mix, mixin); copyProperties(Mix.prototype, mixin.prototype); } return Mix; } function copyProperties(target, source) { for (let key of Reflect.ownKeys(source)) { if ( key !== &quot;constructor&quot; &amp;&amp; key !== &quot;prototype&quot; &amp;&amp; key !== &quot;name&quot; ) { let desc = Object.getOwnPropertyDescriptor(source, key); Object.defineProperty(target, key, desc); } } } 上面代码的mix函数，可以将多个对象合成为一个类。使用的时候，只要继承这个类即可。 class DistributedEdit extends mix(Loggable, Serializable) { // ... } 感谢阮一峰老师的原创，本分享仅供学习交流","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Class","slug":"Class","permalink":"https://microzz.com/tags/Class/"}]},{"title":"异步操作和Async函数","date":"2017-01-15T06:58:52.000Z","path":"2017/01/15/async/","text":"异步操作和Async函数异步编程对 JavaScript 语言太重要。Javascript 语言的执行环境是“单线程”的，如果没有异步编程，根本没法用，非卡死不可。本章主要介绍如何 Generator 函数完成异步操作。 ES6诞生以前，异步编程的方法，大概有下面四种。 回调函数 事件监听 发布/订阅 Promise 对象 Generator 函数将 JavaScript 异步编程带入了一个全新的阶段。 基本概念异步所谓”异步”，简单说就是一个任务不是连续完成的，可以理解成该任务被人为分成两段，先执行第一段，然后转而执行其他任务，等做好了准备，再回过头执行第二段。 比如，有一个任务是读取文件进行处理，任务的第一段是向操作系统发出请求，要求读取文件。然后，程序执行其他任务，等到操作系统返回文件，再接着执行任务的第二段（处理文件）。这种不连续的执行，就叫做异步。 相应地，连续的执行就叫做同步。由于是连续执行，不能插入其他任务，所以操作系统从硬盘读取文件的这段时间，程序只能干等着。 回调函数JavaScript 语言对异步编程的实现，就是回调函数。所谓回调函数，就是把任务的第二段单独写在一个函数里面，等到重新执行这个任务的时候，就直接调用这个函数。回调函数的英语名字callback，直译过来就是”重新调用”。 读取文件进行处理，是这样写的。 fs.readFile(&#39;/etc/passwd&#39;, &#39;utf-8&#39;, function (err, data) { if (err) throw err; console.log(data); }); 上面代码中，readFile函数的第三个参数，就是回调函数，也就是任务的第二段。等到操作系统返回了/etc/passwd这个文件以后，回调函数才会执行。 一个有趣的问题是，为什么 Node 约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null）？ 原因是执行分成两段，第一段执行完以后，任务所在的上下文环境就已经结束了。在这以后抛出的错误，原来的上下文环境已经无法捕捉，只能当作参数，传入第二段。 Promise回调函数本身并没有问题，它的问题出现在多个回调函数嵌套。假定读取A文件之后，再读取B文件，代码如下。 fs.readFile(fileA, &#39;utf-8&#39;, function (err, data) { fs.readFile(fileB, &#39;utf-8&#39;, function (err, data) { // ... }); }); 不难想象，如果依次读取两个以上的文件，就会出现多重嵌套。代码不是纵向发展，而是横向发展，很快就会乱成一团，无法管理。因为多个异步操作形成了强耦合，只要有一个操作需要修改，它的上层回调函数和下层回调函数，可能都要跟着修改。这种情况就称为”回调函数地狱”（callback hell）。 Promise 对象就是为了解决这个问题而提出的。它不是新的语法功能，而是一种新的写法，允许将回调函数的嵌套，改成链式调用。采用 Promise，连续读取多个文件，写法如下。 var readFile = require(&#39;fs-readfile-promise&#39;); readFile(fileA) .then(function (data) { console.log(data.toString()); }) .then(function () { return readFile(fileB); }) .then(function (data) { console.log(data.toString()); }) .catch(function (err) { console.log(err); }); 上面代码中，我使用了fs-readfile-promise模块，它的作用就是返回一个 Promise 版本的readFile函数。Promise 提供then方法加载回调函数，catch方法捕捉执行过程中抛出的错误。 可以看到，Promise 的写法只是回调函数的改进，使用then方法以后，异步任务的两段执行看得更清楚了，除此以外，并无新意。 Promise 的最大问题是代码冗余，原来的任务被 Promise 包装了一下，不管什么操作，一眼看去都是一堆then，原来的语义变得很不清楚。 那么，有没有更好的写法呢？ Generator函数协程传统的编程语言，早有异步编程的解决方案（其实是多任务的解决方案）。其中有一种叫做”协程”（coroutine），意思是多个线程互相协作，完成异步任务。 协程有点像函数，又有点像线程。它的运行流程大致如下。 第一步，协程A开始执行。 第二步，协程A执行到一半，进入暂停，执行权转移到协程B。 第三步，（一段时间后）协程B交还执行权。 第四步，协程A恢复执行。 上面流程的协程A，就是异步任务，因为它分成两段（或多段）执行。 举例来说，读取文件的协程写法如下。 function *asyncJob() { // ...其他代码 var f = yield readFile(fileA); // ...其他代码 } 上面代码的函数asyncJob是一个协程，它的奥妙就在其中的yield命令。它表示执行到此处，执行权将交给其他协程。也就是说，yield命令是异步两个阶段的分界线。 协程遇到yield命令就暂停，等到执行权返回，再从暂停的地方继续往后执行。它的最大优点，就是代码的写法非常像同步操作，如果去除yield命令，简直一模一样。 Generator 函数的概念Generator 函数是协程在 ES6 的实现，最大特点就是可以交出函数的执行权（即暂停执行）。 整个 Generator 函数就是一个封装的异步任务，或者说是异步任务的容器。异步操作需要暂停的地方，都用yield语句注明。Generator 函数的执行方法如下。 function* gen(x) { var y = yield x + 2; return y; } var g = gen(1); g.next() // { value: 3, done: false } g.next() // { value: undefined, done: true } 上面代码中，调用 Generator 函数，会返回一个内部指针（即遍历器）g。这是 Generator 函数不同于普通函数的另一个地方，即执行它不会返回结果，返回的是指针对象。调用指针g的next方法，会移动内部指针（即执行异步任务的第一段），指向第一个遇到的yield语句，上例是执行到x + 2为止。 换言之，next方法的作用是分阶段执行Generator函数。每次调用next方法，会返回一个对象，表示当前阶段的信息（value属性和done属性）。value属性是yield语句后面表达式的值，表示当前阶段的值；done属性是一个布尔值，表示 Generator 函数是否执行完毕，即是否还有下一个阶段。 Generator 函数的数据交换和错误处理Generator函数可以暂停执行和恢复执行，这是它能封装异步任务的根本原因。除此之外，它还有两个特性，使它可以作为异步编程的完整解决方案：函数体内外的数据交换和错误处理机制。 next方法返回值的value属性，是Generator函数向外输出数据；next方法还可以接受参数，这是向Generator函数体内输入数据。 function* gen(x){ var y = yield x + 2; return y; } var g = gen(1); g.next() // { value: 3, done: false } g.next(2) // { value: 2, done: true } 上面代码中，第一个next方法的value属性，返回表达式x + 2的值（3）。第二个next方法带有参数2，这个参数可以传入 Generator 函数，作为上个阶段异步任务的返回结果，被函数体内的变量y接收。因此，这一步的 value 属性，返回的就是2（变量y的值）。 Generator 函数内部还可以部署错误处理代码，捕获函数体外抛出的错误。 function* gen(x){ try { var y = yield x + 2; } catch (e){ console.log(e); } return y; } var g = gen(1); g.next(); g.throw(&#39;出错了&#39;); // 出错了 上面代码的最后一行，Generator函数体外，使用指针对象的throw方法抛出的错误，可以被函数体内的try …catch代码块捕获。这意味着，出错的代码与处理错误的代码，实现了时间和空间上的分离，这对于异步编程无疑是很重要的。 异步任务的封装下面看看如何使用 Generator 函数，执行一个真实的异步任务。 var fetch = require(&#39;node-fetch&#39;); function* gen(){ var url = &#39;https://api.github.com/users/github&#39;; var result = yield fetch(url); console.log(result.bio); } 上面代码中，Generator函数封装了一个异步操作，该操作先读取一个远程接口，然后从JSON格式的数据解析信息。就像前面说过的，这段代码非常像同步操作，除了加上了yield命令。 执行这段代码的方法如下。 var g = gen(); var result = g.next(); result.value.then(function(data){ return data.json(); }).then(function(data){ g.next(data); }); 上面代码中，首先执行Generator函数，获取遍历器对象，然后使用next 方法（第二行），执行异步任务的第一阶段。由于Fetch模块返回的是一个Promise对象，因此要用then方法调用下一个next 方法。 可以看到，虽然 Generator 函数将异步操作表示得很简洁，但是流程管理却不方便（即何时执行第一阶段、何时执行第二阶段）。 Thunk函数参数的求值策略Thunk函数早在上个世纪60年代就诞生了。 那时，编程语言刚刚起步，计算机学家还在研究，编译器怎么写比较好。一个争论的焦点是”求值策略”，即函数的参数到底应该何时求值。 var x = 1; function f(m){ return m * 2; } f(x + 5) 上面代码先定义函数f，然后向它传入表达式x + 5。请问，这个表达式应该何时求值？ 一种意见是”传值调用”（call by value），即在进入函数体之前，就计算x + 5的值（等于6），再将这个值传入函数f 。C语言就采用这种策略。 f(x + 5) // 传值调用时，等同于 f(6) 另一种意见是”传名调用”（call by name），即直接将表达式x + 5传入函数体，只在用到它的时候求值。Haskell语言采用这种策略。 f(x + 5) // 传名调用时，等同于 (x + 5) * 2 传值调用和传名调用，哪一种比较好？回答是各有利弊。传值调用比较简单，但是对参数求值的时候，实际上还没用到这个参数，有可能造成性能损失。 function f(a, b){ return b; } f(3 * x * x - 2 * x - 1, x); 上面代码中，函数f的第一个参数是一个复杂的表达式，但是函数体内根本没用到。对这个参数求值，实际上是不必要的。因此，有一些计算机学家倾向于”传名调用”，即只在执行时求值。 Thunk函数的含义编译器的”传名调用”实现，往往是将参数放到一个临时函数之中，再将这个临时函数传入函数体。这个临时函数就叫做Thunk函数。 function f(m){ return m * 2; } f(x + 5); // 等同于 var thunk = function () { return x + 5; }; function f(thunk){ return thunk() * 2; } 上面代码中，函数f的参数x + 5被一个函数替换了。凡是用到原参数的地方，对Thunk函数求值即可。 这就是Thunk函数的定义，它是”传名调用”的一种实现策略，用来替换某个表达式。 JavaScript语言的Thunk函数JavaScript语言是传值调用，它的Thunk函数含义有所不同。在JavaScript语言中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成单参数的版本，且只接受回调函数作为参数。 // 正常版本的readFile（多参数版本） fs.readFile(fileName, callback); // Thunk版本的readFile（单参数版本） var Thunk = function (fileName){ return function (callback){ return fs.readFile(fileName, callback); }; }; var readFileThunk = Thunk(fileName); readFileThunk(callback); 上面代码中，fs模块的readFile方法是一个多参数函数，两个参数分别为文件名和回调函数。经过转换器处理，它变成了一个单参数函数，只接受回调函数作为参数。这个单参数版本，就叫做Thunk函数。 任何函数，只要参数有回调函数，就能写成Thunk函数的形式。下面是一个简单的Thunk函数转换器。 // ES5版本 var Thunk = function(fn){ return function (){ var args = Array.prototype.slice.call(arguments); return function (callback){ args.push(callback); return fn.apply(this, args); } }; }; // ES6版本 var Thunk = function(fn) { return function (...args) { return function (callback) { return fn.call(this, ...args, callback); } }; }; 使用上面的转换器，生成fs.readFile的Thunk函数。 var readFileThunk = Thunk(fs.readFile); readFileThunk(fileA)(callback); 下面是另一个完整的例子。 function f(a, cb) { cb(a); } let ft = Thunk(f); let log = console.log.bind(console); ft(1)(log) // 1 Thunkify模块生产环境的转换器，建议使用Thunkify模块。 首先是安装。 $ npm install thunkify 使用方式如下。 var thunkify = require(&#39;thunkify&#39;); var fs = require(&#39;fs&#39;); var read = thunkify(fs.readFile); read(&#39;package.json&#39;)(function(err, str){ // ... }); Thunkify的源码与上一节那个简单的转换器非常像。 function thunkify(fn){ return function(){ var args = new Array(arguments.length); var ctx = this; for(var i = 0; i &lt; args.length; ++i) { args[i] = arguments[i]; } return function(done){ var called; args.push(function(){ if (called) return; called = true; done.apply(null, arguments); }); try { fn.apply(ctx, args); } catch (err) { done(err); } } } }; 它的源码主要多了一个检查机制，变量called确保回调函数只运行一次。这样的设计与下文的Generator函数相关。请看下面的例子。 function f(a, b, callback){ var sum = a + b; callback(sum); callback(sum); } var ft = thunkify(f); var print = console.log.bind(console); ft(1, 2)(print); // 3 上面代码中，由于thunkify只允许回调函数执行一次，所以只输出一行结果。 Generator 函数的流程管理你可能会问， Thunk函数有什么用？回答是以前确实没什么用，但是ES6有了Generator函数，Thunk函数现在可以用于Generator函数的自动流程管理。 Generator函数可以自动执行。 function* gen() { // ... } var g = gen(); var res = g.next(); while(!res.done){ console.log(res.value); res = g.next(); } 上面代码中，Generator函数gen会自动执行完所有步骤。 但是，这不适合异步操作。如果必须保证前一步执行完，才能执行后一步，上面的自动执行就不可行。这时，Thunk函数就能派上用处。以读取文件为例。下面的Generator函数封装了两个异步操作。 var fs = require(&#39;fs&#39;); var thunkify = require(&#39;thunkify&#39;); var readFile = thunkify(fs.readFile); var gen = function* (){ var r1 = yield readFile(&#39;/etc/fstab&#39;); console.log(r1.toString()); var r2 = yield readFile(&#39;/etc/shells&#39;); console.log(r2.toString()); }; 上面代码中，yield命令用于将程序的执行权移出Generator函数，那么就需要一种方法，将执行权再交还给Generator函数。 这种方法就是Thunk函数，因为它可以在回调函数里，将执行权交还给Generator函数。为了便于理解，我们先看如何手动执行上面这个Generator函数。 var g = gen(); var r1 = g.next(); r1.value(function(err, data){ if (err) throw err; var r2 = g.next(data); r2.value(function(err, data){ if (err) throw err; g.next(data); }); }); 上面代码中，变量g是Generator函数的内部指针，表示目前执行到哪一步。next方法负责将指针移动到下一步，并返回该步的信息（value属性和done属性）。 仔细查看上面的代码，可以发现Generator函数的执行过程，其实是将同一个回调函数，反复传入next方法的value属性。这使得我们可以用递归来自动完成这个过程。 Thunk函数的自动流程管理Thunk函数真正的威力，在于可以自动执行Generator函数。下面就是一个基于Thunk函数的Generator执行器。 function run(fn) { var gen = fn(); function next(err, data) { var result = gen.next(data); if (result.done) return; result.value(next); } next(); } function* g() { // ... } run(g); 上面代码的run函数，就是一个Generator函数的自动执行器。内部的next函数就是Thunk的回调函数。next函数先将指针移到Generator函数的下一步（gen.next方法），然后判断Generator函数是否结束（result.done属性），如果没结束，就将next函数再传入Thunk函数（result.value属性），否则就直接退出。 有了这个执行器，执行Generator函数方便多了。不管内部有多少个异步操作，直接把Generator函数传入run函数即可。当然，前提是每一个异步操作，都要是Thunk函数，也就是说，跟在yield命令后面的必须是Thunk函数。 var g = function* (){ var f1 = yield readFile(&#39;fileA&#39;); var f2 = yield readFile(&#39;fileB&#39;); // ... var fn = yield readFile(&#39;fileN&#39;); }; run(g); 上面代码中，函数g封装了n个异步的读取文件操作，只要执行run函数，这些操作就会自动完成。这样一来，异步操作不仅可以写得像同步操作，而且一行代码就可以执行。 Thunk函数并不是Generator函数自动执行的唯一方案。因为自动执行的关键是，必须有一种机制，自动控制Generator函数的流程，接收和交还程序的执行权。回调函数可以做到这一点，Promise 对象也可以做到这一点。 co模块基本用法co模块是著名程序员TJ Holowaychuk于2013年6月发布的一个小工具，用于Generator函数的自动执行。 比如，有一个Generator函数，用于依次读取两个文件。 var gen = function* (){ var f1 = yield readFile(&#39;/etc/fstab&#39;); var f2 = yield readFile(&#39;/etc/shells&#39;); console.log(f1.toString()); console.log(f2.toString()); }; co模块可以让你不用编写Generator函数的执行器。 var co = require(&#39;co&#39;); co(gen); 上面代码中，Generator函数只要传入co函数，就会自动执行。 co函数返回一个Promise对象，因此可以用then方法添加回调函数。 co(gen).then(function (){ console.log(&#39;Generator 函数执行完成&#39;); }); 上面代码中，等到Generator函数执行结束，就会输出一行提示。 co模块的原理为什么 co 可以自动执行 Generator 函数？ 前面说过，Generator 就是一个异步操作的容器。它的自动执行需要一种机制，当异步操作有了结果，能够自动交回执行权。 两种方法可以做到这一点。 （1）回调函数。将异步操作包装成 Thunk 函数，在回调函数里面交回执行权。 （2）Promise 对象。将异步操作包装成 Promise 对象，用then方法交回执行权。 co 模块其实就是将两种自动执行器（Thunk 函数和 Promise 对象），包装成一个模块。使用 co 的前提条件是，Generator 函数的yield命令后面，只能是 Thunk 函数或 Promise 对象。 上一节已经介绍了基于 Thunk 函数的自动执行器。下面来看，基于 Promise 对象的自动执行器。这是理解 co 模块必须的。 基于 Promise 对象的自动执行还是沿用上面的例子。首先，把fs模块的readFile方法包装成一个 Promise 对象。 var fs = require(&#39;fs&#39;); var readFile = function (fileName){ return new Promise(function (resolve, reject){ fs.readFile(fileName, function(error, data){ if (error) return reject(error); resolve(data); }); }); }; var gen = function* (){ var f1 = yield readFile(&#39;/etc/fstab&#39;); var f2 = yield readFile(&#39;/etc/shells&#39;); console.log(f1.toString()); console.log(f2.toString()); }; 然后，手动执行上面的 Generator 函数。 var g = gen(); g.next().value.then(function(data){ g.next(data).value.then(function(data){ g.next(data); }); }); 手动执行其实就是用then方法，层层添加回调函数。理解了这一点，就可以写出一个自动执行器。 function run(gen){ var g = gen(); function next(data){ var result = g.next(data); if (result.done) return result.value; result.value.then(function(data){ next(data); }); } next(); } run(gen); 上面代码中，只要 Generator 函数还没执行到最后一步，next函数就调用自身，以此实现自动执行。 co 模块的源码co 就是上面那个自动执行器的扩展，它的源码只有几十行，非常简单。 首先，co 函数接受 Generator 函数作为参数，返回一个 Promise 对象。 function co(gen) { var ctx = this; return new Promise(function(resolve, reject) { }); } 在返回的 Promise 对象里面，co 先检查参数gen是否为 Generator 函数。如果是，就执行该函数，得到一个内部指针对象；如果不是就返回，并将 Promise 对象的状态改为resolved。 function co(gen) { var ctx = this; return new Promise(function(resolve, reject) { if (typeof gen === &#39;function&#39;) gen = gen.call(ctx); if (!gen || typeof gen.next !== &#39;function&#39;) return resolve(gen); }); } 接着，co 将 Generator 函数的内部指针对象的next方法，包装成onFulfilled函数。这主要是为了能够捕捉抛出的错误。 function co(gen) { var ctx = this; return new Promise(function(resolve, reject) { if (typeof gen === &#39;function&#39;) gen = gen.call(ctx); if (!gen || typeof gen.next !== &#39;function&#39;) return resolve(gen); onFulfilled(); function onFulfilled(res) { var ret; try { ret = gen.next(res); } catch (e) { return reject(e); } next(ret); } }); } 最后，就是关键的next函数，它会反复调用自身。 function next(ret) { if (ret.done) return resolve(ret.value); var value = toPromise.call(ctx, ret.value); if (value &amp;&amp; isPromise(value)) return value.then(onFulfilled, onRejected); return onRejected( new TypeError( &#39;You may only yield a function, promise, generator, array, or object, &#39; + &#39;but the following object was passed: &quot;&#39; + String(ret.value) + &#39;&quot;&#39; ) ); } 上面代码中，next函数的内部代码，一共只有四行命令。 第一行，检查当前是否为 Generator 函数的最后一步，如果是就返回。 第二行，确保每一步的返回值，是 Promise 对象。 第三行，使用then方法，为返回值加上回调函数，然后通过onFulfilled函数再次调用next函数。 第四行，在参数不符合要求的情况下（参数非 Thunk 函数和 Promise 对象），将 Promise 对象的状态改为rejected，从而终止执行。 处理并发的异步操作co 支持并发的异步操作，即允许某些操作同时进行，等到它们全部完成，才进行下一步。 这时，要把并发的操作都放在数组或对象里面，跟在yield语句后面。 // 数组的写法 co(function* () { var res = yield [ Promise.resolve(1), Promise.resolve(2) ]; console.log(res); }).catch(onerror); // 对象的写法 co(function* () { var res = yield { 1: Promise.resolve(1), 2: Promise.resolve(2), }; console.log(res); }).catch(onerror); 下面是另一个例子。 co(function* () { var values = [n1, n2, n3]; yield values.map(somethingAsync); }); function* somethingAsync(x) { // do something async return y } 上面的代码允许并发三个somethingAsync异步操作，等到它们全部完成，才会进行下一步。IT技术分享尽在🔗 涵月天-microzz.comhttps://microzz.com async函数含义ES2017 标准提供了async函数，使得异步操作变得更加方便。 async函数是什么？一句话，async函数就是 Generator 函数的语法糖。前文有一个 Generator 函数，依次读取两个文件。 var fs = require(&#39;fs&#39;); var readFile = function (fileName) { return new Promise(function (resolve, reject) { fs.readFile(fileName, function(error, data) { if (error) reject(error); resolve(data); }); }); }; var gen = function* (){ var f1 = yield readFile(&#39;/etc/fstab&#39;); var f2 = yield readFile(&#39;/etc/shells&#39;); console.log(f1.toString()); console.log(f2.toString()); }; 写成async函数，就是下面这样。 var asyncReadFile = async function (){ var f1 = await readFile(&#39;/etc/fstab&#39;); var f2 = await readFile(&#39;/etc/shells&#39;); console.log(f1.toString()); console.log(f2.toString()); }; 一比较就会发现，async函数就是将 Generator 函数的星号（*）替换成async，将yield替换成await，仅此而已。 async函数对 Generator 函数的改进，体现在以下四点。 （1）内置执行器。Generator 函数的执行必须靠执行器，所以才有了co模块，而async函数自带执行器。也就是说，async函数的执行，与普通函数一模一样，只要一行。 var result = asyncReadFile(); 上面的代码调用了asyncReadFile函数，然后它就会自动执行，输出最后结果。这完全不像 Generator 函数，需要调用next方法，或者用co模块，才能得到真正执行，得到最后结果。 （2）更好的语义。async和await，比起星号和yield，语义更清楚了。async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。 （3）更广的适用性。 co模块约定，yield命令后面只能是 Thunk 函数或 Promise 对象，而async函数的await命令后面，可以是Promise 对象和原始类型的值（数值、字符串和布尔值，但这时等同于同步操作）。 （4）返回值是 Promise。async函数的返回值是 Promise 对象，这比 Generator 函数的返回值是 Iterator 对象方便多了。你可以用then方法指定下一步的操作。 进一步说，async函数完全可以看作多个异步操作，包装成的一个 Promise 对象，而await命令就是内部then命令的语法糖。 语法async函数的语法规则总体上比较简单，难点是错误处理机制。 （1）async函数返回一个Promise对象。 async函数内部return语句返回的值，会成为then方法回调函数的参数。 async function f() { return &#39;hello world&#39;; } f().then(v =&gt; console.log(v)) // &quot;hello world&quot; 上面代码中，函数f内部return命令返回的值，会被then方法回调函数接收到。 async函数内部抛出错误，会导致返回的 Promise 对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。 async function f() { throw new Error(&#39;出错了&#39;); } f().then( v =&gt; console.log(v), e =&gt; console.log(e) ) // Error: 出错了 （2）async函数返回的 Promise 对象，必须等到内部所有await命令的 Promise 对象执行完，才会发生状态改变，除非遇到return语句或者抛出错误。也就是说，只有async函数内部的异步操作执行完，才会执行then方法指定的回调函数。 下面是一个例子。 async function getTitle(url) { let response = await fetch(url); let html = await response.text(); return html.match(/&lt;title&gt;([\\s\\S]+)&lt;\\/title&gt;/i)[1]; } getTitle(&#39;https://tc39.github.io/ecma262/&#39;).then(console.log) // &quot;ECMAScript 2017 Language Specification&quot; 上面代码中，函数getTitle内部有三个操作：抓取网页、取出文本、匹配页面标题。只有这三个操作全部完成，才会执行then方法里面的console.log。 （3）正常情况下，await命令后面是一个 Promise 对象。如果不是，会被转成一个立即resolve的 Promise 对象。 async function f() { return await 123; } f().then(v =&gt; console.log(v)) // 123 上面代码中，await命令的参数是数值123，它被转成Promise对象，并立即resolve。 await命令后面的Promise对象如果变为reject状态，则reject的参数会被catch方法的回调函数接收到。 async function f() { await Promise.reject(&#39;出错了&#39;); } f() .then(v =&gt; console.log(v)) .catch(e =&gt; console.log(e)) // 出错了 注意，上面代码中，await语句前面没有return，但是reject方法的参数依然传入了catch方法的回调函数。这里如果在await前面加上return，效果是一样的。 只要一个await语句后面的Promise变为reject，那么整个async函数都会中断执行。 async function f() { await Promise.reject(&#39;出错了&#39;); await Promise.resolve(&#39;hello world&#39;); // 不会执行 } 上面代码中，第二个await语句是不会执行的，因为第一个await语句状态变成了reject。 为了避免这个问题，可以将第一个await放在try...catch结构里面，这样第二个await就会执行。 async function f() { try { await Promise.reject(&#39;出错了&#39;); } catch(e) { } return await Promise.resolve(&#39;hello world&#39;); } f() .then(v =&gt; console.log(v)) // hello world 另一种方法是await后面的Promise对象再跟一个catch方法，处理前面可能出现的错误。 async function f() { await Promise.reject(&#39;出错了&#39;) .catch(e =&gt; console.log(e)); return await Promise.resolve(&#39;hello world&#39;); } f() .then(v =&gt; console.log(v)) // 出错了 // hello world 如果有多个await命令，可以统一放在try...catch结构中。 async function main() { try { var val1 = await firstStep(); var val2 = await secondStep(val1); var val3 = await thirdStep(val1, val2); console.log(&#39;Final: &#39;, val3); } catch (err) { console.error(err); } } （4）如果await后面的异步操作出错，那么等同于async函数返回的Promise对象被reject。 async function f() { await new Promise(function (resolve, reject) { throw new Error(&#39;出错了&#39;); }); } f() .then(v =&gt; console.log(v)) .catch(e =&gt; console.log(e)) // Error：出错了 上面代码中，async函数f执行后，await后面的Promise对象会抛出一个错误对象，导致catch方法的回调函数被调用，它的参数就是抛出的错误对象。具体的执行机制，可以参考后文的“async函数的实现”。 防止出错的方法，也是将其放在try...catch代码块之中。 async function f() { try { await new Promise(function (resolve, reject) { throw new Error(&#39;出错了&#39;); }); } catch(e) { } return await(&#39;hello world&#39;); } async函数的实现async 函数的实现，就是将 Generator 函数和自动执行器，包装在一个函数里。 async function fn(args){ // ... } // 等同于 function fn(args){ return spawn(function*() { // ... }); } 所有的async函数都可以写成上面的第二种形式，其中的 spawn 函数就是自动执行器。 下面给出spawn函数的实现，基本就是前文自动执行器的翻版。 function spawn(genF) { return new Promise(function(resolve, reject) { var gen = genF(); function step(nextF) { try { var next = nextF(); } catch(e) { return reject(e); } if(next.done) { return resolve(next.value); } Promise.resolve(next.value).then(function(v) { step(function() { return gen.next(v); }); }, function(e) { step(function() { return gen.throw(e); }); }); } step(function() { return gen.next(undefined); }); }); } async 函数的用法async函数返回一个Promise对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到触发的异步操作完成，再接着执行函数体内后面的语句。 下面是一个例子。 async function getStockPriceByName(name) { var symbol = await getStockSymbol(name); var stockPrice = await getStockPrice(symbol); return stockPrice; } getStockPriceByName(&#39;goog&#39;).then(function (result) { console.log(result); }); 上面代码是一个获取股票报价的函数，函数前面的async关键字，表明该函数内部有异步操作。调用该函数时，会立即返回一个Promise对象。 下面的例子，指定多少毫秒后输出一个值。 function timeout(ms) { return new Promise((resolve) =&gt; { setTimeout(resolve, ms); }); } async function asyncPrint(value, ms) { await timeout(ms); console.log(value) } asyncPrint(&#39;hello world&#39;, 50); 上面代码指定50毫秒以后，输出hello world。 Async函数有多种使用形式。 // 函数声明 async function foo() {} // 函数表达式 const foo = async function () {}; // 对象的方法 let obj = { async foo() {} }; obj.foo().then(...) // Class 的方法 class Storage { constructor() { this.cachePromise = caches.open(&#39;avatars&#39;); } async getAvatar(name) { const cache = await this.cachePromise; return cache.match(`/avatars/${name}.jpg`); } } const storage = new Storage(); storage.getAvatar(&#39;jake&#39;).then(…); // 箭头函数 const foo = async () =&gt; {}; 注意点第一点，await命令后面的Promise对象，运行结果可能是rejected，所以最好把await命令放在try...catch代码块中。 async function myFunction() { try { await somethingThatReturnsAPromise(); } catch (err) { console.log(err); } } // 另一种写法 async function myFunction() { await somethingThatReturnsAPromise() .catch(function (err) { console.log(err); }; } 第二点，多个await命令后面的异步操作，如果不存在继发关系，最好让它们同时触发。 let foo = await getFoo(); let bar = await getBar(); 上面代码中，getFoo和getBar是两个独立的异步操作（即互不依赖），被写成继发关系。这样比较耗时，因为只有getFoo完成以后，才会执行getBar，完全可以让它们同时触发。 // 写法一 let [foo, bar] = await Promise.all([getFoo(), getBar()]); // 写法二 let fooPromise = getFoo(); let barPromise = getBar(); let foo = await fooPromise; let bar = await barPromise; 上面两种写法，getFoo和getBar都是同时触发，这样就会缩短程序的执行时间。 第三点，await命令只能用在async函数之中，如果用在普通函数，就会报错。 async function dbFuc(db) { let docs = [{}, {}, {}]; // 报错 docs.forEach(function (doc) { await db.post(doc); }); } 上面代码会报错，因为await用在普通函数之中了。但是，如果将forEach方法的参数改成async函数，也有问题。 async function dbFuc(db) { let docs = [{}, {}, {}]; // 可能得到错误结果 docs.forEach(async function (doc) { await db.post(doc); }); } 上面代码可能不会正常工作，原因是这时三个db.post操作将是并发执行，也就是同时执行，而不是继发执行。正确的写法是采用for循环。 async function dbFuc(db) { let docs = [{}, {}, {}]; for (let doc of docs) { await db.post(doc); } } 如果确实希望多个请求并发执行，可以使用Promise.all方法。 async function dbFuc(db) { let docs = [{}, {}, {}]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = await Promise.all(promises); console.log(results); } // 或者使用下面的写法 async function dbFuc(db) { let docs = [{}, {}, {}]; let promises = docs.map((doc) =&gt; db.post(doc)); let results = []; for (let promise of promises) { results.push(await promise); } console.log(results); } ES6将await增加为保留字。使用这个词作为标识符，在ES5是合法的，在ES6将抛出SyntaxError。 与Promise、Generator的比较我们通过一个例子，来看Async函数与Promise、Generator函数的区别。 假定某个DOM元素上面，部署了一系列的动画，前一个动画结束，才能开始后一个。如果当中有一个动画出错，就不再往下执行，返回上一个成功执行的动画的返回值。 首先是Promise的写法。 function chainAnimationsPromise(elem, animations) { // 变量ret用来保存上一个动画的返回值 var ret = null; // 新建一个空的Promise var p = Promise.resolve(); // 使用then方法，添加所有动画 for(var anim of animations) { p = p.then(function(val) { ret = val; return anim(elem); }); } // 返回一个部署了错误捕捉机制的Promise return p.catch(function(e) { /* 忽略错误，继续执行 */ }).then(function() { return ret; }); } 虽然Promise的写法比回调函数的写法大大改进，但是一眼看上去，代码完全都是Promise的API（then、catch等等），操作本身的语义反而不容易看出来。 接着是Generator函数的写法。 function chainAnimationsGenerator(elem, animations) { return spawn(function*() { var ret = null; try { for(var anim of animations) { ret = yield anim(elem); } } catch(e) { /* 忽略错误，继续执行 */ } return ret; }); } 上面代码使用Generator函数遍历了每个动画，语义比Promise写法更清晰，用户定义的操作全部都出现在spawn函数的内部。这个写法的问题在于，必须有一个任务运行器，自动执行Generator函数，上面代码的spawn函数就是自动执行器，它返回一个Promise对象，而且必须保证yield语句后面的表达式，必须返回一个Promise。 最后是Async函数的写法。 async function chainAnimationsAsync(elem, animations) { var ret = null; try { for(var anim of animations) { ret = await anim(elem); } } catch(e) { /* 忽略错误，继续执行 */ } return ret; } 可以看到Async函数的实现最简洁，最符合语义，几乎没有语义不相关的代码。它将Generator写法中的自动执行器，改在语言层面提供，不暴露给用户，因此代码量最少。如果使用Generator写法，自动执行器需要用户自己提供。 实例：按顺序完成异步操作实际开发中，经常遇到一组异步操作，需要按照顺序完成。比如，依次远程读取一组URL，然后按照读取的顺序输出结果。 Promise 的写法如下。 function logInOrder(urls) { // 远程读取所有URL const textPromises = urls.map(url =&gt; { return fetch(url).then(response =&gt; response.text()); }); // 按次序输出 textPromises.reduce((chain, textPromise) =&gt; { return chain.then(() =&gt; textPromise) .then(text =&gt; console.log(text)); }, Promise.resolve()); } 上面代码使用fetch方法，同时远程读取一组URL。每个fetch操作都返回一个Promise对象，放入textPromises数组。然后，reduce方法依次处理每个Promise对象，然后使用then，将所有Promise对象连起来，因此就可以依次输出结果。 这种写法不太直观，可读性比较差。下面是async函数实现。 async function logInOrder(urls) { for (const url of urls) { const response = await fetch(url); console.log(await response.text()); } } 上面代码确实大大简化，问题是所有远程操作都是继发。只有前一个URL返回结果，才会去读取下一个URL，这样做效率很差，非常浪费时间。我们需要的是并发发出远程请求。 async function logInOrder(urls) { // 并发读取远程URL const textPromises = urls.map(async url =&gt; { const response = await fetch(url); return response.text(); }); // 按次序输出 for (const textPromise of textPromises) { console.log(await textPromise); } } 上面代码中，虽然map方法的参数是async函数，但它是并发执行的，因为只有async函数内部是继发执行，外部不受影响。后面的for..of循环内部使用了await，因此实现了按顺序输出。 异步遍历器《遍历器》一章说过，Iterator 接口是一种数据遍历的协议，只要调用遍历器对象的next方法，就会得到一个对象，表示当前遍历指针所在的那个位置的信息。next方法返回的对象的结构是{value, done}，其中value表示当前的数据的值，done是一个布尔值，表示遍历是否结束。 这里隐含着一个规定，next方法必须是同步的，只要调用就必须立刻返回值。也就是说，一旦执行next方法，就必须同步地得到value和done这两个属性。如果遍历指针正好指向同步操作，当然没有问题，但对于异步操作，就不太合适了。目前的解决方法是，Generator 函数里面的异步操作，返回一个 Thunk 函数或者 Promise 对象，即value属性是一个 Thunk 函数或者 Promise 对象，等待以后返回真正的值，而done属性则还是同步产生的。 目前，有一个提案，为异步操作提供原生的遍历器接口，即value和done这两个属性都是异步产生，这称为”异步遍历器“（Async Iterator）。 异步遍历的接口异步遍历器的最大的语法特点，就是调用遍历器的next方法，返回的是一个 Promise 对象。 asyncIterator .next() .then( ({ value, done }) =&gt; /* ... */ ); 上面代码中，asyncIterator是一个异步遍历器，调用next方法以后，返回一个 Promise 对象。因此，可以使用then方法指定，这个 Promise 对象的状态变为resolve以后的回调函数。回调函数的参数，则是一个具有value和done两个属性的对象，这个跟同步遍历器是一样的。 我们知道，一个对象的同步遍历器的接口，部署在Symbol.iterator属性上面。同样地，对象的异步遍历器接口，部署在Symbol.asyncIterator属性上面。不管是什么样的对象，只要它的Symbol.asyncIterator属性有值，就表示应该对它进行异步遍历。 下面是一个异步遍历器的例子。 const asyncIterable = createAsyncIterable([&#39;a&#39;, &#39;b&#39;]); const asyncIterator = asyncIterable[Symbol.asyncIterator](); asyncIterator .next() .then(iterResult1 =&gt; { console.log(iterResult1); // { value: &#39;a&#39;, done: false } return asyncIterator.next(); }) .then(iterResult2 =&gt; { console.log(iterResult2); // { value: &#39;b&#39;, done: false } return asyncIterator.next(); }) .then(iterResult3 =&gt; { console.log(iterResult3); // { value: undefined, done: true } }); 上面代码中，异步遍历器其实返回了两次值。第一次调用的时候，返回一个 Promise 对象；等到 Promise 对象resolve了，再返回一个表示当前数据成员信息的对象。这就是说，异步遍历器与同步遍历器最终行为是一致的，只是会先返回 Promise 对象，作为中介。 由于异步遍历器的next方法，返回的是一个 Promise 对象。因此，可以把它放在await命令后面。 async function f() { const asyncIterable = createAsyncIterable([&#39;a&#39;, &#39;b&#39;]); const asyncIterator = asyncIterable[Symbol.asyncIterator](); console.log(await asyncIterator.next()); // { value: &#39;a&#39;, done: false } console.log(await asyncIterator.next()); // { value: &#39;b&#39;, done: false } console.log(await asyncIterator.next()); // { value: undefined, done: true } } 上面代码中，next方法用await处理以后，就不必使用then方法了。整个流程已经很接近同步处理了。 注意，异步遍历器的next方法是可以连续调用的，不必等到上一步产生的Promise对象resolve以后再调用。这种情况下，next方法会累积起来，自动按照每一步的顺序运行下去。下面是一个例子，把所有的next方法放在Promise.all方法里面。 const asyncGenObj = createAsyncIterable([&#39;a&#39;, &#39;b&#39;]); const [{value: v1}, {value: v2}] = await Promise.all([ asyncGenObj.next(), asyncGenObj.next() ]); console.log(v1, v2); // a b 另一种用法是一次性调用所有的next方法，然后await最后一步操作。 const writer = openFile(&#39;someFile.txt&#39;); writer.next(&#39;hello&#39;); writer.next(&#39;world&#39;); await writer.return(); for await…of前面介绍过，for...of循环用于遍历同步的 Iterator 接口。新引入的for await...of循环，则是用于遍历异步的 Iterator 接口。 async function f() { for await (const x of createAsyncIterable([&#39;a&#39;, &#39;b&#39;])) { console.log(x); } } // a // b 上面代码中，createAsyncIterable()返回一个异步遍历器，for...of循环自动调用这个遍历器的next方法，会得到一个Promise对象。await用来处理这个Promise对象，一旦resolve，就把得到的值（x）传入for...of的循环体。 for await...of循环的一个用途，是部署了 asyncIterable 操作的异步接口，可以直接放入这个循环。 let body = &#39;&#39;; for await(const data of req) body += data; const parsed = JSON.parse(body); console.log(&#39;got&#39;, parsed); 上面代码中，req是一个 asyncIterable 对象，用来异步读取数据。可以看到，使用for await...of循环以后，代码会非常简洁。 如果next方法返回的Promise对象被reject，那么就要用try...catch捕捉。 async function () { try { for await (const x of createRejectingIterable()) { console.log(x); } } catch (e) { console.error(e); } } 注意，for await...of循环也可以用于同步遍历器。 (async function () { for await (const x of [&#39;a&#39;, &#39;b&#39;]) { console.log(x); } })(); // a // b 异步Generator函数就像 Generator 函数返回一个同步遍历器对象一样，异步 Generator 函数的作用，是返回一个异步遍历器对象。 在语法上，异步 Generator 函数就是async函数与 Generator 函数的结合。 async function* readLines(path) { let file = await fileOpen(path); try { while (!file.EOF) { yield await file.readLine(); } } finally { await file.close(); } } 上面代码中，异步操作前面使用await关键字标明，即await后面的操作，应该返回Promise对象。凡是使用yield关键字的地方，就是next方法的停下来的地方，它后面的表达式的值（即await file.readLine()的值），会作为next()返回对象的value属性，这一点是于同步Generator函数一致的。 可以像下面这样，使用上面代码定义的异步Generator函数。 for await (const line of readLines(filePath)) { console.log(line); } 异步Generator函数可以与for await...of循环结合起来使用。 async function* prefixLines(asyncIterable) { for await (const line of asyncIterable) { yield &#39;&gt; &#39; + line; } } yield命令依然是立刻返回的，但是返回的是一个Promise对象。 async function* asyncGenerator() { console.log(&#39;Start&#39;); const result = await doSomethingAsync(); // (A) yield &#39;Result: &#39;+ result; // (B) console.log(&#39;Done&#39;); } 上面代码中，调用next方法以后，会在B处暂停执行，yield命令立刻返回一个Promise对象。这个Promise对象不同于A处await命令后面的那个Promise对象。主要有两点不同，一是A处的Promise对象resolve以后产生的值，会放入result变量；二是B处的Promise对象resolve以后产生的值，是表达式&#39;Result： &#39; + result的值；二是A处的Promise对象一定先于B处的Promise对象resolve。 如果异步Generator函数抛出错误，会被Promise对象reject，然后抛出的错误被catch方法捕获。 async function* asyncGenerator() { throw new Error(&#39;Problem!&#39;); } asyncGenerator() .next() .catch(err =&gt; console.log(err)); // Error: Problem! 注意，普通的async函数返回的是一个Promise对象，而异步Generator函数返回的是一个异步Iterator对象。基本上，可以这样理解，async函数和异步Generator函数，是封装异步操作的两种方法，都用来达到同一种目的。区别在于，前者自带执行器，后者通过for await...of执行，或者自己编写执行器。下面就是一个异步Generator函数的执行器。 async function takeAsync(asyncIterable, count=Infinity) { const result = []; const iterator = asyncIterable[Symbol.asyncIterator](); while (result.length &lt; count) { const {value,done} = await iterator.next(); if (done) break; result.push(value); } return result; } 上面代码中，异步Generator函数产生的异步遍历器，会通过while循环自动执行，每当await iterator.next()完成，就会进入下一轮循环。 下面是这个自动执行器的一个使用实例。 async function f() { async function* gen() { yield &#39;a&#39;; yield &#39;b&#39;; yield &#39;c&#39;; } return await takeAsync(gen()); } f().then(function (result) { console.log(result); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] }) 异步Generator函数出现以后，JavaScript就有了四种函数形式：普通函数、async函数、Generator函数和异步Generator函数。请注意区分每种函数的不同之处。 最后，同步的数据结构，也可以使用异步Generator函数。 async function* createAsyncIterable(syncIterable) { for (const elem of syncIterable) { yield elem; } } 上面代码中，由于没有异步操作，所以也就没有使用await关键字。 yield* 语句yield*语句也可以跟一个异步遍历器。 async function* gen1() { yield &#39;a&#39;; yield &#39;b&#39;; return 2; } async function* gen2() { const result = yield* gen1(); } 上面代码中，gen2函数里面的result变量，最后的值是2。 与同步Generator函数一样，for await...of循环会展开yield*。 (async function () { for await (const x of gen2()) { console.log(x); } })(); // a // b 感谢阮一峰老师的原创，本分享仅供学习交流","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Async","slug":"Async","permalink":"https://microzz.com/tags/Async/"}]},{"title":"Promise对象","date":"2017-01-14T06:11:38.000Z","path":"2017/01/14/promise/","text":"Promise对象Promise的含义Promise是异步编程的一种解决方案，比传统的解决方案——回调函数和事件——更合理和更强大。它由社区最早提出和实现，ES6将其写进了语言标准，统一了用法，原生提供了Promise对象。 所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise是一个对象，从它可以获取异步操作的消息。Promise提供统一的API，各种异步操作都可以用同样的方法进行处理。 Promise对象有以下两个特点。 （1）对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：Pending（进行中）、Resolved（已完成，又称Fulfilled）和Rejected（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。这也是Promise这个名字的由来，它的英语意思就是“承诺”，表示其他手段无法改变。 （2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。Promise对象的状态改变，只有两种可能：从Pending变为Resolved和从Pending变为Rejected。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果。就算改变已经发生了，你再对Promise对象添加回调函数，也会立即得到这个结果。这与事件（Event）完全不同，事件的特点是，如果你错过了它，再去监听，是得不到结果的。 有了Promise对象，就可以将异步操作以同步操作的流程表达出来，避免了层层嵌套的回调函数。此外，Promise对象提供统一的接口，使得控制异步操作更加容易。 Promise也有一些缺点。首先，无法取消Promise，一旦新建它就会立即执行，无法中途取消。其次，如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。第三，当处于Pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。 如果某些事件不断地反复发生，一般来说，使用stream模式是比部署Promise更好的选择。 基本用法ES6规定，Promise对象是一个构造函数，用来生成Promise实例。 下面代码创造了一个Promise实例。 var promise = new Promise(function(resolve, reject) { // ... some code if (/* 异步操作成功 */){ resolve(value); } else { reject(error); } }); Promise构造函数接受一个函数作为参数，该函数的两个参数分别是resolve和reject。它们是两个函数，由JavaScript引擎提供，不用自己部署。 resolve函数的作用是，将Promise对象的状态从“未完成”变为“成功”（即从Pending变为Resolved），在异步操作成功时调用，并将异步操作的结果，作为参数传递出去；reject函数的作用是，将Promise对象的状态从“未完成”变为“失败”（即从Pending变为Rejected），在异步操作失败时调用，并将异步操作报出的错误，作为参数传递出去。 Promise实例生成以后，可以用then方法分别指定Resolved状态和Reject状态的回调函数。 promise.then(function(value) { // success }, function(error) { // failure }); then方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为Resolved时调用，第二个回调函数是Promise对象的状态变为Reject时调用。其中，第二个函数是可选的，不一定要提供。这两个函数都接受Promise对象传出的值作为参数。 下面是一个Promise对象的简单例子。 function timeout(ms) { return new Promise((resolve, reject) =&gt; { setTimeout(resolve, ms, &#39;done&#39;); }); } timeout(100).then((value) =&gt; { console.log(value); }); 上面代码中，timeout方法返回一个Promise实例，表示一段时间以后才会发生的结果。过了指定的时间（ms参数）以后，Promise实例的状态变为Resolved，就会触发then方法绑定的回调函数。 Promise新建后就会立即执行。 let promise = new Promise(function(resolve, reject) { console.log(&#39;Promise&#39;); resolve(); }); promise.then(function() { console.log(&#39;Resolved.&#39;); }); console.log(&#39;Hi!&#39;); // Promise // Hi! // Resolved 上面代码中，Promise新建后立即执行，所以首先输出的是“Promise”。然后，then方法指定的回调函数，将在当前脚本所有同步任务执行完才会执行，所以“Resolved”最后输出。 下面是异步加载图片的例子。 function loadImageAsync(url) { return new Promise(function(resolve, reject) { var image = new Image(); image.onload = function() { resolve(image); }; image.onerror = function() { reject(new Error(&#39;Could not load image at &#39; + url)); }; image.src = url; }); } 上面代码中，使用Promise包装了一个图片加载的异步操作。如果加载成功，就调用resolve方法，否则就调用reject方法。 下面是一个用Promise对象实现的Ajax操作的例子。 var getJSON = function(url) { var promise = new Promise(function(resolve, reject){ var client = new XMLHttpRequest(); client.open(&quot;GET&quot;, url); client.onreadystatechange = handler; client.responseType = &quot;json&quot;; client.setRequestHeader(&quot;Accept&quot;, &quot;application/json&quot;); client.send(); function handler() { if (this.readyState !== 4) { return; } if (this.status === 200) { resolve(this.response); } else { reject(new Error(this.statusText)); } }; }); return promise; }; getJSON(&quot;/posts.json&quot;).then(function(json) { console.log(&#39;Contents: &#39; + json); }, function(error) { console.error(&#39;出错了&#39;, error); }); 上面代码中，getJSON是对XMLHttpRequest对象的封装，用于发出一个针对JSON数据的HTTP请求，并且返回一个Promise对象。需要注意的是，在getJSON内部，resolve函数和reject函数调用时，都带有参数。 如果调用resolve函数和reject函数时带有参数，那么它们的参数会被传递给回调函数。reject函数的参数通常是Error对象的实例，表示抛出的错误；resolve函数的参数除了正常的值以外，还可能是另一个Promise实例，表示异步操作的结果有可能是一个值，也有可能是另一个异步操作，比如像下面这样。 var p1 = new Promise(function (resolve, reject) { // ... }); var p2 = new Promise(function (resolve, reject) { // ... resolve(p1); }) 上面代码中，p1和p2都是Promise的实例，但是p2的resolve方法将p1作为参数，即一个异步操作的结果是返回另一个异步操作。 注意，这时p1的状态就会传递给p2，也就是说，p1的状态决定了p2的状态。如果p1的状态是Pending，那么p2的回调函数就会等待p1的状态改变；如果p1的状态已经是Resolved或者Rejected，那么p2的回调函数将会立刻执行。 var p1 = new Promise(function (resolve, reject) { setTimeout(() =&gt; reject(new Error(&#39;fail&#39;)), 3000) }) var p2 = new Promise(function (resolve, reject) { setTimeout(() =&gt; resolve(p1), 1000) }) p2 .then(result =&gt; console.log(result)) .catch(error =&gt; console.log(error)) // Error: fail 上面代码中，p1是一个Promise，3秒之后变为rejected。p2的状态在1秒之后改变，resolve方法返回的是p1。此时，由于p2返回的是另一个Promise，所以后面的then语句都变成针对后者（p1）。又过了2秒，p1变为rejected，导致触发catch方法指定的回调函数。 Promise.prototype.then()Promise实例具有then方法，也就是说，then方法是定义在原型对象Promise.prototype上的。它的作用是为Promise实例添加状态改变时的回调函数。前面说过，then方法的第一个参数是Resolved状态的回调函数，第二个参数（可选）是Rejected状态的回调函数。 then方法返回的是一个新的Promise实例（注意，不是原来那个Promise实例）。因此可以采用链式写法，即then方法后面再调用另一个then方法。 getJSON(&quot;/posts.json&quot;).then(function(json) { return json.post; }).then(function(post) { // ... }); 上面的代码使用then方法，依次指定了两个回调函数。第一个回调函数完成以后，会将返回结果作为参数，传入第二个回调函数。 采用链式的then，可以指定一组按照次序调用的回调函数。这时，前一个回调函数，有可能返回的还是一个Promise对象（即有异步操作），这时后一个回调函数，就会等待该Promise对象的状态发生变化，才会被调用。 getJSON(&quot;/post/1.json&quot;).then(function(post) { return getJSON(post.commentURL); }).then(function funcA(comments) { console.log(&quot;Resolved: &quot;, comments); }, function funcB(err){ console.log(&quot;Rejected: &quot;, err); }); 上面代码中，第一个then方法指定的回调函数，返回的是另一个Promise对象。这时，第二个then方法指定的回调函数，就会等待这个新的Promise对象状态发生变化。如果变为Resolved，就调用funcA，如果状态变为Rejected，就调用funcB。 如果采用箭头函数，上面的代码可以写得更简洁。 getJSON(&quot;/post/1.json&quot;).then( post =&gt; getJSON(post.commentURL) ).then( comments =&gt; console.log(&quot;Resolved: &quot;, comments), err =&gt; console.log(&quot;Rejected: &quot;, err) ); Promise.prototype.catch()Promise.prototype.catch方法是.then(null, rejection)的别名，用于指定发生错误时的回调函数。 getJSON(&quot;/posts.json&quot;).then(function(posts) { // ... }).catch(function(error) { // 处理 getJSON 和 前一个回调函数运行时发生的错误 console.log(&#39;发生错误！&#39;, error); }); 上面代码中，getJSON方法返回一个Promise对象，如果该对象状态变为Resolved，则会调用then方法指定的回调函数；如果异步操作抛出错误，状态就会变为Rejected，就会调用catch方法指定的回调函数，处理这个错误。另外，then方法指定的回调函数，如果运行中抛出错误，也会被catch方法捕获。 p.then((val) =&gt; console.log(&quot;fulfilled:&quot;, val)) .catch((err) =&gt; console.log(&quot;rejected:&quot;, err)); // 等同于 p.then((val) =&gt; console.log(&quot;fulfilled:&quot;, val)) .then(null, (err) =&gt; console.log(&quot;rejected:&quot;, err)); 下面是一个例子。 var promise = new Promise(function(resolve, reject) { throw new Error(&#39;test&#39;); }); promise.catch(function(error) { console.log(error); }); // Error: test 上面代码中，promise抛出一个错误，就被catch方法指定的回调函数捕获。注意，上面的写法与下面两种写法是等价的。 // 写法一 var promise = new Promise(function(resolve, reject) { try { throw new Error(&#39;test&#39;); } catch(e) { reject(e); } }); promise.catch(function(error) { console.log(error); }); // 写法二 var promise = new Promise(function(resolve, reject) { reject(new Error(&#39;test&#39;)); }); promise.catch(function(error) { console.log(error); }); 比较上面两种写法，可以发现reject方法的作用，等同于抛出错误。 如果Promise状态已经变成Resolved，再抛出错误是无效的。 var promise = new Promise(function(resolve, reject) { resolve(&#39;ok&#39;); throw new Error(&#39;test&#39;); }); promise .then(function(value) { console.log(value) }) .catch(function(error) { console.log(error) }); // ok 上面代码中，Promise在resolve语句后面，再抛出错误，不会被捕获，等于没有抛出。 Promise对象的错误具有“冒泡”性质，会一直向后传递，直到被捕获为止。也就是说，错误总是会被下一个catch语句捕获。 getJSON(&quot;/post/1.json&quot;).then(function(post) { return getJSON(post.commentURL); }).then(function(comments) { // some code }).catch(function(error) { // 处理前面三个Promise产生的错误 }); 上面代码中，一共有三个Promise对象：一个由getJSON产生，两个由then产生。它们之中任何一个抛出的错误，都会被最后一个catch捕获。 一般来说，不要在then方法里面定义Reject状态的回调函数（即then的第二个参数），总是使用catch方法。 // bad promise .then(function(data) { // success }, function(err) { // error }); // good promise .then(function(data) { //cb // success }) .catch(function(err) { // error }); 上面代码中，第二种写法要好于第一种写法，理由是第二种写法可以捕获前面then方法执行中的错误，也更接近同步的写法（try/catch）。因此，建议总是使用catch方法，而不使用then方法的第二个参数。 跟传统的try/catch代码块不同的是，如果没有使用catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层代码，即不会有任何反应。 var someAsyncThing = function() { return new Promise(function(resolve, reject) { // 下面一行会报错，因为x没有声明 resolve(x + 2); }); }; someAsyncThing().then(function() { console.log(&#39;everything is great&#39;); }); 上面代码中，someAsyncThing函数产生的Promise对象会报错，但是由于没有指定catch方法，这个错误不会被捕获，也不会传递到外层代码，导致运行后没有任何输出。注意，Chrome浏览器不遵守这条规定，它会抛出错误“ReferenceError: x is not defined”。 var promise = new Promise(function(resolve, reject) { resolve(&#39;ok&#39;); setTimeout(function() { throw new Error(&#39;test&#39;) }, 0) }); promise.then(function(value) { console.log(value) }); // ok // Uncaught Error: test 上面代码中，Promise 指定在下一轮“事件循环”再抛出错误，结果由于没有指定使用try...catch语句，就冒泡到最外层，成了未捕获的错误。因为此时，Promise的函数体已经运行结束了，所以这个错误是在Promise函数体外抛出的。 Node 有一个unhandledRejection事件，专门监听未捕获的reject错误。 process.on(&#39;unhandledRejection&#39;, function (err, p) { console.error(err.stack) }); 上面代码中，unhandledRejection事件的监听函数有两个参数，第一个是错误对象，第二个是报错的Promise实例，它可以用来了解发生错误的环境信息。。 需要注意的是，catch方法返回的还是一个 Promise 对象，因此后面还可以接着调用then方法。 var someAsyncThing = function() { return new Promise(function(resolve, reject) { // 下面一行会报错，因为x没有声明 resolve(x + 2); }); }; someAsyncThing() .catch(function(error) { console.log(&#39;oh no&#39;, error); }) .then(function() { console.log(&#39;carry on&#39;); }); // oh no [ReferenceError: x is not defined] // carry on 上面代码运行完catch方法指定的回调函数，会接着运行后面那个then方法指定的回调函数。如果没有报错，则会跳过catch方法。 Promise.resolve() .catch(function(error) { console.log(&#39;oh no&#39;, error); }) .then(function() { console.log(&#39;carry on&#39;); }); // carry on 上面的代码因为没有报错，跳过了catch方法，直接执行后面的then方法。此时，要是then方法里面报错，就与前面的catch无关了。 catch方法之中，还能再抛出错误。 var someAsyncThing = function() { return new Promise(function(resolve, reject) { // 下面一行会报错，因为x没有声明 resolve(x + 2); }); }; someAsyncThing().then(function() { return someOtherAsyncThing(); }).catch(function(error) { console.log(&#39;oh no&#39;, error); // 下面一行会报错，因为y没有声明 y + 2; }).then(function() { console.log(&#39;carry on&#39;); }); // oh no [ReferenceError: x is not defined] 上面代码中，catch方法抛出一个错误，因为后面没有别的catch方法了，导致这个错误不会被捕获，也不会传递到外层。如果改写一下，结果就不一样了。 someAsyncThing().then(function() { return someOtherAsyncThing(); }).catch(function(error) { console.log(&#39;oh no&#39;, error); // 下面一行会报错，因为y没有声明 y + 2; }).catch(function(error) { console.log(&#39;carry on&#39;, error); }); // oh no [ReferenceError: x is not defined] // carry on [ReferenceError: y is not defined] 上面代码中，第二个catch方法用来捕获，前一个catch方法抛出的错误。 Promise.all()Promise.all方法用于将多个Promise实例，包装成一个新的Promise实例。 var p = Promise.all([p1, p2, p3]); 上面代码中，Promise.all方法接受一个数组作为参数，p1、p2、p3都是Promise对象的实例，如果不是，就会先调用下面讲到的Promise.resolve方法，将参数转为Promise实例，再进一步处理。（Promise.all方法的参数可以不是数组，但必须具有Iterator接口，且返回的每个成员都是Promise实例。） p的状态由p1、p2、p3决定，分成两种情况。 （1）只有p1、p2、p3的状态都变成fulfilled，p的状态才会变成fulfilled，此时p1、p2、p3的返回值组成一个数组，传递给p的回调函数。 （2）只要p1、p2、p3之中有一个被rejected，p的状态就变成rejected，此时第一个被reject的实例的返回值，会传递给p的回调函数。 下面是一个具体的例子。 // 生成一个Promise对象的数组 var promises = [2, 3, 5, 7, 11, 13].map(function (id) { return getJSON(&quot;/post/&quot; + id + &quot;.json&quot;); }); Promise.all(promises).then(function (posts) { // ... }).catch(function(reason){ // ... }); 上面代码中，promises是包含6个Promise实例的数组，只有这6个实例的状态都变成fulfilled，或者其中有一个变为rejected，才会调用Promise.all方法后面的回调函数。 下面是另一个例子。 const databasePromise = connectDatabase(); const booksPromise = databaseProimse .then(findAllBooks); const userPromise = databasePromise .then(getCurrentUser); Promise.all([ booksPromise, userPromise ]) .then(([books, user]) =&gt; pickTopRecommentations(books, user)); 上面代码中，booksPromise和userPromise是两个异步操作，只有等到它们的结果都返回了，才会触发pickTopRecommentations这个回调函数。 Promise.race()Promise.race方法同样是将多个Promise实例，包装成一个新的Promise实例。 var p = Promise.race([p1, p2, p3]); 上面代码中，只要p1、p2、p3之中有一个实例率先改变状态，p的状态就跟着改变。那个率先改变的 Promise 实例的返回值，就传递给p的回调函数。 Promise.race方法的参数与Promise.all方法一样，如果不是 Promise 实例，就会先调用下面讲到的Promise.resolve方法，将参数转为 Promise 实例，再进一步处理。 下面是一个例子，如果指定时间内没有获得结果，就将Promise的状态变为reject，否则变为resolve。 var p = Promise.race([ fetch(&#39;/resource-that-may-take-a-while&#39;), new Promise(function (resolve, reject) { setTimeout(() =&gt; reject(new Error(&#39;request timeout&#39;)), 5000) }) ]) p.then(response =&gt; console.log(response)) p.catch(error =&gt; console.log(error)) 上面代码中，如果5秒之内fetch方法无法返回结果，变量p的状态就会变为rejected，从而触发catch方法指定的回调函数。 Promise.resolve()有时需要将现有对象转为Promise对象，Promise.resolve方法就起到这个作用。 var jsPromise = Promise.resolve($.ajax(&#39;/whatever.json&#39;)); 上面代码将jQuery生成的deferred对象，转为一个新的Promise对象。 Promise.resolve等价于下面的写法。 Promise.resolve(&#39;foo&#39;) // 等价于 new Promise(resolve =&gt; resolve(&#39;foo&#39;)) Promise.resolve方法的参数分成四种情况。 （1）参数是一个Promise实例 如果参数是Promise实例，那么Promise.resolve将不做任何修改、原封不动地返回这个实例。 （2）参数是一个thenable对象 thenable对象指的是具有then方法的对象，比如下面这个对象。 let thenable = { then: function(resolve, reject) { resolve(42); } }; Promise.resolve方法会将这个对象转为Promise对象，然后就立即执行thenable对象的then方法。 let thenable = { then: function(resolve, reject) { resolve(42); } }; let p1 = Promise.resolve(thenable); p1.then(function(value) { console.log(value); // 42 }); 上面代码中，thenable对象的then方法执行后，对象p1的状态就变为resolved，从而立即执行最后那个then方法指定的回调函数，输出42。 （3）参数不是具有then方法的对象，或根本就不是对象 如果参数是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为Resolved。 var p = Promise.resolve(&#39;Hello&#39;); p.then(function (s){ console.log(s) }); // Hello 上面代码生成一个新的Promise对象的实例p。由于字符串Hello不属于异步操作（判断方法是它不是具有then方法的对象），返回Promise实例的状态从一生成就是Resolved，所以回调函数会立即执行。Promise.resolve方法的参数，会同时传给回调函数。 （4）不带有任何参数 Promise.resolve方法允许调用时不带参数，直接返回一个Resolved状态的Promise对象。 所以，如果希望得到一个Promise对象，比较方便的方法就是直接调用Promise.resolve方法。 var p = Promise.resolve(); p.then(function () { // ... }); 上面代码的变量p就是一个Promise对象。 需要注意的是，立即resolve的Promise对象，是在本轮“事件循环”（event loop）的结束时，而不是在下一轮“事件循环”的开始时。 setTimeout(function () { console.log(&#39;three&#39;); }, 0); Promise.resolve().then(function () { console.log(&#39;two&#39;); }); console.log(&#39;one&#39;); // one // two // three 上面代码中，setTimeout(fn, 0)在下一轮“事件循环”开始时执行，Promise.resolve()在本轮“事件循环”结束时执行，console.log(’one‘)则是立即执行，因此最先输出。 Promise.reject()Promise.reject(reason)方法也会返回一个新的 Promise 实例，该实例的状态为rejected。 var p = Promise.reject(&#39;出错了&#39;); // 等同于 var p = new Promise((resolve, reject) =&gt; reject(&#39;出错了&#39;)) p.then(null, function (s) { console.log(s) }); // 出错了 上面代码生成一个Promise对象的实例p，状态为rejected，回调函数会立即执行。 注意，Promise.reject()方法的参数，会原封不动地作为reject的理由，变成后续方法的参数。这一点与Promise.resolve方法不一致。 const thenable = { then(resolve, reject) { reject(&#39;出错了&#39;); } }; Promise.reject(thenable) .catch(e =&gt; { console.log(e === thenable) }) // true 上面代码中，Promise.reject方法的参数是一个thenable对象，执行以后，后面catch方法的参数不是reject抛出的“出错了”这个字符串，而是thenable对象。 两个有用的附加方法ES6的Promise API提供的方法不是很多，有些有用的方法可以自己部署。下面介绍如何部署两个不在ES6之中、但很有用的方法。 done()Promise对象的回调链，不管以then方法或catch方法结尾，要是最后一个方法抛出错误，都有可能无法捕捉到（因为Promise内部的错误不会冒泡到全局）。因此，我们可以提供一个done方法，总是处于回调链的尾端，保证抛出任何可能出现的错误。 asyncFunc() .then(f1) .catch(r1) .then(f2) .done(); 它的实现代码相当简单。 Promise.prototype.done = function (onFulfilled, onRejected) { this.then(onFulfilled, onRejected) .catch(function (reason) { // 抛出一个全局错误 setTimeout(() =&gt; { throw reason }, 0); }); }; 从上面代码可见，done方法的使用，可以像then方法那样用，提供Fulfilled和Rejected状态的回调函数，也可以不提供任何参数。但不管怎样，done都会捕捉到任何可能出现的错误，并向全局抛出。 finally()finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。它与done方法的最大区别，它接受一个普通的回调函数作为参数，该函数不管怎样都必须执行。 下面是一个例子，服务器使用Promise处理请求，然后使用finally方法关掉服务器。 server.listen(0) .then(function () { // run test }) .finally(server.stop); 它的实现也很简单。 Promise.prototype.finally = function (callback) { let P = this.constructor; return this.then( value =&gt; P.resolve(callback()).then(() =&gt; value), reason =&gt; P.resolve(callback()).then(() =&gt; { throw reason }) ); }; 上面代码中，不管前面的Promise是fulfilled还是rejected，都会执行回调函数callback。 更多IT技术分享尽在 🔗涵月天-microzz.com 应用加载图片我们可以将图片的加载写成一个Promise，一旦加载完成，Promise的状态就发生变化。 const preloadImage = function (path) { return new Promise(function (resolve, reject) { var image = new Image(); image.onload = resolve; image.onerror = reject; image.src = path; }); }; Generator函数与Promise的结合使用Generator函数管理流程，遇到异步操作的时候，通常返回一个Promise对象。 function getFoo () { return new Promise(function (resolve, reject){ resolve(&#39;foo&#39;); }); } var g = function* () { try { var foo = yield getFoo(); console.log(foo); } catch (e) { console.log(e); } }; function run (generator) { var it = generator(); function go(result) { if (result.done) return result.value; return result.value.then(function (value) { return go(it.next(value)); }, function (error) { return go(it.throw(error)); }); } go(it.next()); } run(g); 上面代码的Generator函数g之中，有一个异步操作getFoo，它返回的就是一个Promise对象。函数run用来处理这个Promise对象，并调用下一个next方法。 Promise.try()实际开发中，经常遇到一种情况：不知道或者不想区分，函数f是同步函数还是异步操作，但是想用 Promise 来处理它。因为这样就可以不管f是否包含异步操作，都用then方法指定下一步流程，用catch方法处理f抛出的错误。一般就会采用下面的写法。 Promise.resolve().then(f) 上面的写法有一个缺点，就是如果f是同步函数，那么它会在本轮事件循环的末尾执行。 const f = () =&gt; console.log(&#39;now&#39;); Promise.resolve().then(f); console.log(&#39;next&#39;); // next // now 上面代码中，函数f是同步的，但是用 Promise 包装了以后，就变成异步执行了。 那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用async函数来写。 const f = () =&gt; console.log(&#39;now&#39;); (async () =&gt; f())(); console.log(&#39;next&#39;); // now // next 上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的async函数，因此如果f是同步的，就会得到同步的结果；如果f是异步的，就可以用then指定下一步，就像下面的写法。 (async () =&gt; f())() .then(...) 需要注意的是，async () =&gt; f()会吃掉f()抛出的错误。所以，如果想捕获错误，要使用promise.catch方法。 (async () =&gt; f())() .then(...) .catch(...) 第二种写法是使用new Promise()。 const f = () =&gt; console.log(&#39;now&#39;); ( () =&gt; new Promise( resolve =&gt; resolve(f()) ) )(); console.log(&#39;next&#39;); // now // next 上面代码也是使用立即执行的匿名函数，执行new Promise()。这种情况下，同步函数也是同步执行的。 鉴于这是一个很常见的需求，所以现在有一个提案，提供Promise.try方法替代上面的写法。 const f = () =&gt; console.log(&#39;now&#39;); Promise.try(f); console.log(&#39;next&#39;); // now // next 事实上，Promise.try存在已久，Promise 库Bluebird、Q和when，早就提供了这个方法。 由于Promise.try为所有操作提供了统一的处理机制，所以如果想用then方法管理流程，最好都用Promise.try包装一下。这样有许多好处，其中一点就是可以更好地管理异常。 function getUsername(userId) { return database.users.get({id: userId}) .then(function(user) { return user.name; }); } 上面代码中，database.users.get()返回一个 Promise 对象，如果抛出异步错误，可以用catch方法捕获，就像下面这样写。 database.users.get({id: userId}) .then(...) .catch(...) 但是database.users.get()可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用try...catch去捕获。 try { database.users.get({id: userId}) .then(...) .catch(...) } catch (e) { // ... } 上面这样的写法就很笨拙了，这时就可以统一用promise.catch()捕获所有同步和异步的错误。 Promise.try(database.users.get({id: userId})) .then(...) .catch(...) 事实上，Promise.try就是模拟try代码块，就像promise.catch模拟的是catch代码块。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Promise","slug":"Promise","permalink":"https://microzz.com/tags/Promise/"}]},{"title":"Generator 函数","date":"2017-01-13T06:51:58.000Z","path":"2017/01/13/generator/","text":"Generator 函数简介基本概念Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。本章详细介绍Generator函数的语法和API，它的异步编程应用请看《异步操作》一章。 Generator函数有多种理解角度。从语法上，首先可以把它理解成，Generator函数是一个状态机，封装了多个内部状态。 执行Generator函数会返回一个遍历器对象，也就是说，Generator函数除了状态机，还是一个遍历器对象生成函数。返回的遍历器对象，可以依次遍历Generator函数内部的每一个状态。 形式上，Generator函数是一个普通函数，但是有两个特征。一是，function关键字与函数名之间有一个星号；二是，函数体内部使用yield语句，定义不同的内部状态（yield语句在英语里的意思就是“产出”）。 function* helloWorldGenerator() { yield &#39;hello&#39;; yield &#39;world&#39;; return &#39;ending&#39;; } var hw = helloWorldGenerator(); 上面代码定义了一个Generator函数helloWorldGenerator，它内部有两个yield语句“hello”和“world”，即该函数有三个状态：hello，world和return语句（结束执行）。 然后，Generator函数的调用方法与普通函数一样，也是在函数名后面加上一对圆括号。不同的是，调用Generator函数后，该函数并不执行，返回的也不是函数运行结果，而是一个指向内部状态的指针对象，也就是上一章介绍的遍历器对象（Iterator Object）。 下一步，必须调用遍历器对象的next方法，使得指针移向下一个状态。也就是说，每次调用next方法，内部指针就从函数头部或上一次停下来的地方开始执行，直到遇到下一个yield语句（或return语句）为止。换言之，Generator函数是分段执行的，yield语句是暂停执行的标记，而next方法可以恢复执行。 hw.next() // { value: &#39;hello&#39;, done: false } hw.next() // { value: &#39;world&#39;, done: false } hw.next() // { value: &#39;ending&#39;, done: true } hw.next() // { value: undefined, done: true } 上面代码一共调用了四次next方法。 第一次调用，Generator函数开始执行，直到遇到第一个yield语句为止。next方法返回一个对象，它的value属性就是当前yield语句的值hello，done属性的值false，表示遍历还没有结束。 第二次调用，Generator函数从上次yield语句停下的地方，一直执行到下一个yield语句。next方法返回的对象的value属性就是当前yield语句的值world，done属性的值false，表示遍历还没有结束。 第三次调用，Generator函数从上次yield语句停下的地方，一直执行到return语句（如果没有return语句，就执行到函数结束）。next方法返回的对象的value属性，就是紧跟在return语句后面的表达式的值（如果没有return语句，则value属性的值为undefined），done属性的值true，表示遍历已经结束。 第四次调用，此时Generator函数已经运行完毕，next方法返回对象的value属性为undefined，done属性为true。以后再调用next方法，返回的都是这个值。 总结一下，调用Generator函数，返回一个遍历器对象，代表Generator函数的内部指针。以后，每次调用遍历器对象的next方法，就会返回一个有着value和done两个属性的对象。value属性表示当前的内部状态的值，是yield语句后面那个表达式的值；done属性是一个布尔值，表示是否遍历结束。 ES6没有规定，function关键字与函数名之间的星号，写在哪个位置。这导致下面的写法都能通过。 function * foo(x, y) { ··· } function *foo(x, y) { ··· } function* foo(x, y) { ··· } function*foo(x, y) { ··· } 由于Generator函数仍然是普通函数，所以一般的写法是上面的第三种，即星号紧跟在function关键字后面。本书也采用这种写法。 yield语句由于Generator函数返回的遍历器对象，只有调用next方法才会遍历下一个内部状态，所以其实提供了一种可以暂停执行的函数。yield语句就是暂停标志。 遍历器对象的next方法的运行逻辑如下。 （1）遇到yield语句，就暂停执行后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。 （2）下一次调用next方法时，再继续往下执行，直到遇到下一个yield语句。 （3）如果没有再遇到新的yield语句，就一直运行到函数结束，直到return语句为止，并将return语句后面的表达式的值，作为返回的对象的value属性值。 （4）如果该函数没有return语句，则返回的对象的value属性值为undefined。 需要注意的是，yield语句后面的表达式，只有当调用next方法、内部指针指向该语句时才会执行，因此等于为JavaScript提供了手动的“惰性求值”（Lazy Evaluation）的语法功能。 function* gen() { yield 123 + 456; } 上面代码中，yield后面的表达式123 + 456，不会立即求值，只会在next方法将指针移到这一句时，才会求值。 yield语句与return语句既有相似之处，也有区别。相似之处在于，都能返回紧跟在语句后面的那个表达式的值。区别在于每次遇到yield，函数暂停执行，下一次再从该位置继续向后执行，而return语句不具备位置记忆的功能。一个函数里面，只能执行一次（或者说一个）return语句，但是可以执行多次（或者说多个）yield语句。正常函数只能返回一个值，因为只能执行一次return；Generator函数可以返回一系列的值，因为可以有任意多个yield。从另一个角度看，也可以说Generator生成了一系列的值，这也就是它的名称的来历（在英语中，generator这个词是“生成器”的意思）。 Generator函数可以不用yield语句，这时就变成了一个单纯的暂缓执行函数。 function* f() { console.log(&#39;执行了！&#39;) } var generator = f(); setTimeout(function () { generator.next() }, 2000); 上面代码中，函数f如果是普通函数，在为变量generator赋值时就会执行。但是，函数f是一个Generator函数，就变成只有调用next方法时，函数f才会执行。 另外需要注意，yield语句不能用在普通函数中，否则会报错。 (function (){ yield 1; })() // SyntaxError: Unexpected number 上面代码在一个普通函数中使用yield语句，结果产生一个句法错误。 下面是另外一个例子。 var arr = [1, [[2, 3], 4], [5, 6]]; var flat = function* (a) { a.forEach(function (item) { if (typeof item !== &#39;number&#39;) { yield* flat(item); } else { yield item; } } }; for (var f of flat(arr)){ console.log(f); } 上面代码也会产生句法错误，因为forEach方法的参数是一个普通函数，但是在里面使用了yield语句（这个函数里面还使用了yield*语句，这里可以不用理会，详细说明见后文）。一种修改方法是改用for循环。 var arr = [1, [[2, 3], 4], [5, 6]]; var flat = function* (a) { var length = a.length; for (var i = 0; i &lt; length; i++) { var item = a[i]; if (typeof item !== &#39;number&#39;) { yield* flat(item); } else { yield item; } } }; for (var f of flat(arr)) { console.log(f); } // 1, 2, 3, 4, 5, 6 另外，yield语句如果用在一个表达式之中，必须放在圆括号里面。 console.log(&#39;Hello&#39; + yield); // SyntaxError console.log(&#39;Hello&#39; + yield 123); // SyntaxError console.log(&#39;Hello&#39; + (yield)); // OK console.log(&#39;Hello&#39; + (yield 123)); // OK yield语句用作函数参数或赋值表达式的右边，可以不加括号。 foo(yield &#39;a&#39;, yield &#39;b&#39;); // OK let input = yield; // OK 与Iterator接口的关系上一章说过，任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。 由于Generator函数就是遍历器生成函数，因此可以把Generator赋值给对象的Symbol.iterator属性，从而使得该对象具有Iterator接口。 var myIterable = {}; myIterable[Symbol.iterator] = function* () { yield 1; yield 2; yield 3; }; [...myIterable] // [1, 2, 3] 上面代码中，Generator函数赋值给Symbol.iterator属性，从而使得myIterable对象具有了Iterator接口，可以被...运算符遍历了。 Generator函数执行后，返回一个遍历器对象。该对象本身也具有Symbol.iterator属性，执行后返回自身。 function* gen(){ // some code } var g = gen(); g[Symbol.iterator]() === g // true 上面代码中，gen是一个Generator函数，调用它会生成一个遍历器对象g。它的Symbol.iterator属性，也是一个遍历器对象生成函数，执行后返回它自己。 next方法的参数yield句本身没有返回值，或者说总是返回undefined。next方法可以带一个参数，该参数就会被当作上一个yield语句的返回值。 function* f() { for(var i = 0; true; i++) { var reset = yield i; if(reset) { i = -1; } } } var g = f(); g.next() // { value: 0, done: false } g.next() // { value: 1, done: false } g.next(true) // { value: 0, done: false } 上面代码先定义了一个可以无限运行的 Generator 函数f，如果next方法没有参数，每次运行到yield语句，变量reset的值总是undefined。当next方法带一个参数true时，变量reset就被重置为这个参数（即true），因此i会等于-1，下一轮循环就会从-1开始递增。 这个功能有很重要的语法意义。Generator 函数从暂停状态到恢复运行，它的上下文状态（context）是不变的。通过next方法的参数，就有办法在 Generator 函数开始运行之后，继续向函数体内部注入值。也就是说，可以在 Generator 函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。 再看一个例子。 function* foo(x) { var y = 2 * (yield (x + 1)); var z = yield (y / 3); return (x + y + z); } var a = foo(5); a.next() // Object{value:6, done:false} a.next() // Object{value:NaN, done:false} a.next() // Object{value:NaN, done:true} var b = foo(5); b.next() // { value:6, done:false } b.next(12) // { value:8, done:false } b.next(13) // { value:42, done:true } 上面代码中，第二次运行next方法的时候不带参数，导致y的值等于2 * undefined（即NaN），除以3以后还是NaN，因此返回对象的value属性也等于NaN。第三次运行Next方法的时候不带参数，所以z等于undefined，返回对象的value属性等于5 + NaN + undefined，即NaN。 如果向next方法提供参数，返回结果就完全不一样了。上面代码第一次调用b的next方法时，返回x+1的值6；第二次调用next方法，将上一次yield语句的值设为12，因此y等于24，返回y / 3的值8；第三次调用next方法，将上一次yield语句的值设为13，因此z等于13，这时x等于5，y等于24，所以return语句的值等于42。 注意，由于next方法的参数表示上一个yield语句的返回值，所以第一次使用next方法时，不能带有参数。V8引擎直接忽略第一次使用next方法时的参数，只有从第二次使用next方法开始，参数才是有效的。从语义上讲，第一个next方法用来启动遍历器对象，所以不用带有参数。 如果想要第一次调用next方法时，就能够输入值，可以在Generator函数外面再包一层。 function wrapper(generatorFunction) { return function (...args) { let generatorObject = generatorFunction(...args); generatorObject.next(); return generatorObject; }; } const wrapped = wrapper(function* () { console.log(`First input: ${yield}`); return &#39;DONE&#39;; }); wrapped().next(&#39;hello!&#39;) // First input: hello! 上面代码中，Generator函数如果不用wrapper先包一层，是无法第一次调用next方法，就输入参数的。 再看一个通过next方法的参数，向Generator函数内部输入值的例子。 function* dataConsumer() { console.log(&#39;Started&#39;); console.log(`1. ${yield}`); console.log(`2. ${yield}`); return &#39;result&#39;; } let genObj = dataConsumer(); genObj.next(); // Started genObj.next(&#39;a&#39;) // 1. a genObj.next(&#39;b&#39;) // 2. b 上面代码是一个很直观的例子，每次通过next方法向Generator函数输入值，然后打印出来。 for…of循环for...of循环可以自动遍历Generator函数时生成的Iterator对象，且此时不再需要调用next方法。 function *foo() { yield 1; yield 2; yield 3; yield 4; yield 5; return 6; } for (let v of foo()) { console.log(v); } // 1 2 3 4 5 上面代码使用for...of循环，依次显示5个yield语句的值。这里需要注意，一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含该返回对象，所以上面代码的return语句返回的6，不包括在for...of循环之中。 下面是一个利用Generator函数和for...of循环，实现斐波那契数列的例子。 function* fibonacci() { let [prev, curr] = [0, 1]; for (;;) { [prev, curr] = [curr, prev + curr]; yield curr; } } for (let n of fibonacci()) { if (n &gt; 1000) break; console.log(n); } 从上面代码可见，使用for...of语句时不需要使用next方法。 利用for...of循环，可以写出遍历任意对象（object）的方法。原生的JavaScript对象没有遍历接口，无法使用for...of循环，通过Generator函数为它加上这个接口，就可以用了。 function* objectEntries(obj) { let propKeys = Reflect.ownKeys(obj); for (let propKey of propKeys) { yield [propKey, obj[propKey]]; } } let jane = { first: &#39;Jane&#39;, last: &#39;Doe&#39; }; for (let [key, value] of objectEntries(jane)) { console.log(`${key}: ${value}`); } // first: Jane // last: Doe 上面代码中，对象jane原生不具备Iterator接口，无法用for...of遍历。这时，我们通过Generator函数objectEntries为它加上遍历器接口，就可以用for...of遍历了。加上遍历器接口的另一种写法是，将Generator函数加到对象的Symbol.iterator属性上面。 function* objectEntries() { let propKeys = Object.keys(this); for (let propKey of propKeys) { yield [propKey, this[propKey]]; } } let jane = { first: &#39;Jane&#39;, last: &#39;Doe&#39; }; jane[Symbol.iterator] = objectEntries; for (let [key, value] of jane) { console.log(`${key}: ${value}`); } // first: Jane // last: Doe 除了for...of循环以外，扩展运算符（...）、解构赋值和Array.from方法内部调用的，都是遍历器接口。这意味着，它们都可以将Generator函数返回的Iterator对象，作为参数。 function* numbers () { yield 1 yield 2 return 3 yield 4 } // 扩展运算符 [...numbers()] // [1, 2] // Array.from 方法 Array.from(numbers()) // [1, 2] // 解构赋值 let [x, y] = numbers(); x // 1 y // 2 // for...of 循环 for (let n of numbers()) { console.log(n) } // 1 // 2 Generator.prototype.throw()Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后在Generator函数体内捕获。 var g = function* () { try { yield; } catch (e) { console.log(&#39;内部捕获&#39;, e); } }; var i = g(); i.next(); try { i.throw(&#39;a&#39;); i.throw(&#39;b&#39;); } catch (e) { console.log(&#39;外部捕获&#39;, e); } // 内部捕获 a // 外部捕获 b 上面代码中，遍历器对象i连续抛出两个错误。第一个错误被Generator函数体内的catch语句捕获。i第二次抛出错误，由于Generator函数内部的catch语句已经执行过了，不会再捕捉到这个错误了，所以这个错误就被抛出了Generator函数体，被函数体外的catch语句捕获。 throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象的实例。 var g = function* () { try { yield; } catch (e) { console.log(e); } }; var i = g(); i.next(); i.throw(new Error(&#39;出错了！&#39;)); // Error: 出错了！(…) 注意，不要混淆遍历器对象的throw方法和全局的throw命令。上面代码的错误，是用遍历器对象的throw方法抛出的，而不是用throw命令抛出的。后者只能被函数体外的catch语句捕获。 var g = function* () { while (true) { try { yield; } catch (e) { if (e != &#39;a&#39;) throw e; console.log(&#39;内部捕获&#39;, e); } } }; var i = g(); i.next(); try { throw new Error(&#39;a&#39;); throw new Error(&#39;b&#39;); } catch (e) { console.log(&#39;外部捕获&#39;, e); } // 外部捕获 [Error: a] 上面代码之所以只捕获了a，是因为函数体外的catch语句块，捕获了抛出的a错误以后，就不会再继续try代码块里面剩余的语句了。 如果Generator函数内部没有部署try...catch代码块，那么throw方法抛出的错误，将被外部try...catch代码块捕获。 var g = function* () { while (true) { yield; console.log(&#39;内部捕获&#39;, e); } }; var i = g(); i.next(); try { i.throw(&#39;a&#39;); i.throw(&#39;b&#39;); } catch (e) { console.log(&#39;外部捕获&#39;, e); } // 外部捕获 a 上面代码中，Generator函数g内部没有部署try...catch代码块，所以抛出的错误直接被外部catch代码块捕获。 如果Generator函数内部和外部，都没有部署try...catch代码块，那么程序将报错，直接中断执行。 var gen = function* gen(){ yield console.log(&#39;hello&#39;); yield console.log(&#39;world&#39;); } var g = gen(); g.next(); g.throw(); // hello // Uncaught undefined 上面代码中，g.throw抛出错误以后，没有任何try...catch代码块可以捕获这个错误，导致程序报错，中断执行。 throw方法被捕获以后，会附带执行下一条yield语句。也就是说，会附带执行一次next方法。 var gen = function* gen(){ try { yield console.log(&#39;a&#39;); } catch (e) { // ... } yield console.log(&#39;b&#39;); yield console.log(&#39;c&#39;); } var g = gen(); g.next() // a g.throw() // b g.next() // c 上面代码中，g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。另外，也可以看到，只要Generator函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。 另外，throw命令与g.throw方法是无关的，两者互不影响。 var gen = function* gen(){ yield console.log(&#39;hello&#39;); yield console.log(&#39;world&#39;); } var g = gen(); g.next(); try { throw new Error(); } catch (e) { g.next(); } // hello // world 上面代码中，throw命令抛出的错误不会影响到遍历器的状态，所以两次执行next方法，都进行了正确的操作。 这种函数体内捕获错误的机制，大大方便了对错误的处理。多个yield语句，可以只用一个try...catch代码块来捕获错误。如果使用回调函数的写法，想要捕获多个错误，就不得不为每个函数内部写一个错误处理语句，现在只在Generator函数内部写一次catch语句就可以了。 Generator函数体外抛出的错误，可以在函数体内捕获；反过来，Generator函数体内抛出的错误，也可以被函数体外的catch捕获。 function *foo() { var x = yield 3; var y = x.toUpperCase(); yield y; } var it = foo(); it.next(); // { value:3, done:false } try { it.next(42); } catch (err) { console.log(err); } 上面代码中，第二个next方法向函数体内传入一个参数42，数值是没有toUpperCase方法的，所以会抛出一个TypeError错误，被函数体外的catch捕获。 一旦Generator执行过程中抛出错误，且没有被内部捕获，就不会再执行下去了。如果此后还调用next方法，将返回一个value属性等于undefined、done属性等于true的对象，即JavaScript引擎认为这个Generator已经运行结束了。 function* g() { yield 1; console.log(&#39;throwing an exception&#39;); throw new Error(&#39;generator broke!&#39;); yield 2; yield 3; } function log(generator) { var v; console.log(&#39;starting generator&#39;); try { v = generator.next(); console.log(&#39;第一次运行next方法&#39;, v); } catch (err) { console.log(&#39;捕捉错误&#39;, v); } try { v = generator.next(); console.log(&#39;第二次运行next方法&#39;, v); } catch (err) { console.log(&#39;捕捉错误&#39;, v); } try { v = generator.next(); console.log(&#39;第三次运行next方法&#39;, v); } catch (err) { console.log(&#39;捕捉错误&#39;, v); } console.log(&#39;caller done&#39;); } log(g()); // starting generator // 第一次运行next方法 { value: 1, done: false } // throwing an exception // 捕捉错误 { value: 1, done: false } // 第三次运行next方法 { value: undefined, done: true } // caller done 上面代码一共三次运行next方法，第二次运行的时候会抛出错误，然后第三次运行的时候，Generator函数就已经结束了，不再执行下去了。 Generator.prototype.return()Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，并且终结遍历Generator函数。 function* gen() { yield 1; yield 2; yield 3; } var g = gen(); g.next() // { value: 1, done: false } g.return(&#39;foo&#39;) // { value: &quot;foo&quot;, done: true } g.next() // { value: undefined, done: true } 上面代码中，遍历器对象g调用return方法后，返回值的value属性就是return方法的参数foo。并且，Generator函数的遍历就终止了，返回值的done属性为true，以后再调用next方法，done属性总是返回true。 如果return方法调用时，不提供参数，则返回值的value属性为undefined。 function* gen() { yield 1; yield 2; yield 3; } var g = gen(); g.next() // { value: 1, done: false } g.return() // { value: undefined, done: true } 如果Generator函数内部有try...finally代码块，那么return方法会推迟到finally代码块执行完再执行。 function* numbers () { yield 1; try { yield 2; yield 3; } finally { yield 4; yield 5; } yield 6; } var g = numbers() g.next() // { done: false, value: 1 } g.next() // { done: false, value: 2 } g.return(7) // { done: false, value: 4 } g.next() // { done: false, value: 5 } g.next() // { done: true, value: 7 } 上面代码中，调用return方法后，就开始执行finally代码块，然后等到finally代码块执行完，再执行return方法。 yield* 语句如果在 Generator 函数内部，调用另一个 Generator 函数，默认情况下是没有效果的。 function* foo() { yield &#39;a&#39;; yield &#39;b&#39;; } function* bar() { yield &#39;x&#39;; foo(); yield &#39;y&#39;; } for (let v of bar()){ console.log(v); } // &quot;x&quot; // &quot;y&quot; 上面代码中，foo和bar都是 Generator 函数，在bar里面调用foo，是不会有效果的。 这个就需要用到yield*语句，用来在一个 Generator 函数里面执行另一个 Generator 函数。 function* bar() { yield &#39;x&#39;; yield* foo(); yield &#39;y&#39;; } // 等同于 function* bar() { yield &#39;x&#39;; yield &#39;a&#39;; yield &#39;b&#39;; yield &#39;y&#39;; } // 等同于 function* bar() { yield &#39;x&#39;; for (let v of foo()) { yield v; } yield &#39;y&#39;; } for (let v of bar()){ console.log(v); } // &quot;x&quot; // &quot;a&quot; // &quot;b&quot; // &quot;y&quot; 再来看一个对比的例子。 function* inner() { yield &#39;hello!&#39;; } function* outer1() { yield &#39;open&#39;; yield inner(); yield &#39;close&#39;; } var gen = outer1() gen.next().value // &quot;open&quot; gen.next().value // 返回一个遍历器对象 gen.next().value // &quot;close&quot; function* outer2() { yield &#39;open&#39; yield* inner() yield &#39;close&#39; } var gen = outer2() gen.next().value // &quot;open&quot; gen.next().value // &quot;hello!&quot; gen.next().value // &quot;close&quot; 上面例子中，outer2使用了yield*，outer1没使用。结果就是，outer1返回一个遍历器对象，outer2返回该遍历器对象的内部值。 从语法角度看，如果yield命令后面跟的是一个遍历器对象，需要在yield命令后面加上星号，表明它返回的是一个遍历器对象。这被称为yield*语句。 let delegatedIterator = (function* () { yield &#39;Hello!&#39;; yield &#39;Bye!&#39;; }()); let delegatingIterator = (function* () { yield &#39;Greetings!&#39;; yield* delegatedIterator; yield &#39;Ok, bye.&#39;; }()); for(let value of delegatingIterator) { console.log(value); } // &quot;Greetings! // &quot;Hello!&quot; // &quot;Bye!&quot; // &quot;Ok, bye.&quot; 上面代码中，delegatingIterator是代理者，delegatedIterator是被代理者。由于yield* delegatedIterator语句得到的值，是一个遍历器，所以要用星号表示。运行结果就是使用一个遍历器，遍历了多个Generator函数，有递归的效果。 yield*后面的Generator函数（没有return语句时），等同于在Generator函数内部，部署一个for...of循环。 function* concat(iter1, iter2) { yield* iter1; yield* iter2; } // 等同于 function* concat(iter1, iter2) { for (var value of iter1) { yield value; } for (var value of iter2) { yield value; } } 上面代码说明，yield*后面的Generator函数（没有return语句时），不过是for...of的一种简写形式，完全可以用后者替代前者。反之，则需要用var value = yield* iterator的形式获取return语句的值。 如果yield*后面跟着一个数组，由于数组原生支持遍历器，因此就会遍历数组成员。 function* gen(){ yield* [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]; } gen().next() // { value:&quot;a&quot;, done:false } 上面代码中，yield命令后面如果不加星号，返回的是整个数组，加了星号就表示返回的是数组的遍历器对象。 实际上，任何数据结构只要有Iterator接口，就可以被yield*遍历。 let read = (function* () { yield &#39;hello&#39;; yield* &#39;hello&#39;; })(); read.next().value // &quot;hello&quot; read.next().value // &quot;h&quot; 上面代码中，yield语句返回整个字符串，yield*语句返回单个字符。因为字符串具有Iterator接口，所以被yield*遍历。 如果被代理的Generator函数有return语句，那么就可以向代理它的Generator函数返回数据。 function *foo() { yield 2; yield 3; return &quot;foo&quot;; } function *bar() { yield 1; var v = yield *foo(); console.log( &quot;v: &quot; + v ); yield 4; } var it = bar(); it.next() // {value: 1, done: false} it.next() // {value: 2, done: false} it.next() // {value: 3, done: false} it.next(); // &quot;v: foo&quot; // {value: 4, done: false} it.next() // {value: undefined, done: true} 上面代码在第四次调用next方法的时候，屏幕上会有输出，这是因为函数foo的return语句，向函数bar提供了返回值。 再看一个例子。 function* genFuncWithReturn() { yield &#39;a&#39;; yield &#39;b&#39;; return &#39;The result&#39;; } function* logReturned(genObj) { let result = yield* genObj; console.log(result); } [...logReturned(genFuncWithReturn())] // The result // 值为 [ &#39;a&#39;, &#39;b&#39; ] 上面代码中，存在两次遍历。第一次是扩展运算符遍历函数logReturned返回的遍历器对象，第二次是yield*语句遍历函数genFuncWithReturn返回的遍历器对象。这两次遍历的效果是叠加的，最终表现为扩展运算符遍历函数genFuncWithReturn返回的遍历器对象。所以，最后的数据表达式得到的值等于[ &#39;a&#39;, &#39;b&#39; ]。但是，函数genFuncWithReturn的return语句的返回值The result，会返回给函数logReturned内部的result变量，因此会有终端输出。 yield*命令可以很方便地取出嵌套数组的所有成员。 function* iterTree(tree) { if (Array.isArray(tree)) { for(let i=0; i &lt; tree.length; i++) { yield* iterTree(tree[i]); } } else { yield tree; } } const tree = [ &#39;a&#39;, [&#39;b&#39;, &#39;c&#39;], [&#39;d&#39;, &#39;e&#39;] ]; for(let x of iterTree(tree)) { console.log(x); } // a // b // c // d // e 下面是一个稍微复杂的例子，使用yield*语句遍历完全二叉树。 // 下面是二叉树的构造函数， // 三个参数分别是左树、当前节点和右树 function Tree(left, label, right) { this.left = left; this.label = label; this.right = right; } // 下面是中序（inorder）遍历函数。 // 由于返回的是一个遍历器，所以要用generator函数。 // 函数体内采用递归算法，所以左树和右树要用yield*遍历 function* inorder(t) { if (t) { yield* inorder(t.left); yield t.label; yield* inorder(t.right); } } // 下面生成二叉树 function make(array) { // 判断是否为叶节点 if (array.length == 1) return new Tree(null, array[0], null); return new Tree(make(array[0]), array[1], make(array[2])); } let tree = make([[[&#39;a&#39;], &#39;b&#39;, [&#39;c&#39;]], &#39;d&#39;, [[&#39;e&#39;], &#39;f&#39;, [&#39;g&#39;]]]); // 遍历二叉树 var result = []; for (let node of inorder(tree)) { result.push(node); } result // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;, &#39;f&#39;, &#39;g&#39;] 作为对象属性的Generator函数如果一个对象的属性是Generator函数，可以简写成下面的形式。 let obj = { * myGeneratorMethod() { ··· } }; 上面代码中，myGeneratorMethod属性前面有一个星号，表示这个属性是一个Generator函数。 它的完整形式如下，与上面的写法是等价的。 let obj = { myGeneratorMethod: function* () { // ··· } }; Generator函数的thisGenerator函数总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的prototype对象上的方法。 function* g() {} g.prototype.hello = function () { return &#39;hi!&#39;; }; let obj = g(); obj instanceof g // true obj.hello() // &#39;hi!&#39; 上面代码表明，Generator函数g返回的遍历器obj，是g的实例，而且继承了g.prototype。但是，如果把g当作普通的构造函数，并不会生效，因为g返回的总是遍历器对象，而不是this对象。 function* g() { this.a = 11; } let obj = g(); obj.a // undefined 上面代码中，Generator函数g在this对象上面添加了一个属性a，但是obj对象拿不到这个属性。 Generator函数也不能跟new命令一起用，会报错。 function* F() { yield this.x = 2; yield this.y = 3; } new F() // TypeError: F is not a constructor 上面代码中，new命令跟构造函数F一起使用，结果报错，因为F不是构造函数。 那么，有没有办法让Generator函数返回一个正常的对象实例，既可以用next方法，又可以获得正常的this？ 下面是一个变通方法。首先，生成一个空对象，使用call方法绑定Generator函数内部的this。这样，构造函数调用以后，这个空对象就是Generator函数的实例对象了。 function* F() { this.a = 1; yield this.b = 2; yield this.c = 3; } var obj = {}; var f = F.call(obj); f.next(); // Object {value: 2, done: false} f.next(); // Object {value: 3, done: false} f.next(); // Object {value: undefined, done: true} obj.a // 1 obj.b // 2 obj.c // 3 上面代码中，首先是F内部的this对象绑定obj对象，然后调用它，返回一个Iterator对象。这个对象执行三次next方法（因为F内部有两个yield语句），完成F内部所有代码的运行。这时，所有内部属性都绑定在obj对象上了，因此obj对象也就成了F的实例。 上面代码中，执行的是遍历器对象f，但是生成的对象实例是obj，有没有办法将这两个对象统一呢？ 一个办法就是将obj换成F.prototype。 function* F() { this.a = 1; yield this.b = 2; yield this.c = 3; } var f = F.call(F.prototype); f.next(); // Object {value: 2, done: false} f.next(); // Object {value: 3, done: false} f.next(); // Object {value: undefined, done: true} f.a // 1 f.b // 2 f.c // 3 再将F改成构造函数，就可以对它执行new命令了。 function* gen() { this.a = 1; yield this.b = 2; yield this.c = 3; } function F() { return gen.call(gen.prototype); } var f = new F(); f.next(); // Object {value: 2, done: false} f.next(); // Object {value: 3, done: false} f.next(); // Object {value: undefined, done: true} f.a // 1 f.b // 2 f.c // 3 含义Generator与状态机Generator是实现状态机的最佳结构。比如，下面的clock函数就是一个状态机。 var ticking = true; var clock = function() { if (ticking) console.log(&#39;Tick!&#39;); else console.log(&#39;Tock!&#39;); ticking = !ticking; } 上面代码的clock函数一共有两种状态（Tick和Tock），每运行一次，就改变一次状态。这个函数如果用Generator实现，就是下面这样。 var clock = function*() { while (true) { console.log(&#39;Tick!&#39;); yield; console.log(&#39;Tock!&#39;); yield; } }; 上面的Generator实现与ES5实现对比，可以看到少了用来保存状态的外部变量ticking，这样就更简洁，更安全（状态不会被非法篡改）、更符合函数式编程的思想，在写法上也更优雅。Generator之所以可以不用外部变量保存状态，是因为它本身就包含了一个状态信息，即目前是否处于暂停态。 Generator与协程协程（coroutine）是一种程序运行的方式，可以理解成“协作的线程”或“协作的函数”。协程既可以用单线程实现，也可以用多线程实现。前者是一种特殊的子例程，后者是一种特殊的线程。 （1）协程与子例程的差异 传统的“子例程”（subroutine）采用堆栈式“后进先出”的执行方式，只有当调用的子函数完全执行完毕，才会结束执行父函数。协程与其不同，多个线程（单线程情况下，即多个函数）可以并行执行，但是只有一个线程（或函数）处于正在运行的状态，其他线程（或函数）都处于暂停态（suspended），线程（或函数）之间可以交换执行权。也就是说，一个线程（或函数）执行到一半，可以暂停执行，将执行权交给另一个线程（或函数），等到稍后收回执行权的时候，再恢复执行。这种可以并行执行、交换执行权的线程（或函数），就称为协程。 从实现上看，在内存中，子例程只使用一个栈（stack），而协程是同时存在多个栈，但只有一个栈是在运行状态，也就是说，协程是以多占用内存为代价，实现多任务的并行。 （2）协程与普通线程的差异 不难看出，协程适合用于多任务运行的环境。在这个意义上，它与普通的线程很相似，都有自己的执行上下文、可以分享全局变量。它们的不同之处在于，同一时间可以有多个线程处于运行状态，但是运行的协程只能有一个，其他协程都处于暂停状态。此外，普通的线程是抢先式的，到底哪个线程优先得到资源，必须由运行环境决定，但是协程是合作式的，执行权由协程自己分配。 由于ECMAScript是单线程语言，只能保持一个调用栈。引入协程以后，每个任务可以保持自己的调用栈。这样做的最大好处，就是抛出错误的时候，可以找到原始的调用栈。不至于像异步操作的回调函数那样，一旦出错，原始的调用栈早就结束。 Generator函数是ECMAScript 6对协程的实现，但属于不完全实现。Generator函数被称为“半协程”（semi-coroutine），意思是只有Generator函数的调用者，才能将程序的执行权还给Generator函数。如果是完全执行的协程，任何函数都可以让暂停的协程继续执行。 如果将Generator函数当作协程，完全可以将多个需要互相协作的任务写成Generator函数，它们之间使用yield语句交换控制权。 应用Generator可以暂停函数执行，返回任意表达式的值。这种特点使得Generator有多种应用场景。 （1）异步操作的同步化表达Generator函数的暂停执行的效果，意味着可以把异步操作写在yield语句里面，等到调用next方法时再往后执行。这实际上等同于不需要写回调函数了，因为异步操作的后续操作可以放在yield语句下面，反正要等到调用next方法时再执行。所以，Generator函数的一个重要实际意义就是用来处理异步操作，改写回调函数。 function* loadUI() { showLoadingScreen(); yield loadUIDataAsynchronously(); hideLoadingScreen(); } var loader = loadUI(); // 加载UI loader.next() // 卸载UI loader.next() 上面代码表示，第一次调用loadUI函数时，该函数不会执行，仅返回一个遍历器。下一次对该遍历器调用next方法，则会显示Loading界面，并且异步加载数据。等到数据加载完成，再一次使用next方法，则会隐藏Loading界面。可以看到，这种写法的好处是所有Loading界面的逻辑，都被封装在一个函数，按部就班非常清晰。 Ajax是典型的异步操作，通过Generator函数部署Ajax操作，可以用同步的方式表达。 function* main() { var result = yield request(&quot;http://some.url&quot;); var resp = JSON.parse(result); console.log(resp.value); } function request(url) { makeAjaxCall(url, function(response){ it.next(response); }); } var it = main(); it.next(); 上面代码的main函数，就是通过Ajax操作获取数据。可以看到，除了多了一个yield，它几乎与同步操作的写法完全一样。注意，makeAjaxCall函数中的next方法，必须加上response参数，因为yield语句构成的表达式，本身是没有值的，总是等于undefined。 下面是另一个例子，通过Generator函数逐行读取文本文件。 function* numbers() { let file = new FileReader(&quot;numbers.txt&quot;); try { while(!file.eof) { yield parseInt(file.readLine(), 10); } } finally { file.close(); } } 上面代码打开文本文件，使用yield语句可以手动逐行读取文件。 （2）控制流管理如果有一个多步操作非常耗时，采用回调函数，可能会写成下面这样。 step1(function (value1) { step2(value1, function(value2) { step3(value2, function(value3) { step4(value3, function(value4) { // Do something with value4 }); }); }); }); 采用Promise改写上面的代码。 Promise.resolve(step1) .then(step2) .then(step3) .then(step4) .then(function (value4) { // Do something with value4 }, function (error) { // Handle any error from step1 through step4 }) .done(); 上面代码已经把回调函数，改成了直线执行的形式，但是加入了大量Promise的语法。Generator函数可以进一步改善代码运行流程。 function* longRunningTask(value1) { try { var value2 = yield step1(value1); var value3 = yield step2(value2); var value4 = yield step3(value3); var value5 = yield step4(value4); // Do something with value4 } catch (e) { // Handle any error from step1 through step4 } } 然后，使用一个函数，按次序自动执行所有步骤。 scheduler(longRunningTask(initialValue)); function scheduler(task) { var taskObj = task.next(task.value); // 如果Generator函数未结束，就继续调用 if (!taskObj.done) { task.value = taskObj.value scheduler(task); } } 注意，上面这种做法，只适合同步操作，即所有的task都必须是同步的，不能有异步操作。因为这里的代码一得到返回值，就继续往下执行，没有判断异步操作何时完成。如果要控制异步的操作流程，详见后面的《异步操作》一章。 下面，利用for...of循环会自动依次执行yield命令的特性，提供一种更一般的控制流管理的方法。 let steps = [step1Func, step2Func, step3Func]; function *iterateSteps(steps){ for (var i=0; i&lt; steps.length; i++){ var step = steps[i]; yield step(); } } 上面代码中，数组steps封装了一个任务的多个步骤，Generator函数iterateSteps则是依次为这些步骤加上yield命令。 将任务分解成步骤之后，还可以将项目分解成多个依次执行的任务。 let jobs = [job1, job2, job3]; function *iterateJobs(jobs){ for (var i=0; i&lt; jobs.length; i++){ var job = jobs[i]; yield *iterateSteps(job.steps); } } 上面代码中，数组jobs封装了一个项目的多个任务，Generator函数iterateJobs则是依次为这些任务加上yield *命令。 最后，就可以用for...of循环一次性依次执行所有任务的所有步骤。 for (var step of iterateJobs(jobs)){ console.log(step.id); } 再次提醒，上面的做法只能用于所有步骤都是同步操作的情况，不能有异步操作的步骤。如果想要依次执行异步的步骤，必须使用后面的《异步操作》一章介绍的方法。 for...of的本质是一个while循环，所以上面的代码实质上执行的是下面的逻辑。 var it = iterateJobs(jobs); var res = it.next(); while (!res.done){ var result = res.value; // ... res = it.next(); } （3）部署Iterator接口利用Generator函数，可以在任意对象上部署Iterator接口。 function* iterEntries(obj) { let keys = Object.keys(obj); for (let i=0; i &lt; keys.length; i++) { let key = keys[i]; yield [key, obj[key]]; } } let myObj = { foo: 3, bar: 7 }; for (let [key, value] of iterEntries(myObj)) { console.log(key, value); } // foo 3 // bar 7 上述代码中，myObj是一个普通对象，通过iterEntries函数，就有了Iterator接口。也就是说，可以在任意对象上部署next方法。 下面是一个对数组部署Iterator接口的例子，尽管数组原生具有这个接口。 function* makeSimpleGenerator(array){ var nextIndex = 0; while(nextIndex &lt; array.length){ yield array[nextIndex++]; } } var gen = makeSimpleGenerator([&#39;yo&#39;, &#39;ya&#39;]); gen.next().value // &#39;yo&#39; gen.next().value // &#39;ya&#39; gen.next().done // true （4）作为数据结构Generator可以看作是数据结构，更确切地说，可以看作是一个数组结构，因为Generator函数可以返回一系列的值，这意味着它可以对任意表达式，提供类似数组的接口。 function *doStuff() { yield fs.readFile.bind(null, &#39;hello.txt&#39;); yield fs.readFile.bind(null, &#39;world.txt&#39;); yield fs.readFile.bind(null, &#39;and-such.txt&#39;); } 上面代码就是依次返回三个函数，但是由于使用了Generator函数，导致可以像处理数组那样，处理这三个返回的函数。 for (task of doStuff()) { // task是一个函数，可以像回调函数那样使用它 } 实际上，如果用ES5表达，完全可以用数组模拟Generator的这种用法。 function doStuff() { return [ fs.readFile.bind(null, &#39;hello.txt&#39;), fs.readFile.bind(null, &#39;world.txt&#39;), fs.readFile.bind(null, &#39;and-such.txt&#39;) ]; } 上面的函数，可以用一模一样的for…of循环处理！两相一比较，就不难看出Generator使得数据或者操作，具备了类似数组的接口。 感谢阮一峰老师的原创，本分享仅供学习交流","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Generator","slug":"Generator","permalink":"https://microzz.com/tags/Generator/"}]},{"title":"Iterator和for...of循环","date":"2017-01-12T07:45:19.000Z","path":"2017/01/12/iterator/","text":"Iterator和for…of循环Iterator（遍历器）的概念JavaScript原有的表示“集合”的数据结构，主要是数组（Array）和对象（Object），ES6又添加了Map和Set。这样就有了四种数据集合，用户还可以组合使用它们，定义自己的数据结构，比如数组的成员是Map，Map的成员是对象。这样就需要一种统一的接口机制，来处理所有不同的数据结构。 遍历器（Iterator）就是这样一种机制。它是一种接口，为各种不同的数据结构提供统一的访问机制。任何数据结构只要部署Iterator接口，就可以完成遍历操作（即依次处理该数据结构的所有成员）。 Iterator的作用有三个：一是为各种数据结构，提供一个统一的、简便的访问接口；二是使得数据结构的成员能够按某种次序排列；三是ES6创造了一种新的遍历命令for...of循环，Iterator接口主要供for...of消费。 Iterator的遍历过程是这样的。 （1）创建一个指针对象，指向当前数据结构的起始位置。也就是说，遍历器对象本质上，就是一个指针对象。 （2）第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员。 （3）第二次调用指针对象的next方法，指针就指向数据结构的第二个成员。 （4）不断调用指针对象的next方法，直到它指向数据结构的结束位置。 每一次调用next方法，都会返回数据结构的当前成员的信息。具体来说，就是返回一个包含value和done两个属性的对象。其中，value属性是当前成员的值，done属性是一个布尔值，表示遍历是否结束。 下面是一个模拟next方法返回值的例子。 var it = makeIterator([&#39;a&#39;, &#39;b&#39;]); it.next() // { value: &quot;a&quot;, done: false } it.next() // { value: &quot;b&quot;, done: false } it.next() // { value: undefined, done: true } function makeIterator(array) { var nextIndex = 0; return { next: function() { return nextIndex &lt; array.length ? {value: array[nextIndex++], done: false} : {value: undefined, done: true}; } }; } 上面代码定义了一个makeIterator函数，它是一个遍历器生成函数，作用就是返回一个遍历器对象。对数组[&#39;a&#39;, &#39;b&#39;]执行这个函数，就会返回该数组的遍历器对象（即指针对象）it。 指针对象的next方法，用来移动指针。开始时，指针指向数组的开始位置。然后，每次调用next方法，指针就会指向数组的下一个成员。第一次调用，指向a；第二次调用，指向b。 next方法返回一个对象，表示当前数据成员的信息。这个对象具有value和done两个属性，value属性返回当前位置的成员，done属性是一个布尔值，表示遍历是否结束，即是否还有必要再一次调用next方法。 总之，调用指针对象的next方法，就可以遍历事先给定的数据结构。 对于遍历器对象来说，done: false和value: undefined属性都是可以省略的，因此上面的makeIterator函数可以简写成下面的形式。 function makeIterator(array) { var nextIndex = 0; return { next: function() { return nextIndex &lt; array.length ? {value: array[nextIndex++]} : {done: true}; } }; } 由于Iterator只是把接口规格加到数据结构之上，所以，遍历器与它所遍历的那个数据结构，实际上是分开的，完全可以写出没有对应数据结构的遍历器对象，或者说用遍历器对象模拟出数据结构。下面是一个无限运行的遍历器对象的例子。 var it = idMaker(); it.next().value // &#39;0&#39; it.next().value // &#39;1&#39; it.next().value // &#39;2&#39; // ... function idMaker() { var index = 0; return { next: function() { return {value: index++, done: false}; } }; } 上面的例子中，遍历器生成函数idMaker，返回一个遍历器对象（即指针对象）。但是并没有对应的数据结构，或者说，遍历器对象自己描述了一个数据结构出来。 在ES6中，有些数据结构原生具备Iterator接口（比如数组），即不用任何处理，就可以被for...of循环遍历，有些就不行（比如对象）。原因在于，这些数据结构原生部署了Symbol.iterator属性（详见下文），另外一些数据结构没有。凡是部署了Symbol.iterator属性的数据结构，就称为部署了遍历器接口。调用这个接口，就会返回一个遍历器对象。 如果使用TypeScript的写法，遍历器接口（Iterable）、指针对象（Iterator）和next方法返回值的规格可以描述如下。 interface Iterable { [Symbol.iterator]() : Iterator, } interface Iterator { next(value?: any) : IterationResult, } interface IterationResult { value: any, done: boolean, } 数据结构的默认Iterator接口Iterator接口的目的，就是为所有数据结构，提供了一种统一的访问机制，即for...of循环（详见下文）。当使用for...of循环遍历某种数据结构时，该循环会自动去寻找Iterator接口。 一种数据结构只要部署了Iterator接口，我们就称这种数据结构是”可遍历的“（iterable）。 ES6规定，默认的Iterator接口部署在数据结构的Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是“可遍历的”（iterable）。Symbol.iterator属性本身是一个函数，就是当前数据结构默认的遍历器生成函数。执行这个函数，就会返回一个遍历器。至于属性名Symbol.iterator，它是一个表达式，返回Symbol对象的iterator属性，这是一个预定义好的、类型为Symbol的特殊值，所以要放在方括号内。（参见Symbol一章）。 const obj = { [Symbol.iterator] : function () { return { next: function () { return { value: 1, done: true }; } }; } }; 上面代码中，对象obj是可遍历的（iterable），因为具有Symbol.iterator属性。执行这个属性，会返回一个遍历器对象。该对象的根本特征就是具有next方法。每次调用next方法，都会返回一个代表当前成员的信息对象，具有value和done两个属性。 在ES6中，有三类数据结构原生具备Iterator接口：数组、某些类似数组的对象、Set和Map结构。 let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; let iter = arr[Symbol.iterator](); iter.next() // { value: &#39;a&#39;, done: false } iter.next() // { value: &#39;b&#39;, done: false } iter.next() // { value: &#39;c&#39;, done: false } iter.next() // { value: undefined, done: true } 上面代码中，变量arr是一个数组，原生就具有遍历器接口，部署在arr的Symbol.iterator属性上面。所以，调用这个属性，就得到遍历器对象。 上面提到，原生就部署Iterator接口的数据结构有三类，对于这三类数据结构，不用自己写遍历器生成函数，for...of循环会自动遍历它们。除此之外，其他数据结构（主要是对象）的Iterator接口，都需要自己在Symbol.iterator属性上面部署，这样才会被for...of循环遍历。 对象（Object）之所以没有默认部署Iterator接口，是因为对象的哪个属性先遍历，哪个属性后遍历是不确定的，需要开发者手动指定。本质上，遍历器是一种线性处理，对于任何非线性的数据结构，部署遍历器接口，就等于部署一种线性转换。不过，严格地说，对象部署遍历器接口并不是很必要，因为这时对象实际上被当作Map结构使用，ES5没有Map结构，而ES6原生提供了。 一个对象如果要有可被for...of循环调用的Iterator接口，就必须在Symbol.iterator的属性上部署遍历器生成方法（原型链上的对象具有该方法也可）。 class RangeIterator { constructor(start, stop) { this.value = start; this.stop = stop; } [Symbol.iterator]() { return this; } next() { var value = this.value; if (value &lt; this.stop) { this.value++; return {done: false, value: value}; } else { return {done: true, value: undefined}; } } } function range(start, stop) { return new RangeIterator(start, stop); } for (var value of range(0, 3)) { console.log(value); } 上面代码是一个类部署Iterator接口的写法。Symbol.iterator属性对应一个函数，执行后返回当前对象的遍历器对象。 下面是通过遍历器实现指针结构的例子。 function Obj(value) { this.value = value; this.next = null; } Obj.prototype[Symbol.iterator] = function() { var iterator = { next: next }; var current = this; function next() { if (current) { var value = current.value; current = current.next; return { done: false, value: value }; } else { return { done: true }; } } return iterator; } var one = new Obj(1); var two = new Obj(2); var three = new Obj(3); one.next = two; two.next = three; for (var i of one){ console.log(i); } // 1 // 2 // 3 上面代码首先在构造函数的原型链上部署Symbol.iterator方法，调用该方法会返回遍历器对象iterator，调用该对象的next方法，在返回一个值的同时，自动将内部指针移到下一个实例。 下面是另一个为对象添加Iterator接口的例子。 let obj = { data: [ &#39;hello&#39;, &#39;world&#39; ], [Symbol.iterator]() { const self = this; let index = 0; return { next() { if (index &lt; self.data.length) { return { value: self.data[index++], done: false }; } else { return { value: undefined, done: true }; } } }; } }; 对于类似数组的对象（存在数值键名和length属性），部署Iterator接口，有一个简便方法，就是Symbol.iterator方法直接引用数组的Iterator接口。 NodeList.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator]; // 或者 NodeList.prototype[Symbol.iterator] = [][Symbol.iterator]; [...document.querySelectorAll(&#39;div&#39;)] // 可以执行了 下面是类似数组的对象调用数组的Symbol.iterator方法的例子。 let iterable = { 0: &#39;a&#39;, 1: &#39;b&#39;, 2: &#39;c&#39;, length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator] }; for (let item of iterable) { console.log(item); // &#39;a&#39;, &#39;b&#39;, &#39;c&#39; } 注意，普通对象部署数组的Symbol.iterator方法，并无效果。 let iterable = { a: &#39;a&#39;, b: &#39;b&#39;, c: &#39;c&#39;, length: 3, [Symbol.iterator]: Array.prototype[Symbol.iterator] }; for (let item of iterable) { console.log(item); // undefined, undefined, undefined } 如果Symbol.iterator方法对应的不是遍历器生成函数（即会返回一个遍历器对象），解释引擎将会报错。 var obj = {}; obj[Symbol.iterator] = () =&gt; 1; [...obj] // TypeError: [] is not a function 上面代码中，变量obj的Symbol.iterator方法对应的不是遍历器生成函数，因此报错。 有了遍历器接口，数据结构就可以用for...of循环遍历（详见下文），也可以使用while循环遍历。 var $iterator = ITERABLE[Symbol.iterator](); var $result = $iterator.next(); while (!$result.done) { var x = $result.value; // ... $result = $iterator.next(); } 上面代码中，ITERABLE代表某种可遍历的数据结构，$iterator是它的遍历器对象。遍历器对象每次移动指针（next方法），都检查一下返回值的done属性，如果遍历还没结束，就移动遍历器对象的指针到下一步（next方法），不断循环。 调用Iterator接口的场合有一些场合会默认调用Iterator接口（即Symbol.iterator方法），除了下文会介绍的for...of循环，还有几个别的场合。 （1）解构赋值 对数组和Set结构进行解构赋值时，会默认调用Symbol.iterator方法。 let set = new Set().add(&#39;a&#39;).add(&#39;b&#39;).add(&#39;c&#39;); let [x,y] = set; // x=&#39;a&#39;; y=&#39;b&#39; let [first, ...rest] = set; // first=&#39;a&#39;; rest=[&#39;b&#39;,&#39;c&#39;]; （2）扩展运算符 扩展运算符（…）也会调用默认的iterator接口。 // 例一 var str = &#39;hello&#39;; [...str] // [&#39;h&#39;,&#39;e&#39;,&#39;l&#39;,&#39;l&#39;,&#39;o&#39;] // 例二 let arr = [&#39;b&#39;, &#39;c&#39;]; [&#39;a&#39;, ...arr, &#39;d&#39;] // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;] 上面代码的扩展运算符内部就调用Iterator接口。 实际上，这提供了一种简便机制，可以将任何部署了Iterator接口的数据结构，转为数组。也就是说，只要某个数据结构部署了Iterator接口，就可以对它使用扩展运算符，将其转为数组。 let arr = [...iterable]; （3）yield* yield*后面跟的是一个可遍历的结构，它会调用该结构的遍历器接口。 let generator = function* () { yield 1; yield* [2,3,4]; yield 5; }; var iterator = generator(); iterator.next() // { value: 1, done: false } iterator.next() // { value: 2, done: false } iterator.next() // { value: 3, done: false } iterator.next() // { value: 4, done: false } iterator.next() // { value: 5, done: false } iterator.next() // { value: undefined, done: true } （4）其他场合 由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口。下面是一些例子。 for…of Array.from() Map(), Set(), WeakMap(), WeakSet()（比如new Map([[&#39;a&#39;,1],[&#39;b&#39;,2]])） Promise.all() Promise.race() 字符串的Iterator接口字符串是一个类似数组的对象，也原生具有Iterator接口。 var someString = &quot;hi&quot;; typeof someString[Symbol.iterator] // &quot;function&quot; var iterator = someString[Symbol.iterator](); iterator.next() // { value: &quot;h&quot;, done: false } iterator.next() // { value: &quot;i&quot;, done: false } iterator.next() // { value: undefined, done: true } 上面代码中，调用Symbol.iterator方法返回一个遍历器对象，在这个遍历器上可以调用next方法，实现对于字符串的遍历。 可以覆盖原生的Symbol.iterator方法，达到修改遍历器行为的目的。 var str = new String(&quot;hi&quot;); [...str] // [&quot;h&quot;, &quot;i&quot;] str[Symbol.iterator] = function() { return { next: function() { if (this._first) { this._first = false; return { value: &quot;bye&quot;, done: false }; } else { return { done: true }; } }, _first: true }; }; [...str] // [&quot;bye&quot;] str // &quot;hi&quot; 上面代码中，字符串str的Symbol.iterator方法被修改了，所以扩展运算符（...）返回的值变成了bye，而字符串本身还是hi。 Iterator接口与Generator函数Symbol.iterator方法的最简单实现，还是使用下一章要介绍的Generator函数。 var myIterable = {}; myIterable[Symbol.iterator] = function* () { yield 1; yield 2; yield 3; }; [...myIterable] // [1, 2, 3] // 或者采用下面的简洁写法 let obj = { * [Symbol.iterator]() { yield &#39;hello&#39;; yield &#39;world&#39;; } }; for (let x of obj) { console.log(x); } // hello // world 上面代码中，Symbol.iterator方法几乎不用部署任何代码，只要用yield命令给出每一步的返回值即可。 遍历器对象的return()，throw()遍历器对象除了具有next方法，还可以具有return方法和throw方法。如果你自己写遍历器对象生成函数，那么next方法是必须部署的，return方法和throw方法是否部署是可选的。 return方法的使用场合是，如果for...of循环提前退出（通常是因为出错，或者有break语句或continue语句），就会调用return方法。如果一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法。 function readLinesSync(file) { return { next() { if (file.isAtEndOfFile()) { file.close(); return { done: true }; } }, return() { file.close(); return { done: true }; }, }; } 上面代码中，函数readLinesSync接受一个文件对象作为参数，返回一个遍历器对象，其中除了next方法，还部署了return方法。下面，我们让文件的遍历提前返回，这样就会触发执行return方法。 for (let line of readLinesSync(fileName)) { console.log(line); break; } 注意，return方法必须返回一个对象，这是Generator规格决定的。 throw方法主要是配合Generator函数使用，一般的遍历器对象用不到这个方法。请参阅《Generator函数》一章。 for…of循环ES6 借鉴 C++、Java、C# 和 Python 语言，引入了for...of循环，作为遍历所有数据结构的统一的方法。 一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口，就可以用for...of循环遍历它的成员。也就是说，for...of循环内部调用的是数据结构的Symbol.iterator方法。 for...of循环可以使用的范围包括数组、Set 和 Map 结构、某些类似数组的对象（比如arguments对象、DOM NodeList 对象）、后文的 Generator 对象，以及字符串。 数组数组原生具备iterator接口（即默认部署了Symbol.iterator属性），for...of循环本质上就是调用这个接口产生的遍历器，可以用下面的代码证明。 const arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]; for(let v of arr) { console.log(v); // red green blue } const obj = {}; obj[Symbol.iterator] = arr[Symbol.iterator].bind(arr); for(let v of obj) { console.log(v); // red green blue } 上面代码中，空对象obj部署了数组arr的Symbol.iterator属性，结果obj的for...of循环，产生了与arr完全一样的结果。 for...of循环可以代替数组实例的forEach方法。 const arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]; arr.forEach(function (element, index) { console.log(element); // red green blue console.log(index); // 0 1 2 }); JavaScript原有的for...in循环，只能获得对象的键名，不能直接获取键值。ES6提供for...of循环，允许遍历获得键值。 var arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]; for (let a in arr) { console.log(a); // 0 1 2 3 } for (let a of arr) { console.log(a); // a b c d } 上面代码表明，for...in循环读取键名，for...of循环读取键值。如果要通过for...of循环，获取数组的索引，可以借助数组实例的entries方法和keys方法，参见《数组的扩展》章节。 for...of循环调用遍历器接口，数组的遍历器接口只返回具有数字索引的属性。这一点跟for...in循环也不一样。 let arr = [3, 5, 7]; arr.foo = &#39;hello&#39;; for (let i in arr) { console.log(i); // &quot;0&quot;, &quot;1&quot;, &quot;2&quot;, &quot;foo&quot; } for (let i of arr) { console.log(i); // &quot;3&quot;, &quot;5&quot;, &quot;7&quot; } 上面代码中，for...of循环不会返回数组arr的foo属性。 Set和Map结构Set和Map结构也原生具有Iterator接口，可以直接使用for...of循环。 var engines = new Set([&quot;Gecko&quot;, &quot;Trident&quot;, &quot;Webkit&quot;, &quot;Webkit&quot;]); for (var e of engines) { console.log(e); } // Gecko // Trident // Webkit var es6 = new Map(); es6.set(&quot;edition&quot;, 6); es6.set(&quot;committee&quot;, &quot;TC39&quot;); es6.set(&quot;standard&quot;, &quot;ECMA-262&quot;); for (var [name, value] of es6) { console.log(name + &quot;: &quot; + value); } // edition: 6 // committee: TC39 // standard: ECMA-262 上面代码演示了如何遍历Set结构和Map结构。值得注意的地方有两个，首先，遍历的顺序是按照各个成员被添加进数据结构的顺序。其次，Set结构遍历时，返回的是一个值，而Map结构遍历时，返回的是一个数组，该数组的两个成员分别为当前Map成员的键名和键值。 let map = new Map().set(&#39;a&#39;, 1).set(&#39;b&#39;, 2); for (let pair of map) { console.log(pair); } // [&#39;a&#39;, 1] // [&#39;b&#39;, 2] for (let [key, value] of map) { console.log(key + &#39; : &#39; + value); } // a : 1 // b : 2 计算生成的数据结构有些数据结构是在现有数据结构的基础上，计算生成的。比如，ES6的数组、Set、Map都部署了以下三个方法，调用后都返回遍历器对象。 entries() 返回一个遍历器对象，用来遍历[键名, 键值]组成的数组。对于数组，键名就是索引值；对于Set，键名与键值相同。Map结构的iterator接口，默认就是调用entries方法。 keys() 返回一个遍历器对象，用来遍历所有的键名。 values() 返回一个遍历器对象，用来遍历所有的键值。 这三个方法调用后生成的遍历器对象，所遍历的都是计算生成的数据结构。 let arr = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; for (let pair of arr.entries()) { console.log(pair); } // [0, &#39;a&#39;] // [1, &#39;b&#39;] // [2, &#39;c&#39;] 类似数组的对象类似数组的对象包括好几类。下面是for...of循环用于字符串、DOM NodeList对象、arguments对象的例子。 // 字符串 let str = &quot;hello&quot;; for (let s of str) { console.log(s); // h e l l o } // DOM NodeList对象 let paras = document.querySelectorAll(&quot;p&quot;); for (let p of paras) { p.classList.add(&quot;test&quot;); } // arguments对象 function printArgs() { for (let x of arguments) { console.log(x); } } printArgs(&#39;a&#39;, &#39;b&#39;); // &#39;a&#39; // &#39;b&#39; 对于字符串来说，for...of循环还有一个特点，就是会正确识别32位UTF-16字符。 for (let x of &#39;a\\uD83D\\uDC0A&#39;) { console.log(x); } // &#39;a&#39; // &#39;\\uD83D\\uDC0A&#39; 并不是所有类似数组的对象都具有iterator接口，一个简便的解决方法，就是使用Array.from方法将其转为数组。 let arrayLike = { length: 2, 0: &#39;a&#39;, 1: &#39;b&#39; }; // 报错 for (let x of arrayLike) { console.log(x); } // 正确 for (let x of Array.from(arrayLike)) { console.log(x); } 对象对于普通的对象，for...of结构不能直接使用，会报错，必须部署了iterator接口后才能使用。但是，这样情况下，for...in循环依然可以用来遍历键名。 var es6 = { edition: 6, committee: &quot;TC39&quot;, standard: &quot;ECMA-262&quot; }; for (let e in es6) { console.log(e); } // edition // committee // standard for (let e of es6) { console.log(e); } // TypeError: es6 is not iterable 上面代码表示，对于普通的对象，for...in循环可以遍历键名，for...of循环会报错。 一种解决方法是，使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组。 for (var key of Object.keys(someObject)) { console.log(key + &quot;: &quot; + someObject[key]); } 在对象上部署iterator接口的代码，参见本章前面部分。一个方便的方法是将数组的Symbol.iterator属性，直接赋值给其他对象的Symbol.iterator属性。比如，想要让for...of环遍历jQuery对象，只要加上下面这一行就可以了。 jQuery.prototype[Symbol.iterator] = Array.prototype[Symbol.iterator]; 另一个方法是使用Generator函数将对象重新包装一下。 function* entries(obj) { for (let key of Object.keys(obj)) { yield [key, obj[key]]; } } for (let [key, value] of entries(obj)) { console.log(key, &quot;-&gt;&quot;, value); } // a -&gt; 1 // b -&gt; 2 // c -&gt; 3 与其他遍历语法的比较以数组为例，JavaScript提供多种遍历语法。最原始的写法就是for循环。 for (var index = 0; index &lt; myArray.length; index++) { console.log(myArray[index]); } 这种写法比较麻烦，因此数组提供内置的forEach方法。 myArray.forEach(function (value) { console.log(value); }); 这种写法的问题在于，无法中途跳出forEach循环，break命令或return命令都不能奏效。 for...in循环可以遍历数组的键名。 for (var index in myArray) { console.log(myArray[index]); } for…in循环有几个缺点。 数组的键名是数字，但是for…in循环是以字符串作为键名“0”、“1”、“2”等等。 for…in循环不仅遍历数字键名，还会遍历手动添加的其他键，甚至包括原型链上的键。 某些情况下，for…in循环会以任意顺序遍历键名。 总之，for...in循环主要是为遍历对象而设计的，不适用于遍历数组。 for...of循环相比上面几种做法，有一些显著的优点。 for (let value of myArray) { console.log(value); } 有着同for…in一样的简洁语法，但是没有for…in那些缺点。 不同用于forEach方法，它可以与break、continue和return配合使用。 提供了遍历所有数据结构的统一操作接口。 下面是一个使用break语句，跳出for...of循环的例子。 for (var n of fibonacci) { if (n &gt; 1000) break; console.log(n); } 上面的例子，会输出斐波纳契数列小于等于1000的项。如果当前项大于1000，就会使用break语句跳出for...of循环。 感谢阮一峰老师的原创，本分享仅供学习交流","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Iterator","slug":"Iterator","permalink":"https://microzz.com/tags/Iterator/"},{"name":"for","slug":"for","permalink":"https://microzz.com/tags/for/"}]},{"title":"Reflect","date":"2017-01-11T00:25:19.000Z","path":"2017/01/11/reflect/","text":"Reflect概述Reflect对象与Proxy对象一样，也是 ES6 为了操作对象而提供的新 API。Reflect对象的设计目的有这样几个。 （1） 将Object对象的一些明显属于语言内部的方法（比如Object.defineProperty），放到Reflect对象上。现阶段，某些方法同时在Object和Reflect对象上部署，未来的新方法将只部署在Reflect对象上。也就是说，从Reflect对象上可以拿到语言内部的方法。 （2） 修改某些Object方法的返回结果，让其变得更合理。比如，Object.defineProperty(obj, name, desc)在无法定义属性时，会抛出一个错误，而Reflect.defineProperty(obj, name, desc)则会返回false。 // 老写法 try { Object.defineProperty(target, property, attributes); // success } catch (e) { // failure } // 新写法 if (Reflect.defineProperty(target, property, attributes)) { // success } else { // failure } （3） 让Object操作都变成函数行为。某些Object操作是命令式，比如name in obj和delete obj[name]，而Reflect.has(obj, name)和Reflect.deleteProperty(obj, name)让它们变成了函数行为。 // 老写法 &#39;assign&#39; in Object // true // 新写法 Reflect.has(Object, &#39;assign&#39;) // true （4）Reflect对象的方法与Proxy对象的方法一一对应，只要是Proxy对象的方法，就能在Reflect对象上找到对应的方法。这就让Proxy对象可以方便地调用对应的Reflect方法，完成默认行为，作为修改行为的基础。也就是说，不管Proxy怎么修改默认行为，你总可以在Reflect上获取默认行为。 Proxy(target, { set: function(target, name, value, receiver) { var success = Reflect.set(target,name, value, receiver); if (success) { log(&#39;property &#39; + name + &#39; on &#39; + target + &#39; set to &#39; + value); } return success; } }); 上面代码中，Proxy方法拦截target对象的属性赋值行为。它采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，然后再部署额外的功能。 下面是另一个例子。 var loggedObj = new Proxy(obj, { get(target, name) { console.log(&#39;get&#39;, target, name); return Reflect.get(target, name); }, deleteProperty(target, name) { console.log(&#39;delete&#39; + name); return Reflect.deleteProperty(target, name); }, has(target, name) { console.log(&#39;has&#39; + name); return Reflect.has(target, name); } }); 上面代码中，每一个Proxy对象的拦截操作（get、delete、has），内部都调用对应的Reflect方法，保证原生行为能够正常执行。添加的工作，就是将每一个操作输出一行日志。 有了Reflect对象以后，很多操作会更易读。 // 老写法 Function.prototype.apply.call(Math.floor, undefined, [1.75]) // 1 // 新写法 Reflect.apply(Math.floor, undefined, [1.75]) // 1 静态方法Reflect对象一共有13个静态方法。 Reflect.apply(target,thisArg,args) Reflect.construct(target,args) Reflect.get(target,name,receiver) Reflect.set(target,name,value,receiver) Reflect.defineProperty(target,name,desc) Reflect.deleteProperty(target,name) Reflect.has(target,name) Reflect.ownKeys(target) Reflect.isExtensible(target) Reflect.preventExtensions(target) Reflect.getOwnPropertyDescriptor(target, name) Reflect.getPrototypeOf(target) Reflect.setPrototypeOf(target, prototype) 上面这些方法的作用，大部分与Object对象的同名方法的作用都是相同的，而且它与Proxy对象的方法是一一对应的。下面是对它们的解释。 Reflect.get(target, name, receiver)Reflect.get方法查找并返回target对象的name属性，如果没有该属性，则返回undefined。 var myObject = { foo: 1, bar: 2, get baz() { return this.foo + this.bar; }, } Reflect.get(myObject, &#39;foo&#39;) // 1 Reflect.get(myObject, &#39;bar&#39;) // 2 Reflect.get(myObject, &#39;baz&#39;) // 3 如果name属性部署了读取函数（getter），则读取函数的this绑定receiver。 var myObject = { foo: 1, bar: 2, get baz() { return this.foo + this.bar; }, }; var myReceiverObject = { foo: 4, bar: 4, }; Reflect.get(myObject, &#39;baz&#39;, myReceiverObject) // 8 如果第一个参数不是对象，Reflect.get方法会报错。 Reflect.get(1, &#39;foo&#39;) // 报错 Reflect.get(false, &#39;foo&#39;) // 报错 Reflect.set(target, name, value, receiver)Reflect.set方法设置target对象的name属性等于value。 var myObject = { foo: 1, set bar(value) { return this.foo = value; }, } myObject.foo // 1 Reflect.set(myObject, &#39;foo&#39;, 2); myObject.foo // 2 Reflect.set(myObject, &#39;bar&#39;, 3) myObject.foo // 3 如果name属性设置了赋值函数，则赋值函数的this绑定receiver。 var myObject = { foo: 4, set bar(value) { return this.foo = value; }, }; var myReceiverObject = { foo: 0, }; Reflect.set(myObject, &#39;bar&#39;, 1, myReceiverObject); myObject.foo // 4 myReceiverObject.foo // 1 如果第一个参数不是对象，Reflect.set会报错。 Reflect.set(1, &#39;foo&#39;, {}) // 报错 Reflect.set(false, &#39;foo&#39;, {}) // 报错 Reflect.has(obj, name)Reflect.has方法对应name in obj里面的in运算符。 var myObject = { foo: 1, }; // 旧写法 &#39;foo&#39; in myObject // true // 新写法 Reflect.has(myObject, &#39;foo&#39;) // true 如果第一个参数不是对象，Reflect.has和in运算符都会报错。 Reflect.deleteProperty(obj, name)Reflect.deleteProperty方法等同于delete obj[name]，用于删除对象的属性。 const myObj = { foo: &#39;bar&#39; }; // 旧写法 delete myObj.foo; // 新写法 Reflect.deleteProperty(myObj, &#39;foo&#39;); 该方法返回一个布尔值。如果删除成功，或者被删除的属性不存在，返回true；删除失败，被删除的属性依然存在，返回false。 Reflect.construct(target, args)Reflect.construct方法等同于new target(...args)，这提供了一种不使用new，来调用构造函数的方法。 function Greeting(name) { this.name = name; } // new 的写法 const instance = new Greeting(&#39;张三&#39;); // Reflect.construct 的写法 const instance = Reflect.construct(Greeting, &#39;张三&#39;); Reflect.getPrototypeOf(obj)Reflect.getPrototypeOf方法用于读取对象的__proto__属性，对应Object.getPrototypeOf(obj)。 const myObj = new FancyThing(); // 旧写法 Object.getPrototypeOf(myObj) === FancyThing.prototype; // 新写法 Reflect.getPrototypeOf(myObj) === FancyThing.prototype; Reflect.getPrototypeOf和Object.getPrototypeOf的一个区别是，如果第一个参数不是对象（包括null和undefined），Object.getPrototypeOf会将这个参数转为对象，然后再运行，而Reflect.getPrototypeOf会报错。 Object.getPrototypeOf(1) // undefined Reflect.getPrototypeOf(1) // 报错 Reflect.setPrototypeOf(obj, newProto)Reflect.setPrototypeOf方法用于设置对象的__proto__属性，对应Object.setPrototypeOf(obj, newProto)。 const myObj = new FancyThing(); // 旧写法 Object.setPrototypeOf(myObj, OtherThing.prototype); // 新写法 Reflect.setPrototypeOf(myObj, OtherThing.prototype); 如果第一个参数不是对象，Reflect.setPrototypeOf和Object.setPrototypeOf都会报错。 Object.setPrototypeOf(1) // 报错 Reflect.setPrototypeOf(1) // 报错 Reflect.apply(func, thisArg, args)Reflect.apply方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定函数。 一般来说，如果要绑定一个函数的this对象，可以这样写fn.apply(obj, args)，但是如果函数定义了自己的apply方法，就只能写成Function.prototype.apply.call(fn, obj, args)，采用Reflect对象可以简化这种操作。 const ages = [11, 33, 12, 54, 18, 96]; // 旧写法 const youngest = Math.min.apply(Math, ages); const oldest = Math.max.apply(Math, ages); const type = Object.prototype.toString.call(youngest); // 新写法 const youngest = Reflect.apply(Math.min, Math, ages); const oldest = Reflect.apply(Math.max, Math, ages); const type = Reflect.apply(Object.prototype.toString, youngest); Reflect.defineProperty(target, propertyKey, attributes)Reflect.defineProperty方法基本等同于Object.defineProperty，用来为对象定义属性。未来，后者会被逐渐废除，请从现在开始就使用Reflect.defineProperty代替它。 function MyDate() { /*…*/ } // 旧写法 Object.defineProperty(MyDate, &#39;now&#39;, { value: () =&gt; new Date.now() }); // 新写法 Reflect.defineProperty(MyDate, &#39;now&#39;, { value: () =&gt; new Date.now() }); 如果Reflect.defineProperty的第一个参数不是对象，就会抛出错误，比如Reflect.defineProperty(1, &#39;foo&#39;)。 Reflect.getOwnPropertyDescriptor(target, propertyKey)Reflect.getOwnPropertyDescriptor基本等同于Object.getOwnPropertyDescriptor，用于得到指定属性的描述对象，将来会替代掉后者。 var myObject = {}; Object.defineProperty(myObject, &#39;hidden&#39;, { value: true, enumerable: false, }); // 旧写法 var theDescriptor = Object.getOwnPropertyDescriptor(myObject, &#39;hidden&#39;); // 新写法 var theDescriptor = Reflect.getOwnPropertyDescriptor(myObject, &#39;hidden&#39;); Reflect.getOwnPropertyDescriptor和Object.getOwnPropertyDescriptor的一个区别是，如果第一个参数不是对象，Object.getOwnPropertyDescriptor(1, &#39;foo&#39;)不报错，返回undefined，而Reflect.getOwnPropertyDescriptor(1, &#39;foo&#39;)会抛出错误，表示参数非法。 Reflect.isExtensible (target)Reflect.isExtensible方法对应Object.isExtensible，返回一个布尔值，表示当前对象是否可扩展。 const myObject = {}; // 旧写法 Object.isExtensible(myObject) // true // 新写法 Reflect.isExtensible(myObject) // true 如果参数不是对象，Object.isExtensible会返回false，因为非对象本来就是不可扩展的，而Reflect.isExtensible会报错。 Object.isExtensible(1) // false Reflect.isExtensible(1) // 报错 Reflect.preventExtensions(target)Reflect.preventExtensions对应Object.preventExtensions方法，用于让一个对象变为不可扩展。它返回一个布尔值，表示是否操作成功。 var myObject = {}; // 旧写法 Object.isExtensible(myObject) // true // 新写法 Reflect.preventExtensions(myObject) // true 如果参数不是对象，Object.isExtensible在 ES5 环境报错，在 ES6 环境返回这个参数，而Reflect.preventExtensions会报错。 // ES5 Object.preventExtensions(1) // 报错 // ES6 Object.preventExtensions(1) // 1 // 新写法 Reflect.preventExtensions(1) // 报错 Reflect.ownKeys (target)Reflect.ownKeys方法用于返回对象的所有属性，基本等同于Object.getOwnPropertyNames与Object.getOwnPropertySymbols之和。 var myObject = { foo: 1, bar: 2, [Symbol.for(&#39;baz&#39;)]: 3, [Symbol.for(&#39;bing&#39;)]: 4, }; // 旧写法 Object.getOwnPropertyNames(myObject) // [&#39;foo&#39;, &#39;bar&#39;] Object.getOwnPropertySymbols(myObject) //[Symbol.for(&#39;baz&#39;), Symbol.for(&#39;bing&#39;)] // 新写法 Reflect.ownKeys(myObject) // [&#39;foo&#39;, &#39;bar&#39;, Symbol.for(&#39;baz&#39;), Symbol.for(&#39;bing&#39;)] 实例：使用 Proxy 实现观察者模式观察者模式（Observer mode）指的是函数自动观察数据对象，一旦对象有变化，函数就会自动执行。 const person = observable({ name: &#39;张三&#39;, age: 20 }); function print() { console.log(`${person.name}, ${person.age}`) } observe(print); person.name = &#39;李四&#39;; // 输出 // 李四, 20 上面代码中，数据对象person是观察目标，函数print是观察者。一旦数据对象发生变化，print就会自动执行。 下面，使用 Proxy 写一个观察者模式的最简单实现，即实现observable和observe这两个函数。思路是observable函数返回一个原始对象的 Proxy 代理，拦截赋值操作，触发充当观察者的各个函数。 const queuedObservers = new Set(); const observe = fn =&gt; queuedObservers.add(fn); const observable = obj =&gt; new Proxy(obj, {set}); function set(target, key, value, receiver) { const result = Reflect.set(target, key, value, receiver); queuedObservers.forEach(observer =&gt; observer()); return result; } 上面代码中，先定义了一个Set集合，所有观察者函数都放进这个集合。然后，observable函数返回原始对象的代理，拦截赋值操作。拦截函数set之中，会自动执行所有观察者。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Reflect","slug":"Reflect","permalink":"https://microzz.com/tags/Reflect/"}]},{"title":"Proxy","date":"2017-01-09T02:40:19.000Z","path":"2017/01/09/proxy/","text":"Proxy概述Proxy 用于修改某些操作的默认行为，等同于在语言层面做出修改，所以属于一种“元编程”（meta programming），即对编程语言进行编程。 Proxy 可以理解成，在目标对象之前架设一层“拦截”，外界对该对象的访问，都必须先通过这层拦截，因此提供了一种机制，可以对外界的访问进行过滤和改写。Proxy 这个词的原意是代理，用在这里表示由它来“代理”某些操作，可以译为“代理器”。 var obj = new Proxy({}, { get: function (target, key, receiver) { console.log(`getting ${key}!`); return Reflect.get(target, key, receiver); }, set: function (target, key, value, receiver) { console.log(`setting ${key}!`); return Reflect.set(target, key, value, receiver); } }); 上面代码对一个空对象架设了一层拦截，重定义了属性的读取（get）和设置（set）行为。这里暂时先不解释具体的语法，只看运行结果。对设置了拦截行为的对象obj，去读写它的属性，就会得到下面的结果。 obj.count = 1 // setting count! ++obj.count // getting count! // setting count! // 2 上面代码说明，Proxy 实际上重载（overload）了点运算符，即用自己的定义覆盖了语言的原始定义。 ES6 原生提供 Proxy 构造函数，用来生成 Proxy 实例。 var proxy = new Proxy(target, handler); Proxy 对象的所有用法，都是上面这种形式，不同的只是handler参数的写法。其中，new Proxy()表示生成一个Proxy实例，target参数表示所要拦截的目标对象，handler参数也是一个对象，用来定制拦截行为。 下面是另一个拦截读取属性行为的例子。 var proxy = new Proxy({}, { get: function(target, property) { return 35; } }); proxy.time // 35 proxy.name // 35 proxy.title // 35 上面代码中，作为构造函数，Proxy接受两个参数。第一个参数是所要代理的目标对象（上例是一个空对象），即如果没有Proxy的介入，操作原来要访问的就是这个对象；第二个参数是一个配置对象，对于每一个被代理的操作，需要提供一个对应的处理函数，该函数将拦截对应的操作。比如，上面代码中，配置对象有一个get方法，用来拦截对目标对象属性的访问请求。get方法的两个参数分别是目标对象和所要访问的属性。可以看到，由于拦截函数总是返回35，所以访问任何属性都得到35。 注意，要使得Proxy起作用，必须针对Proxy实例（上例是proxy对象）进行操作，而不是针对目标对象（上例是空对象）进行操作。 如果handler没有设置任何拦截，那就等同于直接通向原对象。 var target = {}; var handler = {}; var proxy = new Proxy(target, handler); proxy.a = &#39;b&#39;; target.a // &quot;b&quot; 上面代码中，handler是一个空对象，没有任何拦截效果，访问handler就等同于访问target。 一个技巧是将 Proxy 对象，设置到object.proxy属性，从而可以在object对象上调用。 var object = { proxy: new Proxy(target, handler) }; Proxy 实例也可以作为其他对象的原型对象。 var proxy = new Proxy({}, { get: function(target, property) { return 35; } }); let obj = Object.create(proxy); obj.time // 35 上面代码中，proxy对象是obj对象的原型，obj对象本身并没有time属性，所以根据原型链，会在proxy对象上读取该属性，导致被拦截。 同一个拦截器函数，可以设置拦截多个操作。 var handler = { get: function(target, name) { if (name === &#39;prototype&#39;) { return Object.prototype; } return &#39;Hello, &#39; + name; }, apply: function(target, thisBinding, args) { return args[0]; }, construct: function(target, args) { return {value: args[1]}; } }; var fproxy = new Proxy(function(x, y) { return x + y; }, handler); fproxy(1, 2) // 1 new fproxy(1,2) // {value: 2} fproxy.prototype === Object.prototype // true fproxy.foo // &quot;Hello, foo&quot; 下面是 Proxy 支持的拦截操作一览。 对于可以设置、但没有设置拦截的操作，则直接落在目标对象上，按照原先的方式产生结果。 （1）get(target, propKey, receiver) 拦截对象属性的读取，比如proxy.foo和proxy[&#39;foo&#39;]。 最后一个参数receiver是一个对象，可选，参见下面Reflect.get的部分。 （2）set(target, propKey, value, receiver) 拦截对象属性的设置，比如proxy.foo = v或proxy[&#39;foo&#39;] = v，返回一个布尔值。 （3）has(target, propKey) 拦截propKey in proxy的操作，返回一个布尔值。 （4）deleteProperty(target, propKey) 拦截delete proxy[propKey]的操作，返回一个布尔值。 （5）ownKeys(target) 拦截Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)，返回一个数组。该方法返回目标对象所有自身的属性的属性名，而Object.keys()的返回结果仅包括目标对象自身的可遍历属性。 （6）getOwnPropertyDescriptor(target, propKey) 拦截Object.getOwnPropertyDescriptor(proxy, propKey)，返回属性的描述对象。 （7）defineProperty(target, propKey, propDesc) 拦截Object.defineProperty(proxy, propKey, propDesc）、Object.defineProperties(proxy, propDescs)，返回一个布尔值。 （8）preventExtensions(target) 拦截Object.preventExtensions(proxy)，返回一个布尔值。 （9）getPrototypeOf(target) 拦截Object.getPrototypeOf(proxy)，返回一个对象。 （10）isExtensible(target) 拦截Object.isExtensible(proxy)，返回一个布尔值。 （11）setPrototypeOf(target, proto) 拦截Object.setPrototypeOf(proxy, proto)，返回一个布尔值。 如果目标对象是函数，那么还有两种额外操作可以拦截。 （12）apply(target, object, args) 拦截 Proxy 实例作为函数调用的操作，比如proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)。 （13）construct(target, args) 拦截 Proxy 实例作为构造函数调用的操作，比如new proxy(...args)。 Proxy 实例的方法下面是上面这些拦截方法的详细介绍。 get()get方法用于拦截某个属性的读取操作。上文已经有一个例子，下面是另一个拦截读取操作的例子。 var person = { name: &quot;张三&quot; }; var proxy = new Proxy(person, { get: function(target, property) { if (property in target) { return target[property]; } else { throw new ReferenceError(&quot;Property \\&quot;&quot; + property + &quot;\\&quot; does not exist.&quot;); } } }); proxy.name // &quot;张三&quot; proxy.age // 抛出一个错误 上面代码表示，如果访问目标对象不存在的属性，会抛出一个错误。如果没有这个拦截函数，访问不存在的属性，只会返回undefined。 get方法可以继承。 let proto = new Proxy({}, { get(target, propertyKey, receiver) { console.log(&#39;GET &#39;+propertyKey); return target[propertyKey]; } }); let obj = Object.create(proto); obj.xxx // &quot;GET xxx&quot; 上面代码中，拦截操作定义在Prototype对象上面，所以如果读取obj对象继承的属性时，拦截会生效。 下面的例子使用get拦截，实现数组读取负数的索引。 function createArray(...elements) { let handler = { get(target, propKey, receiver) { let index = Number(propKey); if (index &lt; 0) { propKey = String(target.length + index); } return Reflect.get(target, propKey, receiver); } }; let target = []; target.push(...elements); return new Proxy(target, handler); } let arr = createArray(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;); arr[-1] // c 上面代码中，数组的位置参数是-1，就会输出数组的倒数最后一个成员。 利用 Proxy，可以将读取属性的操作（get），转变为执行某个函数，从而实现属性的链式操作。 var pipe = (function () { return function (value) { var funcStack = []; var oproxy = new Proxy({} , { get : function (pipeObject, fnName) { if (fnName === &#39;get&#39;) { return funcStack.reduce(function (val, fn) { return fn(val); },value); } funcStack.push(window[fnName]); return oproxy; } }); return oproxy; } }()); var double = n =&gt; n * 2; var pow = n =&gt; n * n; var reverseInt = n =&gt; n.toString().split(&quot;&quot;).reverse().join(&quot;&quot;) | 0; pipe(3).double.pow.reverseInt.get; // 63 上面代码设置 Proxy 以后，达到了将函数名链式使用的效果。 下面的例子则是利用get拦截，实现一个生成各种DOM节点的通用函数dom。 const dom = new Proxy({}, { get(target, property) { return function(attrs = {}, ...children) { const el = document.createElement(property); for (let prop of Object.keys(attrs)) { el.setAttribute(prop, attrs[prop]); } for (let child of children) { if (typeof child === &#39;string&#39;) { child = document.createTextNode(child); } el.appendChild(child); } return el; } } }); const el = dom.div({}, &#39;Hello, my name is &#39;, dom.a({href: &#39;//example.com&#39;}, &#39;Mark&#39;), &#39;. I like:&#39;, dom.ul({}, dom.li({}, &#39;The web&#39;), dom.li({}, &#39;Food&#39;), dom.li({}, &#39;…actually that\\&#39;s it&#39;) ) ); document.body.appendChild(el); 如果一个属性不可配置（configurable）和不可写（writable），则该属性不能被代理，通过 Proxy 对象访问该属性会报错。 const target = Object.defineProperties({}, { foo: { value: 123, writable: false, configurable: false }, }); const handler = { get(target, propKey) { return &#39;abc&#39;; } }; const proxy = new Proxy(target, handler); proxy.foo // TypeError: Invariant check failed set()set方法用来拦截某个属性的赋值操作。 假定Person对象有一个age属性，该属性应该是一个不大于200的整数，那么可以使用Proxy保证age的属性值符合要求。 let validator = { set: function(obj, prop, value) { if (prop === &#39;age&#39;) { if (!Number.isInteger(value)) { throw new TypeError(&#39;The age is not an integer&#39;); } if (value &gt; 200) { throw new RangeError(&#39;The age seems invalid&#39;); } } // 对于age以外的属性，直接保存 obj[prop] = value; } }; let person = new Proxy({}, validator); person.age = 100; person.age // 100 person.age = &#39;young&#39; // 报错 person.age = 300 // 报错 上面代码中，由于设置了存值函数set，任何不符合要求的age属性赋值，都会抛出一个错误，这是数据验证的一种实现方法。利用set方法，还可以数据绑定，即每当对象发生变化时，会自动更新 DOM。 有时，我们会在对象上面设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用。结合get和set方法，就可以做到防止这些内部属性被外部读写。 var handler = { get (target, key) { invariant(key, &#39;get&#39;); return target[key]; }, set (target, key, value) { invariant(key, &#39;set&#39;); target[key] = value; return true; } }; function invariant (key, action) { if (key[0] === &#39;_&#39;) { throw new Error(`Invalid attempt to ${action} private &quot;${key}&quot; property`); } } var target = {}; var proxy = new Proxy(target, handler); proxy._prop // Error: Invalid attempt to get private &quot;_prop&quot; property proxy._prop = &#39;c&#39; // Error: Invalid attempt to set private &quot;_prop&quot; property 上面代码中，只要读写的属性名的第一个字符是下划线，一律抛错，从而达到禁止读写内部属性的目的。 注意，如果目标对象自身的某个属性，不可写也不可配置，那么set不得改变这个属性的值，只能返回同样的值，否则报错。 apply()apply方法拦截函数的调用、call和apply操作。 apply方法可以接受三个参数，分别是目标对象、目标对象的上下文对象（this）和目标对象的参数数组。 var handler = { apply (target, ctx, args) { return Reflect.apply(...arguments); } }; 下面是一个例子。 var target = function () { return &#39;I am the target&#39;; }; var handler = { apply: function () { return &#39;I am the proxy&#39;; } }; var p = new Proxy(target, handler); p() // &quot;I am the proxy&quot; 上面代码中，变量p是 Proxy 的实例，当它作为函数调用时（p()），就会被apply方法拦截，返回一个字符串。 下面是另外一个例子。 var twice = { apply (target, ctx, args) { return Reflect.apply(...arguments) * 2; } }; function sum (left, right) { return left + right; }; var proxy = new Proxy(sum, twice); proxy(1, 2) // 6 proxy.call(null, 5, 6) // 22 proxy.apply(null, [7, 8]) // 30 上面代码中，每当执行proxy函数（直接调用或call和apply调用），就会被apply方法拦截。 另外，直接调用Reflect.apply方法，也会被拦截。 Reflect.apply(proxy, null, [9, 10]) // 38 has()has方法用来拦截HasProperty操作，即判断对象是否具有某个属性时，这个方法会生效。典型的操作就是in运算符。 下面的例子使用has方法隐藏某些属性，不被in运算符发现。 var handler = { has (target, key) { if (key[0] === &#39;_&#39;) { return false; } return key in target; } }; var target = { _prop: &#39;foo&#39;, prop: &#39;foo&#39; }; var proxy = new Proxy(target, handler); &#39;_prop&#39; in proxy // false 上面代码中，如果原对象的属性名的第一个字符是下划线，proxy.has就会返回false，从而不会被in运算符发现。 如果原对象不可配置或者禁止扩展，这时has拦截会报错。 var obj = { a: 10 }; Object.preventExtensions(obj); var p = new Proxy(obj, { has: function(target, prop) { return false; } }); &#39;a&#39; in p // TypeError is thrown 上面代码中，obj对象禁止扩展，结果使用has拦截就会报错。也就是说，如果某个属性不可配置（或者目标对象不可扩展），则has方法就不得“隐藏”（即返回false）目标对象的该属性。 值得注意的是，has方法拦截的是HasProperty操作，而不是HasOwnProperty操作，即has方法不判断一个属性是对象自身的属性，还是继承的属性。 另外，虽然for...in循环也用到了in运算符，但是has拦截对for...in循环不生效。 let stu1 = {name: &#39;张三&#39;, score: 59}; let stu2 = {name: &#39;李四&#39;, score: 99}; let handler = { has(target, prop) { if (prop === &#39;score&#39; &amp;&amp; target[prop] &lt; 60) { console.log(`${target.name} 不及格`); return false; } return prop in target; } } let oproxy1 = new Proxy(stu1, handler); let oproxy2 = new Proxy(stu2, handler); &#39;score&#39; in oproxy1 // 张三 不及格 // false &#39;score&#39; in oproxy2 // true for (let a in oproxy1) { console.log(oproxy1[a]); } // 张三 // 59 for (let b in oproxy2) { console.log(oproxy2[b]); } // 李四 // 99 上面代码中，has拦截只对in循环生效，对for...in循环不生效，导致不符合要求的属性没有被排除在for...in循环之外。 construct()construct方法用于拦截new命令，下面是拦截对象的写法。 var handler = { construct (target, args, newTarget) { return new target(...args); } }; construct方法可以接受两个参数。 target: 目标对象 args：构建函数的参数对象 下面是一个例子。 var p = new Proxy(function () {}, { construct: function(target, args) { console.log(&#39;called: &#39; + args.join(&#39;, &#39;)); return { value: args[0] * 10 }; } }); (new p(1)).value // &quot;called: 1&quot; // 10 construct方法返回的必须是一个对象，否则会报错。 var p = new Proxy(function() {}, { construct: function(target, argumentsList) { return 1; } }); new p() // 报错 deleteProperty()deleteProperty方法用于拦截delete操作，如果这个方法抛出错误或者返回false，当前属性就无法被delete命令删除。 var handler = { deleteProperty (target, key) { invariant(key, &#39;delete&#39;); return true; } }; function invariant (key, action) { if (key[0] === &#39;_&#39;) { throw new Error(`Invalid attempt to ${action} private &quot;${key}&quot; property`); } } var target = { _prop: &#39;foo&#39; }; var proxy = new Proxy(target, handler); delete proxy._prop // Error: Invalid attempt to delete private &quot;_prop&quot; property 上面代码中，deleteProperty方法拦截了delete操作符，删除第一个字符为下划线的属性会报错。 注意，目标对象自身的不可配置（configurable）的属性，不能被deleteProperty方法删除，否则报错。 defineProperty()defineProperty方法拦截了Object.defineProperty操作。 var handler = { defineProperty (target, key, descriptor) { return false; } }; var target = {}; var proxy = new Proxy(target, handler); proxy.foo = &#39;bar&#39; // TypeError: proxy defineProperty handler returned false for property &#39;&quot;foo&quot;&#39; 上面代码中，defineProperty方法返回false，导致添加新属性会抛出错误。 注意，如果目标对象不可扩展（extensible），则defineProperty不能增加目标对象上不存在的属性，否则会报错。另外，如果目标对象的某个属性不可写（writable）或不可配置（configurable），则defineProperty方法不得改变这两个设置。 getOwnPropertyDescriptor()getOwnPropertyDescriptor方法拦截Object.getOwnPropertyDescriptor，返回一个属性描述对象或者undefined。 var handler = { getOwnPropertyDescriptor (target, key) { if (key[0] === &#39;_&#39;) { return; } return Object.getOwnPropertyDescriptor(target, key); } }; var target = { _foo: &#39;bar&#39;, baz: &#39;tar&#39; }; var proxy = new Proxy(target, handler); Object.getOwnPropertyDescriptor(proxy, &#39;wat&#39;) // undefined Object.getOwnPropertyDescriptor(proxy, &#39;_foo&#39;) // undefined Object.getOwnPropertyDescriptor(proxy, &#39;baz&#39;) // { value: &#39;tar&#39;, writable: true, enumerable: true, configurable: true } 上面代码中，handler.getOwnPropertyDescriptor方法对于第一个字符为下划线的属性名会返回undefined。 getPrototypeOf()getPrototypeOf方法主要用来拦截Object.getPrototypeOf()运算符，以及其他一些操作。 Object.prototype.__proto__ Object.prototype.isPrototypeOf() Object.getPrototypeOf() Reflect.getPrototypeOf() instanceof运算符 下面是一个例子。 var proto = {}; var p = new Proxy({}, { getPrototypeOf(target) { return proto; } }); Object.getPrototypeOf(p) === proto // true 上面代码中，getPrototypeOf方法拦截Object.getPrototypeOf()，返回proto对象。 注意，getPrototypeOf方法的返回值必须是对象或者null，否则报错。另外，如果目标对象不可扩展（extensible）， getPrototypeOf方法必须返回目标对象的原型对象。 isExtensible()isExtensible方法拦截Object.isExtensible操作。 var p = new Proxy({}, { isExtensible: function(target) { console.log(&quot;called&quot;); return true; } }); Object.isExtensible(p) // &quot;called&quot; // true 上面代码设置了isExtensible方法，在调用Object.isExtensible时会输出called。 注意，该方法只能返回布尔值，否则返回值会被自动转为布尔值。 这个方法有一个强限制，它的返回值必须与目标对象的isExtensible属性保持一致，否则就会抛出错误。 Object.isExtensible(proxy) === Object.isExtensible(target) 下面是一个例子。 var p = new Proxy({}, { isExtensible: function(target) { return false; } }); Object.isExtensible(p) // 报错 ownKeys()ownKeys方法用来拦截以下操作。 Object.getOwnPropertyNames() Object.getOwnPropertySymbols() Object.keys() 下面是拦截Object.keys()的例子。 let target = { a: 1, b: 2, c: 3 }; let handler = { ownKeys(target) { return [&#39;a&#39;]; } }; let proxy = new Proxy(target, handler); Object.keys(proxy) // [ &#39;a&#39; ] 上面代码拦截了对于target对象的Object.keys()操作，只返回a、b、c三个属性之中的a属性。 下面的例子是拦截第一个字符为下划线的属性名。 let target = { _bar: &#39;foo&#39;, _prop: &#39;bar&#39;, prop: &#39;baz&#39; }; let handler = { ownKeys (target) { return Reflect.ownKeys(target).filter(key =&gt; key[0] !== &#39;_&#39;); } }; let proxy = new Proxy(target, handler); for (let key of Object.keys(proxy)) { console.log(target[key]); } // &quot;baz&quot; 注意，使用Object.keys方法时，有三类属性会被ownKeys方法自动过滤，不会返回。 目标对象上不存在的属性 属性名为 Symbol 值 不可遍历（enumerable）的属性 let target = { a: 1, b: 2, c: 3, [Symbol.for(&#39;secret&#39;)]: &#39;4&#39;, }; Object.defineProperty(target, &#39;key&#39;, { enumerable: false, configurable: true, writable: true, value: &#39;static&#39; }); let handler = { ownKeys(target) { return [&#39;a&#39;, &#39;d&#39;, Symbol.for(&#39;secret&#39;), &#39;key&#39;]; } }; let proxy = new Proxy(target, handler); Object.keys(proxy) // [&#39;a&#39;] 上面代码中，ownKeys方法之中，显式返回不存在的属性（d）、Symbol 值（Symbol.for(&#39;secret&#39;)）、不可遍历的属性（key），结果都被自动过滤掉。 ownKeys方法还可以拦截Object.getOwnPropertyNames()。 var p = new Proxy({}, { ownKeys: function(target) { return [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; } }); Object.getOwnPropertyNames(p) // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39; ] ownKeys方法返回的数组成员，只能是字符串或 Symbol 值。如果有其他类型的值，或者返回的根本不是数组，就会报错。 var obj = {}; var p = new Proxy(obj, { ownKeys: function(target) { return [123, true, undefined, null, {}, []]; } }); Object.getOwnPropertyNames(p) // Uncaught TypeError: 123 is not a valid property name 上面代码中，ownKeys方法虽然返回一个数组，但是每一个数组成员都不是字符串或 Symbol 值，因此就报错了。 如果目标对象自身包含不可配置的属性，则该属性必须被ownKeys方法返回，否则报错。 var obj = {}; Object.defineProperty(obj, &#39;a&#39;, { configurable: false, enumerable: true, value: 10 } ); var p = new Proxy(obj, { ownKeys: function(target) { return [&#39;b&#39;]; } }); Object.getOwnPropertyNames(p) // Uncaught TypeError: &#39;ownKeys&#39; on proxy: trap result did not include &#39;a&#39; 上面代码中，obj对象的a属性是不可配置的，这时ownKeys方法返回的数组之中，必须包含a，否则会报错。 另外，如果目标对象是不可扩展的（non-extensition），这时ownKeys方法返回的数组之中，必须包含原对象的所有属性，且不能包含多余的属性，否则报错。 var obj = { a: 1 }; Object.preventExtensions(obj); var p = new Proxy(obj, { ownKeys: function(target) { return [&#39;a&#39;, &#39;b&#39;]; } }); Object.getOwnPropertyNames(p) // Uncaught TypeError: &#39;ownKeys&#39; on proxy: trap returned extra keys but proxy target is non-extensible 上面代码中，Obj对象是不可扩展的，这时ownKeys方法返回的数组之中，包含了obj对象的多余属性b，所以导致了报错。 preventExtensions()preventExtensions方法拦截Object.preventExtensions()。该方法必须返回一个布尔值，否则会被自动转为布尔值。 这个方法有一个限制，只有目标对象不可扩展时（即Object.isExtensible(proxy)为false），proxy.preventExtensions才能返回true，否则会报错。 var p = new Proxy({}, { preventExtensions: function(target) { return true; } }); Object.preventExtensions(p) // 报错 上面代码中，proxy.preventExtensions方法返回true，但这时Object.isExtensible(proxy)会返回true，因此报错。 为了防止出现这个问题，通常要在proxy.preventExtensions方法里面，调用一次Object.preventExtensions。 var p = new Proxy({}, { preventExtensions: function(target) { console.log(&#39;called&#39;); Object.preventExtensions(target); return true; } }); Object.preventExtensions(p) // &quot;called&quot; // true setPrototypeOf()setPrototypeOf方法主要用来拦截Object.setPrototypeOf方法。 下面是一个例子。 var handler = { setPrototypeOf (target, proto) { throw new Error(&#39;Changing the prototype is forbidden&#39;); } }; var proto = {}; var target = function () {}; var proxy = new Proxy(target, handler); proxy.setPrototypeOf(proxy, proto); // Error: Changing the prototype is forbidden 上面代码中，只要修改target的原型对象，就会报错。 注意，该方法只能返回布尔值，否则会被自动转为布尔值。另外，如果目标对象不可扩展（extensible），setPrototypeOf方法不得改变目标对象的原型。 Proxy.revocable()Proxy.revocable方法返回一个可取消的 Proxy 实例。 let target = {}; let handler = {}; let {proxy, revoke} = Proxy.revocable(target, handler); proxy.foo = 123; proxy.foo // 123 revoke(); proxy.foo // TypeError: Revoked Proxy.revocable方法返回一个对象，该对象的proxy属性是Proxy实例，revoke属性是一个函数，可以取消Proxy实例。上面代码中，当执行revoke函数之后，再访问Proxy实例，就会抛出一个错误。 Proxy.revocable的一个使用场景是，目标对象不允许直接访问，必须通过代理访问，一旦访问结束，就收回代理权，不允许再次访问。 this 问题虽然 Proxy 可以代理针对目标对象的访问，但它不是目标对象的透明代理，即不做任何拦截的情况下，也无法保证与目标对象的行为一致。主要原因就是在 Proxy 代理的情况下，目标对象内部的this关键字会指向 Proxy 代理。 const target = { m: function () { console.log(this === proxy); } }; const handler = {}; const proxy = new Proxy(target, handler); target.m() // false proxy.m() // true 上面代码中，一旦proxy代理target.m，后者内部的this就是指向proxy，而不是target。 下面是一个例子，由于this指向的变化，导致 Proxy 无法代理目标对象。 const _name = new WeakMap(); class Person { constructor(name) { _name.set(this, name); } get name() { return _name.get(this); } } const jane = new Person(&#39;Jane&#39;); jane.name // &#39;Jane&#39; const proxy = new Proxy(jane, {}); proxy.name // undefined 上面代码中，目标对象jane的name属性，实际保存在外部WeakMap对象_name上面，通过this键区分。由于通过proxy.name访问时，this指向proxy，导致无法取到值，所以返回undefined。 此外，有些原生对象的内部属性，只有通过正确的this才能拿到，所以 Proxy 也无法代理这些原生对象的属性。 const target = new Date(); const handler = {}; const proxy = new Proxy(target, handler); proxy.getDate(); // TypeError: this is not a Date object. 上面代码中，getDate方法只能在Date对象实例上面拿到，如果this不是Date对象实例就会报错。这时，this绑定原始对象，就可以解决这个问题。 const target = new Date(&#39;2015-01-01&#39;); const handler = { get(target, prop) { if (prop === &#39;getDate&#39;) { return target.getDate.bind(target); } return Reflect.get(target, prop); } }; const proxy = new Proxy(target, handler); proxy.getDate() // 1 实例：Web 服务的客户端Proxy 对象可以拦截目标对象的任意属性，这使得它很合适用来写 Web 服务的客户端。 const service = createWebService(&#39;http://example.com/data&#39;); service.employees().then(json =&gt; { const employees = JSON.parse(json); // ··· }); 上面代码新建了一个 Web 服务的接口，这个接口返回各种数据。Proxy 可以拦截这个对象的任意属性，所以不用为每一种数据写一个适配方法，只要写一个 Proxy 拦截就可以了。 function createWebService(baseUrl) { return new Proxy({}, { get(target, propKey, receiver) { return () =&gt; httpGet(baseUrl+&#39;/&#39; + propKey); } }); } 同理，Proxy 也可以用来实现数据库的 ORM 层。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Proxy","slug":"Proxy","permalink":"https://microzz.com/tags/Proxy/"}]},{"title":"Set和Map数据结构","date":"2017-01-05T03:40:19.000Z","path":"2017/01/05/set-map/","text":"Set和Map数据结构Set基本用法ES6提供了新的数据结构Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set本身是一个构造函数，用来生成Set数据结构。 var s = new Set(); [2, 3, 5, 4, 5, 2, 2].map(x =&gt; s.add(x)); for (let i of s) { console.log(i); } // 2 3 5 4 上面代码通过add方法向Set结构加入成员，结果表明Set结构不会添加重复的值。 Set函数可以接受一个数组（或类似数组的对象）作为参数，用来初始化。 // 例一 var set = new Set([1, 2, 3, 4, 4]); [...set] // [1, 2, 3, 4] // 例二 var items = new Set([1, 2, 3, 4, 5, 5, 5, 5]); items.size // 5 // 例三 function divs () { return [...document.querySelectorAll(&#39;div&#39;)]; } var set = new Set(divs()); set.size // 56 // 类似于 divs().forEach(div =&gt; set.add(div)); set.size // 56 上面代码中，例一和例二都是Set函数接受数组作为参数，例三是接受类似数组的对象作为参数。 上面代码中，也展示了一种去除数组重复成员的方法。 // 去除数组的重复成员 [...new Set(array)] 向Set加入值的时候，不会发生类型转换，所以5和&quot;5&quot;是两个不同的值。Set内部判断两个值是否不同，使用的算法叫做“Same-value equality”，它类似于精确相等运算符（===），主要的区别是NaN等于自身，而精确相等运算符认为NaN不等于自身。 let set = new Set(); let a = NaN; let b = NaN; set.add(a); set.add(b); set // Set {NaN} 上面代码向Set实例添加了两个NaN，但是只能加入一个。这表明，在Set内部，两个NaN是相等。 另外，两个对象总是不相等的。 let set = new Set(); set.add({}); set.size // 1 set.add({}); set.size // 2 上面代码表示，由于两个空对象不相等，所以它们被视为两个值。 Set实例的属性和方法Set结构的实例有以下属性。 Set.prototype.constructor：构造函数，默认就是Set函数。 Set.prototype.size：返回Set实例的成员总数。 Set实例的方法分为两大类：操作方法（用于操作数据）和遍历方法（用于遍历成员）。下面先介绍四个操作方法。 add(value)：添加某个值，返回Set结构本身。 delete(value)：删除某个值，返回一个布尔值，表示删除是否成功。 has(value)：返回一个布尔值，表示该值是否为Set的成员。 clear()：清除所有成员，没有返回值。 上面这些属性和方法的实例如下。 s.add(1).add(2).add(2); // 注意2被加入了两次 s.size // 2 s.has(1) // true s.has(2) // true s.has(3) // false s.delete(2); s.has(2) // false 下面是一个对比，看看在判断是否包括一个键上面，Object结构和Set结构的写法不同。 // 对象的写法 var properties = { &#39;width&#39;: 1, &#39;height&#39;: 1 }; if (properties[someName]) { // do something } // Set的写法 var properties = new Set(); properties.add(&#39;width&#39;); properties.add(&#39;height&#39;); if (properties.has(someName)) { // do something } Array.from方法可以将Set结构转为数组。 var items = new Set([1, 2, 3, 4, 5]); var array = Array.from(items); 这就提供了去除数组重复成员的另一种方法。 function dedupe(array) { return Array.from(new Set(array)); } dedupe([1, 1, 2, 3]) // [1, 2, 3] 遍历操作Set结构的实例有四个遍历方法，可以用于遍历成员。 keys()：返回键名的遍历器 values()：返回键值的遍历器 entries()：返回键值对的遍历器 forEach()：使用回调函数遍历每个成员 需要特别指出的是，Set的遍历顺序就是插入顺序。这个特性有时非常有用，比如使用Set保存一个回调函数列表，调用时就能保证按照添加顺序调用。 （1）keys()，values()，entries() keys方法、values方法、entries方法返回的都是遍历器对象（详见《Iterator 对象》一章）。由于 Set 结构没有键名，只有键值（或者说键名和键值是同一个值），所以keys方法和values方法的行为完全一致。 let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]); for (let item of set.keys()) { console.log(item); } // red // green // blue for (let item of set.values()) { console.log(item); } // red // green // blue for (let item of set.entries()) { console.log(item); } // [&quot;red&quot;, &quot;red&quot;] // [&quot;green&quot;, &quot;green&quot;] // [&quot;blue&quot;, &quot;blue&quot;] 上面代码中，entries方法返回的遍历器，同时包括键名和键值，所以每次输出一个数组，它的两个成员完全相等。 Set结构的实例默认可遍历，它的默认遍历器生成函数就是它的values方法。 Set.prototype[Symbol.iterator] === Set.prototype.values // true 这意味着，可以省略values方法，直接用for...of循环遍历Set。 let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]); for (let x of set) { console.log(x); } // red // green // blue （2）forEach() Set结构的实例的forEach方法，用于对每个成员执行某种操作，没有返回值。 let set = new Set([1, 2, 3]); set.forEach((value, key) =&gt; console.log(value * 2) ) // 2 // 4 // 6 上面代码说明，forEach方法的参数就是一个处理函数。该函数的参数依次为键值、键名、集合本身（上例省略了该参数）。另外，forEach方法还可以有第二个参数，表示绑定的this对象。 （3）遍历的应用 扩展运算符（...）内部使用for...of循环，所以也可以用于Set结构。 let set = new Set([&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;]); let arr = [...set]; // [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;] 扩展运算符和Set结构相结合，就可以去除数组的重复成员。 let arr = [3, 5, 2, 2, 5, 5]; let unique = [...new Set(arr)]; // [3, 5, 2] 而且，数组的map和filter方法也可以用于Set了。 let set = new Set([1, 2, 3]); set = new Set([...set].map(x =&gt; x * 2)); // 返回Set结构：{2, 4, 6} let set = new Set([1, 2, 3, 4, 5]); set = new Set([...set].filter(x =&gt; (x % 2) == 0)); // 返回Set结构：{2, 4} 因此使用Set可以很容易地实现并集（Union）、交集（Intersect）和差集（Difference）。 let a = new Set([1, 2, 3]); let b = new Set([4, 3, 2]); // 并集 let union = new Set([...a, ...b]); // Set {1, 2, 3, 4} // 交集 let intersect = new Set([...a].filter(x =&gt; b.has(x))); // set {2, 3} // 差集 let difference = new Set([...a].filter(x =&gt; !b.has(x))); // Set {1} 如果想在遍历操作中，同步改变原来的Set结构，目前没有直接的方法，但有两种变通方法。一种是利用原Set结构映射出一个新的结构，然后赋值给原来的Set结构；另一种是利用Array.from方法。 // 方法一 let set = new Set([1, 2, 3]); set = new Set([...set].map(val =&gt; val * 2)); // set的值是2, 4, 6 // 方法二 let set = new Set([1, 2, 3]); set = new Set(Array.from(set, val =&gt; val * 2)); // set的值是2, 4, 6 上面代码提供了两种方法，直接在遍历操作中改变原来的Set结构。 WeakSetWeakSet结构与Set类似，也是不重复的值的集合。但是，它与Set有两个区别。 首先，WeakSet的成员只能是对象，而不能是其他类型的值。 其次，WeakSet中的对象都是弱引用，即垃圾回收机制不考虑WeakSet对该对象的引用，也就是说，如果其他对象都不再引用该对象，那么垃圾回收机制会自动回收该对象所占用的内存，不考虑该对象还存在于WeakSet之中。这个特点意味着，无法引用WeakSet的成员，因此WeakSet是不可遍历的。 var ws = new WeakSet(); ws.add(1) // TypeError: Invalid value used in weak set ws.add(Symbol()) // TypeError: invalid value used in weak set 上面代码试图向WeakSet添加一个数值和Symbol值，结果报错，因为WeakSet只能放置对象。 WeakSet是一个构造函数，可以使用new命令，创建WeakSet数据结构。 var ws = new WeakSet(); 作为构造函数，WeakSet可以接受一个数组或类似数组的对象作为参数。（实际上，任何具有iterable接口的对象，都可以作为WeakSet的参数。）该数组的所有成员，都会自动成为WeakSet实例对象的成员。 var a = [[1,2], [3,4]]; var ws = new WeakSet(a); 上面代码中，a是一个数组，它有两个成员，也都是数组。将a作为WeakSet构造函数的参数，a的成员会自动成为WeakSet的成员。 注意，是a数组的成员成为WeakSet的成员，而不是a数组本身。这意味着，数组的成员只能是对象。 var b = [3, 4]; var ws = new WeakSet(b); // Uncaught TypeError: Invalid value used in weak set(…) 上面代码中，数组b的成员不是对象，加入WeaKSet就会报错。 WeakSet结构有以下三个方法。 WeakSet.prototype.add(value)：向WeakSet实例添加一个新成员。 WeakSet.prototype.delete(value)：清除WeakSet实例的指定成员。 WeakSet.prototype.has(value)：返回一个布尔值，表示某个值是否在WeakSet实例之中。 下面是一个例子。 var ws = new WeakSet(); var obj = {}; var foo = {}; ws.add(window); ws.add(obj); ws.has(window); // true ws.has(foo); // false ws.delete(window); ws.has(window); // false WeakSet没有size属性，没有办法遍历它的成员。 ws.size // undefined ws.forEach // undefined ws.forEach(function(item){ console.log(&#39;WeakSet has &#39; + item)}) // TypeError: undefined is not a function 上面代码试图获取size和forEach属性，结果都不能成功。 WeakSet不能遍历，是因为成员都是弱引用，随时可能消失，遍历机制无法保证成员的存在，很可能刚刚遍历结束，成员就取不到了。WeakSet的一个用处，是储存DOM节点，而不用担心这些节点从文档移除时，会引发内存泄漏。 下面是WeakSet的另一个例子。 const foos = new WeakSet() class Foo { constructor() { foos.add(this) } method () { if (!foos.has(this)) { throw new TypeError(&#39;Foo.prototype.method 只能在Foo的实例上调用！&#39;); } } } 上面代码保证了Foo的实例方法，只能在Foo的实例上调用。这里使用WeakSet的好处是，foos对实例的引用，不会被计入内存回收机制，所以删除实例的时候，不用考虑foos，也不会出现内存泄漏。 MapMap结构的目的和基本用法JavaScript的对象（Object），本质上是键值对的集合（Hash结构），但是传统上只能用字符串当作键。这给它的使用带来了很大的限制。 var data = {}; var element = document.getElementById(&#39;myDiv&#39;); data[element] = &#39;metadata&#39;; data[&#39;[object HTMLDivElement]&#39;] // &quot;metadata&quot; 上面代码原意是将一个DOM节点作为对象data的键，但是由于对象只接受字符串作为键名，所以element被自动转为字符串[object HTMLDivElement]。 为了解决这个问题，ES6提供了Map数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。也就是说，Object结构提供了“字符串—值”的对应，Map结构提供了“值—值”的对应，是一种更完善的Hash结构实现。如果你需要“键值对”的数据结构，Map比Object更合适。 var m = new Map(); var o = {p: &#39;Hello World&#39;}; m.set(o, &#39;content&#39;) m.get(o) // &quot;content&quot; m.has(o) // true m.delete(o) // true m.has(o) // false 上面代码使用set方法，将对象o当作m的一个键，然后又使用get方法读取这个键，接着使用delete方法删除了这个键。 作为构造函数，Map也可以接受一个数组作为参数。该数组的成员是一个个表示键值对的数组。 var map = new Map([ [&#39;name&#39;, &#39;张三&#39;], [&#39;title&#39;, &#39;Author&#39;] ]); map.size // 2 map.has(&#39;name&#39;) // true map.get(&#39;name&#39;) // &quot;张三&quot; map.has(&#39;title&#39;) // true map.get(&#39;title&#39;) // &quot;Author&quot; 上面代码在新建Map实例时，就指定了两个键name和title。 Map构造函数接受数组作为参数，实际上执行的是下面的算法。 var items = [ [&#39;name&#39;, &#39;张三&#39;], [&#39;title&#39;, &#39;Author&#39;] ]; var map = new Map(); items.forEach(([key, value]) =&gt; map.set(key, value)); 下面的例子中，字符串true和布尔值true是两个不同的键。 var m = new Map([ [true, &#39;foo&#39;], [&#39;true&#39;, &#39;bar&#39;] ]); m.get(true) // &#39;foo&#39; m.get(&#39;true&#39;) // &#39;bar&#39; 如果对同一个键多次赋值，后面的值将覆盖前面的值。 let map = new Map(); map .set(1, &#39;aaa&#39;) .set(1, &#39;bbb&#39;); map.get(1) // &quot;bbb&quot; 上面代码对键1连续赋值两次，后一次的值覆盖前一次的值。 如果读取一个未知的键，则返回undefined。 new Map().get(&#39;asfddfsasadf&#39;) // undefined 注意，只有对同一个对象的引用，Map结构才将其视为同一个键。这一点要非常小心。 var map = new Map(); map.set([&#39;a&#39;], 555); map.get([&#39;a&#39;]) // undefined 上面代码的set和get方法，表面是针对同一个键，但实际上这是两个值，内存地址是不一样的，因此get方法无法读取该键，返回undefined。 同理，同样的值的两个实例，在Map结构中被视为两个键。 var map = new Map(); var k1 = [&#39;a&#39;]; var k2 = [&#39;a&#39;]; map .set(k1, 111) .set(k2, 222); map.get(k1) // 111 map.get(k2) // 222 上面代码中，变量k1和k2的值是一样的，但是它们在Map结构中被视为两个键。 由上可知，Map的键实际上是跟内存地址绑定的，只要内存地址不一样，就视为两个键。这就解决了同名属性碰撞（clash）的问题，我们扩展别人的库的时候，如果使用对象作为键名，就不用担心自己的属性与原作者的属性同名。 如果Map的键是一个简单类型的值（数字、字符串、布尔值），则只要两个值严格相等，Map将其视为一个键，包括0和-0。另外，虽然NaN不严格相等于自身，但Map将其视为同一个键。 let map = new Map(); map.set(NaN, 123); map.get(NaN) // 123 map.set(-0, 123); map.get(+0) // 123 实例的属性和操作方法Map结构的实例有以下属性和操作方法。 （1）size属性 size属性返回Map结构的成员总数。 let map = new Map(); map.set(&#39;foo&#39;, true); map.set(&#39;bar&#39;, false); map.size // 2 （2）set(key, value) set方法设置key所对应的键值，然后返回整个Map结构。如果key已经有值，则键值会被更新，否则就新生成该键。 var m = new Map(); m.set(&quot;edition&quot;, 6) // 键是字符串 m.set(262, &quot;standard&quot;) // 键是数值 m.set(undefined, &quot;nah&quot;) // 键是undefined set方法返回的是Map本身，因此可以采用链式写法。 let map = new Map() .set(1, &#39;a&#39;) .set(2, &#39;b&#39;) .set(3, &#39;c&#39;); （3）get(key) get方法读取key对应的键值，如果找不到key，返回undefined。 var m = new Map(); var hello = function() {console.log(&quot;hello&quot;);} m.set(hello, &quot;Hello ES6!&quot;) // 键是函数 m.get(hello) // Hello ES6! （4）has(key) has方法返回一个布尔值，表示某个键是否在Map数据结构中。 var m = new Map(); m.set(&quot;edition&quot;, 6); m.set(262, &quot;standard&quot;); m.set(undefined, &quot;nah&quot;); m.has(&quot;edition&quot;) // true m.has(&quot;years&quot;) // false m.has(262) // true m.has(undefined) // true （5）delete(key) delete方法删除某个键，返回true。如果删除失败，返回false。 var m = new Map(); m.set(undefined, &quot;nah&quot;); m.has(undefined) // true m.delete(undefined) m.has(undefined) // false （6）clear() clear方法清除所有成员，没有返回值。 let map = new Map(); map.set(&#39;foo&#39;, true); map.set(&#39;bar&#39;, false); map.size // 2 map.clear() map.size // 0 遍历方法Map原生提供三个遍历器生成函数和一个遍历方法。 keys()：返回键名的遍历器。 values()：返回键值的遍历器。 entries()：返回所有成员的遍历器。 forEach()：遍历Map的所有成员。 需要特别注意的是，Map的遍历顺序就是插入顺序。 下面是使用实例。 let map = new Map([ [&#39;F&#39;, &#39;no&#39;], [&#39;T&#39;, &#39;yes&#39;], ]); for (let key of map.keys()) { console.log(key); } // &quot;F&quot; // &quot;T&quot; for (let value of map.values()) { console.log(value); } // &quot;no&quot; // &quot;yes&quot; for (let item of map.entries()) { console.log(item[0], item[1]); } // &quot;F&quot; &quot;no&quot; // &quot;T&quot; &quot;yes&quot; // 或者 for (let [key, value] of map.entries()) { console.log(key, value); } // 等同于使用map.entries() for (let [key, value] of map) { console.log(key, value); } 上面代码最后的那个例子，表示Map结构的默认遍历器接口（Symbol.iterator属性），就是entries方法。 map[Symbol.iterator] === map.entries // true Map结构转为数组结构，比较快速的方法是结合使用扩展运算符（...）。 let map = new Map([ [1, &#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;], ]); [...map.keys()] // [1, 2, 3] [...map.values()] // [&#39;one&#39;, &#39;two&#39;, &#39;three&#39;] [...map.entries()] // [[1,&#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;]] [...map] // [[1,&#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;]] 结合数组的map方法、filter方法，可以实现Map的遍历和过滤（Map本身没有map和filter方法）。 let map0 = new Map() .set(1, &#39;a&#39;) .set(2, &#39;b&#39;) .set(3, &#39;c&#39;); let map1 = new Map( [...map0].filter(([k, v]) =&gt; k &lt; 3) ); // 产生Map结构 {1 =&gt; &#39;a&#39;, 2 =&gt; &#39;b&#39;} let map2 = new Map( [...map0].map(([k, v]) =&gt; [k * 2, &#39;_&#39; + v]) ); // 产生Map结构 {2 =&gt; &#39;_a&#39;, 4 =&gt; &#39;_b&#39;, 6 =&gt; &#39;_c&#39;} 此外，Map还有一个forEach方法，与数组的forEach方法类似，也可以实现遍历。 map.forEach(function(value, key, map) { console.log(&quot;Key: %s, Value: %s&quot;, key, value); }); forEach方法还可以接受第二个参数，用来绑定this。 var reporter = { report: function(key, value) { console.log(&quot;Key: %s, Value: %s&quot;, key, value); } }; map.forEach(function(value, key, map) { this.report(key, value); }, reporter); 上面代码中，forEach方法的回调函数的this，就指向reporter。 与其他数据结构的互相转换（1）Map转为数组 前面已经提过，Map转为数组最方便的方法，就是使用扩展运算符（…）。 let myMap = new Map().set(true, 7).set({foo: 3}, [&#39;abc&#39;]); [...myMap] // [ [ true, 7 ], [ { foo: 3 }, [ &#39;abc&#39; ] ] ] （2）数组转为Map 将数组转入Map构造函数，就可以转为Map。 new Map([[true, 7], [{foo: 3}, [&#39;abc&#39;]]]) // Map {true =&gt; 7, Object {foo: 3} =&gt; [&#39;abc&#39;]} （3）Map转为对象 如果所有Map的键都是字符串，它可以转为对象。 function strMapToObj(strMap) { let obj = Object.create(null); for (let [k,v] of strMap) { obj[k] = v; } return obj; } let myMap = new Map().set(&#39;yes&#39;, true).set(&#39;no&#39;, false); strMapToObj(myMap) // { yes: true, no: false } （4）对象转为Map function objToStrMap(obj) { let strMap = new Map(); for (let k of Object.keys(obj)) { strMap.set(k, obj[k]); } return strMap; } objToStrMap({yes: true, no: false}) // [ [ &#39;yes&#39;, true ], [ &#39;no&#39;, false ] ] （5）Map转为JSON Map转为JSON要区分两种情况。一种情况是，Map的键名都是字符串，这时可以选择转为对象JSON。 function strMapToJson(strMap) { return JSON.stringify(strMapToObj(strMap)); } let myMap = new Map().set(&#39;yes&#39;, true).set(&#39;no&#39;, false); strMapToJson(myMap) // &#39;{&quot;yes&quot;:true,&quot;no&quot;:false}&#39; 另一种情况是，Map的键名有非字符串，这时可以选择转为数组JSON。 function mapToArrayJson(map) { return JSON.stringify([...map]); } let myMap = new Map().set(true, 7).set({foo: 3}, [&#39;abc&#39;]); mapToArrayJson(myMap) // &#39;[[true,7],[{&quot;foo&quot;:3},[&quot;abc&quot;]]]&#39; （6）JSON转为Map JSON转为Map，正常情况下，所有键名都是字符串。 function jsonToStrMap(jsonStr) { return objToStrMap(JSON.parse(jsonStr)); } jsonToStrMap(&#39;{&quot;yes&quot;:true,&quot;no&quot;:false}&#39;) // Map {&#39;yes&#39; =&gt; true, &#39;no&#39; =&gt; false} 但是，有一种特殊情况，整个JSON就是一个数组，且每个数组成员本身，又是一个有两个成员的数组。这时，它可以一一对应地转为Map。这往往是数组转为JSON的逆操作。 function jsonToMap(jsonStr) { return new Map(JSON.parse(jsonStr)); } jsonToMap(&#39;[[true,7],[{&quot;foo&quot;:3},[&quot;abc&quot;]]]&#39;) // Map {true =&gt; 7, Object {foo: 3} =&gt; [&#39;abc&#39;]} WeakMapWeakMap结构与Map结构基本类似，唯一的区别是它只接受对象作为键名（null除外），不接受其他类型的值作为键名，而且键名所指向的对象，不计入垃圾回收机制。 var map = new WeakMap() map.set(1, 2) // TypeError: 1 is not an object! map.set(Symbol(), 2) // TypeError: Invalid value used as weak map key 上面代码中，如果将1和Symbol作为WeakMap的键名，都会报错。 WeakMap的设计目的在于，键名是对象的弱引用（垃圾回收机制不将该引用考虑在内），所以其所对应的对象可能会被自动回收。当对象被回收后，WeakMap自动移除对应的键值对。典型应用是，一个对应DOM元素的WeakMap结构，当某个DOM元素被清除，其所对应的WeakMap记录就会自动被移除。基本上，WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。 下面是WeakMap结构的一个例子，可以看到用法上与Map几乎一样。 var wm = new WeakMap(); var element = document.querySelector(&quot;.element&quot;); wm.set(element, &quot;Original&quot;); wm.get(element) // &quot;Original&quot; element.parentNode.removeChild(element); element = null; wm.get(element) // undefined 上面代码中，变量wm是一个WeakMap实例，我们将一个DOM节点element作为键名，然后销毁这个节点，element对应的键就自动消失了，再引用这个键名就返回undefined。 WeakMap与Map在API上的区别主要是两个，一是没有遍历操作（即没有key()、values()和entries()方法），也没有size属性；二是无法清空，即不支持clear方法。这与WeakMap的键不被计入引用、被垃圾回收机制忽略有关。因此，WeakMap只有四个方法可用：get()、set()、has()、delete()。 var wm = new WeakMap(); wm.size // undefined wm.forEach // undefined 前文说过，WeakMap应用的典型场合就是DOM节点作为键名。下面是一个例子。 let myElement = document.getElementById(&#39;logo&#39;); let myWeakmap = new WeakMap(); myWeakmap.set(myElement, {timesClicked: 0}); myElement.addEventListener(&#39;click&#39;, function() { let logoData = myWeakmap.get(myElement); logoData.timesClicked++; }, false); 上面代码中，myElement是一个 DOM 节点，每当发生click事件，就更新一下状态。我们将这个状态作为键值放在 WeakMap 里，对应的键名就是myElement。一旦这个 DOM 节点删除，该状态就会自动消失，不存在内存泄漏风险。 WeakMap 的另一个用处是部署私有属性。 let _counter = new WeakMap(); let _action = new WeakMap(); class Countdown { constructor(counter, action) { _counter.set(this, counter); _action.set(this, action); } dec() { let counter = _counter.get(this); if (counter &lt; 1) return; counter--; _counter.set(this, counter); if (counter === 0) { _action.get(this)(); } } } let c = new Countdown(2, () =&gt; console.log(&#39;DONE&#39;)); c.dec() c.dec() // DONE 上面代码中，Countdown类的两个内部属性_counter和_action，是实例的弱引用，所以如果删除实例，它们也就随之消失，不会造成内存泄漏。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Set","slug":"Set","permalink":"https://microzz.com/tags/Set/"},{"name":"Map","slug":"Map","permalink":"https://microzz.com/tags/Map/"}]},{"title":"Symbol","date":"2017-01-01T05:43:19.000Z","path":"2017/01/01/symbol/","text":"Symbol概述ES5的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是ES6引入Symbol的原因。 ES6引入了一种新的原始数据类型Symbol，表示独一无二的值。它是JavaScript语言的第七种数据类型，前六种是：Undefined、Null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Symbol值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的Symbol类型。凡是属性名属于Symbol类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 let s = Symbol(); typeof s // &quot;symbol&quot; 上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是Symbol数据类型，而不是字符串之类的其他类型。 注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的Symbol是一个原始类型的值，不是对象。也就是说，由于Symbol值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。 Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 var s1 = Symbol(&#39;foo&#39;); var s2 = Symbol(&#39;bar&#39;); s1 // Symbol(foo) s2 // Symbol(bar) s1.toString() // &quot;Symbol(foo)&quot; s2.toString() // &quot;Symbol(bar)&quot; 上面代码中，s1和s2是两个Symbol值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。 const obj = { toString() { return &#39;abc&#39;; } }; const sym = Symbol(obj); sym // Symbol(abc) 注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。 // 没有参数的情况 var s1 = Symbol(); var s2 = Symbol(); s1 === s2 // false // 有参数的情况 var s1 = Symbol(&#39;foo&#39;); var s2 = Symbol(&#39;foo&#39;); s1 === s2 // false 上面代码中，s1和s2都是Symbol函数的返回值，而且参数相同，但是它们是不相等的。 Symbol值不能与其他类型的值进行运算，会报错。 var sym = Symbol(&#39;My symbol&#39;); &quot;your symbol is &quot; + sym // TypeError: can&#39;t convert symbol to string `your symbol is ${sym}` // TypeError: can&#39;t convert symbol to string 但是，Symbol值可以显式转为字符串。 var sym = Symbol(&#39;My symbol&#39;); String(sym) // &#39;Symbol(My symbol)&#39; sym.toString() // &#39;Symbol(My symbol)&#39; 另外，Symbol值也可以转为布尔值，但是不能转为数值。 var sym = Symbol(); Boolean(sym) // true !sym // false if (sym) { // ... } Number(sym) // TypeError sym + 2 // TypeError 作为属性名的Symbol由于每一个Symbol值都是不相等的，这意味着Symbol值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 var mySymbol = Symbol(); // 第一种写法 var a = {}; a[mySymbol] = &#39;Hello!&#39;; // 第二种写法 var a = { [mySymbol]: &#39;Hello!&#39; }; // 第三种写法 var a = {}; Object.defineProperty(a, mySymbol, { value: &#39;Hello!&#39; }); // 以上写法都得到同样结果 a[mySymbol] // &quot;Hello!&quot; 上面代码通过方括号结构和Object.defineProperty，将对象的属性名指定为一个Symbol值。 注意，Symbol值作为对象属性名时，不能用点运算符。 var mySymbol = Symbol(); var a = {}; a.mySymbol = &#39;Hello!&#39;; a[mySymbol] // undefined a[&#39;mySymbol&#39;] // &quot;Hello!&quot; 上面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个Symbol值。 同理，在对象的内部，使用Symbol值定义属性时，Symbol值必须放在方括号之中。 let s = Symbol(); let obj = { [s]: function (arg) { ... } }; obj[s](123); 上面代码中，如果s不放在方括号中，该属性的键名就是字符串s，而不是s所代表的那个Symbol值。 采用增强的对象写法，上面代码的obj对象可以写得更简洁一些。 let obj = { [s](arg) { ... } }; Symbol类型还可以用于定义一组常量，保证这组常量的值都是不相等的。 log.levels = { DEBUG: Symbol(&#39;debug&#39;), INFO: Symbol(&#39;info&#39;), WARN: Symbol(&#39;warn&#39;) }; log(log.levels.DEBUG, &#39;debug message&#39;); log(log.levels.INFO, &#39;info message&#39;); 下面是另外一个例子。 const COLOR_RED = Symbol(); const COLOR_GREEN = Symbol(); function getComplement(color) { switch (color) { case COLOR_RED: return COLOR_GREEN; case COLOR_GREEN: return COLOR_RED; default: throw new Error(&#39;Undefined color&#39;); } } 常量使用Symbol值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的switch语句会按设计的方式工作。 还有一点需要注意，Symbol值作为属性名时，该属性还是公开属性，不是私有属性。 实例：消除魔术字符串魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，该由含义清晰的变量代替。 function getArea(shape, options) { var area = 0; switch (shape) { case &#39;Triangle&#39;: // 魔术字符串 area = .5 * options.width * options.height; break; /* ... more code ... */ } return area; } getArea(&#39;Triangle&#39;, { width: 100, height: 100 }); // 魔术字符串 上面代码中，字符串“Triangle”就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。 常用的消除魔术字符串的方法，就是把它写成一个变量。 var shapeType = { triangle: &#39;Triangle&#39; }; function getArea(shape, options) { var area = 0; switch (shape) { case shapeType.triangle: area = .5 * options.width * options.height; break; } return area; } getArea(shapeType.triangle, { width: 100, height: 100 }); 上面代码中，我们把“Triangle”写成shapeType对象的triangle属性，这样就消除了强耦合。 如果仔细分析，可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用Symbol值。 const shapeType = { triangle: Symbol() }; 上面代码中，除了将shapeType.triangle的值设为一个Symbol，其他地方都不用修改。 属性名的遍历Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。 Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 var obj = {}; var a = Symbol(&#39;a&#39;); var b = Symbol(&#39;b&#39;); obj[a] = &#39;Hello&#39;; obj[b] = &#39;World&#39;; var objectSymbols = Object.getOwnPropertySymbols(obj); objectSymbols // [Symbol(a), Symbol(b)] 下面是另一个例子，Object.getOwnPropertySymbols方法与for...in循环、Object.getOwnPropertyNames方法进行对比的例子。 var obj = {}; var foo = Symbol(&quot;foo&quot;); Object.defineProperty(obj, foo, { value: &quot;foobar&quot;, }); for (var i in obj) { console.log(i); // 无输出 } Object.getOwnPropertyNames(obj) // [] Object.getOwnPropertySymbols(obj) // [Symbol(foo)] 上面代码中，使用Object.getOwnPropertyNames方法得不到Symbol属性名，需要使用Object.getOwnPropertySymbols方法。 另一个新的API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 let obj = { [Symbol(&#39;my_key&#39;)]: 1, enum: 2, nonEnum: 3 }; Reflect.ownKeys(obj) // [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)] 由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。 var size = Symbol(&#39;size&#39;); class Collection { constructor() { this[size] = 0; } add(item) { this[this[size]] = item; this[size]++; } static sizeOf(instance) { return instance[size]; } } var x = new Collection(); Collection.sizeOf(x) // 0 x.add(&#39;foo&#39;); Collection.sizeOf(x) // 1 Object.keys(x) // [&#39;0&#39;] Object.getOwnPropertyNames(x) // [&#39;0&#39;] Object.getOwnPropertySymbols(x) // [Symbol(size)] 上面代码中，对象x的size属性是一个 Symbol 值，所以Object.keys(x)、Object.getOwnPropertyNames(x)都无法获取它。这就造成了一种非私有的内部方法的效果。 Symbol.for()，Symbol.keyFor()有时，我们希望重新使用同一个Symbol值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，就返回这个Symbol值，否则就新建并返回一个以该字符串为名称的Symbol值。 var s1 = Symbol.for(&#39;foo&#39;); var s2 = Symbol.for(&#39;foo&#39;); s1 === s2 // true 上面代码中，s1和s2都是 Symbol 值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。 Symbol.for()与Symbol()这两种写法，都会生成新的Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(&quot;cat&quot;)30次，每次都会返回同一个 Symbol 值，但是调用Symbol(&quot;cat&quot;)30次，会返回30个不同的Symbol值。 Symbol.for(&quot;bar&quot;) === Symbol.for(&quot;bar&quot;) // true Symbol(&quot;bar&quot;) === Symbol(&quot;bar&quot;) // false 上面代码中，由于Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。 Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。 var s1 = Symbol.for(&quot;foo&quot;); Symbol.keyFor(s1) // &quot;foo&quot; var s2 = Symbol(&quot;foo&quot;); Symbol.keyFor(s2) // undefined 上面代码中，变量s2属于未登记的Symbol值，所以返回undefined。 需要注意的是，Symbol.for为Symbol值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。 iframe = document.createElement(&#39;iframe&#39;); iframe.src = String(window.location); document.body.appendChild(iframe); iframe.contentWindow.Symbol.for(&#39;foo&#39;) === Symbol.for(&#39;foo&#39;) // true 上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。 实例：模块的 Singleton 模式Singleton模式指的是调用一个类，任何时候返回的都是同一个实例。 对于Node来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？ 很容易想到，可以把实例放到顶层对象global。 // mod.js function A() { this.foo = &#39;hello&#39;; } if (!global._foo) { global._foo = new A(); } module.exports = global._foo; 然后，加载上面的mod.js。 var a = require(&#39;./mod.js&#39;); console.log(a.foo); 上面代码中，变量a任何时候加载的都是A的同一个实例。 但是，这里有一个问题，全局变量global._foo是可写的，任何文件都可以修改。 var a = require(&#39;./mod.js&#39;); global._foo = 123; 上面的代码，会使得别的脚本加载mod.js都失真。 为了防止这种情况出现，我们就可以使用Symbol。 // mod.js const FOO_KEY = Symbol.for(&#39;foo&#39;); function A() { this.foo = &#39;hello&#39;; } if (!global[FOO_KEY]) { global[FOO_KEY] = new A(); } module.exports = global[FOO_KEY]; 上面代码中，可以保证global[FOO_KEY]不会被无意间覆盖，但还是可以被改写。 var a = require(&#39;./mod.js&#39;); global[Symbol.for(&#39;foo&#39;)] = 123; 如果键名使用Symbol方法生成，那么外部将无法引用这个值，当然也就无法改写。 // mod.js const FOO_KEY = Symbol(&#39;foo&#39;); // 后面代码相同 …… 上面代码将导致其他脚本都无法引用FOO_KEY。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的FOO_KEY都是不一样的。虽然Node会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是完全可靠。 内置的Symbol值除了定义自己使用的Symbol值以外，ES6还提供了11个内置的Symbol值，指向语言内部使用的方法。 Symbol.hasInstance对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。 class MyClass { [Symbol.hasInstance](foo) { return foo instanceof Array; } } [1, 2, 3] instanceof new MyClass() // true 上面代码中，MyClass是一个类，new MyClass()会返回一个实例。该实例的Symbol.hasInstance方法，会在进行instanceof运算时自动调用，判断左侧的运算子是否为Array的实例。 下面是另一个例子。 class Even { static [Symbol.hasInstance](obj) { return Number(obj) % 2 === 0; } } 1 instanceof Even // false 2 instanceof Even // true 12345 instanceof Even // false Symbol.isConcatSpreadable对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象使用Array.prototype.concat()时，是否可以展开。 let arr1 = [&#39;c&#39;, &#39;d&#39;]; [&#39;a&#39;, &#39;b&#39;].concat(arr1, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;] arr1[Symbol.isConcatSpreadable] // undefined let arr2 = [&#39;c&#39;, &#39;d&#39;]; arr2[Symbol.isConcatSpreadable] = false; [&#39;a&#39;, &#39;b&#39;].concat(arr2, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, [&#39;c&#39;,&#39;d&#39;], &#39;e&#39;] 上面代码说明，数组的默认行为是可以展开。Symbol.isConcatSpreadable属性等于true或undefined，都有这个效果。 类似数组的对象也可以展开，但它的Symbol.isConcatSpreadable属性默认为false，必须手动打开。 let obj = {length: 2, 0: &#39;c&#39;, 1: &#39;d&#39;}; [&#39;a&#39;, &#39;b&#39;].concat(obj, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, obj, &#39;e&#39;] obj[Symbol.isConcatSpreadable] = true; [&#39;a&#39;, &#39;b&#39;].concat(obj, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;] 对于一个类来说，Symbol.isConcatSpreadable属性必须写成实例的属性。 class A1 extends Array { constructor(args) { super(args); this[Symbol.isConcatSpreadable] = true; } } class A2 extends Array { constructor(args) { super(args); this[Symbol.isConcatSpreadable] = false; } } let a1 = new A1(); a1[0] = 3; a1[1] = 4; let a2 = new A2(); a2[0] = 5; a2[1] = 6; [1, 2].concat(a1).concat(a2) // [1, 2, 3, 4, [5, 6]] 上面代码中，类A1是可展开的，类A2是不可展开的，所以使用concat时有不一样的结果。 Symbol.species对象的Symbol.species属性，指向当前对象的构造函数。创造实例时，默认会调用这个方法，即使用这个属性返回的函数当作构造函数，来创造新的实例对象。 class MyArray extends Array { // 覆盖父类 Array 的构造函数 static get [Symbol.species]() { return Array; } } 上面代码中，子类MyArray继承了父类Array。创建MyArray的实例对象时，本来会调用它自己的构造函数（本例中被省略了），但是由于定义了Symbol.species属性，所以会使用这个属性返回的的函数，创建MyArray的实例。 这个例子也说明，定义Symbol.species属性要采用get读取器。默认的Symbol.species属性等同于下面的写法。 static get [Symbol.species]() { return this; } 下面是一个例子。 class MyArray extends Array { static get [Symbol.species]() { return Array; } } var a = new MyArray(1,2,3); var mapped = a.map(x =&gt; x * x); mapped instanceof MyArray // false mapped instanceof Array // true 上面代码中，由于构造函数被替换成了Array。所以，mapped对象不是MyArray的实例，而是Array的实例。 Symbol.match对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。 String.prototype.match(regexp) // 等同于 regexp[Symbol.match](this) class MyMatcher { [Symbol.match](string) { return &#39;hello world&#39;.indexOf(string); } } &#39;e&#39;.match(new MyMatcher()) // 1 Symbol.replace对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。 String.prototype.replace(searchValue, replaceValue) // 等同于 searchValue[Symbol.replace](this, replaceValue) 下面是一个例子。 const x = {}; x[Symbol.replace] = (...s) =&gt; console.log(s); &#39;Hello&#39;.replace(x, &#39;World&#39;) // [&quot;Hello&quot;, &quot;World&quot;] Symbol.replace方法会收到两个参数，第一个参数是replace方法正在作用的对象，上面例子是Hello，第二个参数是替换后的值，上面例子是World。 Symbol.search对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。 String.prototype.search(regexp) // 等同于 regexp[Symbol.search](this) class MySearch { constructor(value) { this.value = value; } [Symbol.search](string) { return string.indexOf(this.value); } } &#39;foobar&#39;.search(new MySearch(&#39;foo&#39;)) // 0 Symbol.split对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。 String.prototype.split(separator, limit) // 等同于 separator[Symbol.split](this, limit) 下面是一个例子。 class MySplitter { constructor(value) { this.value = value; } [Symbol.split](string) { var index = string.indexOf(this.value); if (index === -1) { return string; } return [ string.substr(0, index), string.substr(index + this.value.length) ]; } } &#39;foobar&#39;.split(new MySplitter(&#39;foo&#39;)) // [&#39;&#39;, &#39;bar&#39;] &#39;foobar&#39;.split(new MySplitter(&#39;bar&#39;)) // [&#39;foo&#39;, &#39;&#39;] &#39;foobar&#39;.split(new MySplitter(&#39;baz&#39;)) // &#39;foobar&#39; 上面方法使用Symbol.split方法，重新定义了字符串对象的split方法的行为， Symbol.iterator对象的Symbol.iterator属性，指向该对象的默认遍历器方法。 var myIterable = {}; myIterable[Symbol.iterator] = function* () { yield 1; yield 2; yield 3; }; [...myIterable] // [1, 2, 3] 对象进行for...of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器，详细介绍参见《Iterator和for…of循环》一章。 class Collection { *[Symbol.iterator]() { let i = 0; while(this[i] !== undefined) { yield this[i]; ++i; } } } let myCollection = new Collection(); myCollection[0] = 1; myCollection[1] = 2; for(let value of myCollection) { console.log(value); } // 1 // 2 Symbol.toPrimitive对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。 Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。 Number：该场合需要转成数值 String：该场合需要转成字符串 Default：该场合可以转成数值，也可以转成字符串 let obj = { [Symbol.toPrimitive](hint) { switch (hint) { case &#39;number&#39;: return 123; case &#39;string&#39;: return &#39;str&#39;; case &#39;default&#39;: return &#39;default&#39;; default: throw new Error(); } } }; 2 * obj // 246 3 + obj // &#39;3default&#39; obj == &#39;default&#39; // true String(obj) // &#39;str&#39; Symbol.toStringTag对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。 // 例一 ({[Symbol.toStringTag]: &#39;Foo&#39;}.toString()) // &quot;[object Foo]&quot; // 例二 class Collection { get [Symbol.toStringTag]() { return &#39;xxx&#39;; } } var x = new Collection(); Object.prototype.toString.call(x) // &quot;[object xxx]&quot; ES6新增内置对象的Symbol.toStringTag属性值如下。 JSON[Symbol.toStringTag]：’JSON’ Math[Symbol.toStringTag]：’Math’ Module对象M[Symbol.toStringTag]：’Module’ ArrayBuffer.prototype[Symbol.toStringTag]：’ArrayBuffer’ DataView.prototype[Symbol.toStringTag]：’DataView’ Map.prototype[Symbol.toStringTag]：’Map’ Promise.prototype[Symbol.toStringTag]：’Promise’ Set.prototype[Symbol.toStringTag]：’Set’ %TypedArray%.prototype[Symbol.toStringTag]：’Uint8Array’等 WeakMap.prototype[Symbol.toStringTag]：’WeakMap’ WeakSet.prototype[Symbol.toStringTag]：’WeakSet’ %MapIteratorPrototype%[Symbol.toStringTag]：’Map Iterator’ %SetIteratorPrototype%[Symbol.toStringTag]：’Set Iterator’ %StringIteratorPrototype%[Symbol.toStringTag]：’String Iterator’ Symbol.prototype[Symbol.toStringTag]：’Symbol’ Generator.prototype[Symbol.toStringTag]：’Generator’ GeneratorFunction.prototype[Symbol.toStringTag]：’GeneratorFunction’ Symbol.unscopables对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。 Array.prototype[Symbol.unscopables] // { // copyWithin: true, // entries: true, // fill: true, // find: true, // findIndex: true, // keys: true // } Object.keys(Array.prototype[Symbol.unscopables]) // [&#39;copyWithin&#39;, &#39;entries&#39;, &#39;fill&#39;, &#39;find&#39;, &#39;findIndex&#39;, &#39;keys&#39;] 上面代码说明，数组有6个属性，会被with命令排除。 // 没有unscopables时 class MyClass { foo() { return 1; } } var foo = function () { return 2; }; with (MyClass.prototype) { foo(); // 1 } // 有unscopables时 class MyClass { foo() { return 1; } get [Symbol.unscopables]() { return { foo: true }; } } var foo = function () { return 2; }; with (MyClass.prototype) { foo(); // 2 }","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Symbol","slug":"Symbol","permalink":"https://microzz.com/tags/Symbol/"}]},{"title":"对象的扩展(Object)","date":"2016-12-25T04:45:19.000Z","path":"2016/12/25/object/","text":"对象的扩展属性的简洁表示法ES6允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 var foo = &#39;bar&#39;; var baz = {foo}; baz // {foo: &quot;bar&quot;} // 等同于 var baz = {foo: foo}; 上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。 function f(x, y) { return {x, y}; } // 等同于 function f(x, y) { return {x: x, y: y}; } f(1, 2) // Object {x: 1, y: 2} 除了属性简写，方法也可以简写。 var o = { method() { return &quot;Hello!&quot;; } }; // 等同于 var o = { method: function() { return &quot;Hello!&quot;; } }; 下面是一个实际的例子。 var birth = &#39;2000/01/01&#39;; var Person = { name: &#39;张三&#39;, //等同于birth: birth birth, // 等同于hello: function ()... hello() { console.log(&#39;我的名字是&#39;, this.name); } }; 这种写法用于函数的返回值，将会非常方便。 function getPoint() { var x = 1; var y = 10; return {x, y}; } getPoint() // {x:1, y:10} CommonJS模块输出变量，就非常合适使用简洁写法。 var ms = {}; function getItem (key) { return key in ms ? ms[key] : null; } function setItem (key, value) { ms[key] = value; } function clear () { ms = {}; } module.exports = { getItem, setItem, clear }; // 等同于 module.exports = { getItem: getItem, setItem: setItem, clear: clear }; 属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。 var cart = { _wheels: 4, get wheels () { return this._wheels; }, set wheels (value) { if (value &lt; this._wheels) { throw new Error(&#39;数值太小了！&#39;); } this._wheels = value; } } 注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。 var obj = { class () {} }; // 等同于 var obj = { &#39;class&#39;: function() {} }; 上面代码中，class是字符串，所以不会因为它属于关键字，而导致语法解析报错。 如果某个方法的值是一个Generator函数，前面需要加上星号。 var obj = { * m(){ yield &#39;hello world&#39;; } }; 属性名表达式JavaScript语言定义对象的属性，有两种方法。 // 方法一 obj.foo = true; // 方法二 obj[&#39;a&#39; + &#39;bc&#39;] = 123; 上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。 但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。 var obj = { foo: true, abc: 123 }; ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。 let propKey = &#39;foo&#39;; let obj = { [propKey]: true, [&#39;a&#39; + &#39;bc&#39;]: 123 }; 下面是另一个例子。 var lastWord = &#39;last word&#39;; var a = { &#39;first word&#39;: &#39;hello&#39;, [lastWord]: &#39;world&#39; }; a[&#39;first word&#39;] // &quot;hello&quot; a[lastWord] // &quot;world&quot; a[&#39;last word&#39;] // &quot;world&quot; 表达式还可以用于定义方法名。 let obj = { [&#39;h&#39; + &#39;ello&#39;]() { return &#39;hi&#39;; } }; obj.hello() // hi 注意，属性名表达式与简洁表示法，不能同时使用，会报错。 // 报错 var foo = &#39;bar&#39;; var bar = &#39;abc&#39;; var baz = { [foo] }; // 正确 var foo = &#39;bar&#39;; var baz = { [foo]: &#39;abc&#39;}; 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。 const keyA = {a: 1}; const keyB = {b: 2}; const myObject = { [keyA]: &#39;valueA&#39;, [keyB]: &#39;valueB&#39; }; myObject // Object {[object Object]: &quot;valueB&quot;} 上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。 方法的 name 属性函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。 const person = { sayName() { console.log(&#39;hello!&#39;); }, }; person.sayName.name // &quot;sayName&quot; 上面代码中，方法的name属性返回函数名（即方法名）。 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。 const obj = { get foo() {}, set foo(x) {} }; obj.foo.name // TypeError: Cannot read property &#39;name&#39; of undefined const descriptor = Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;); descriptor.get.name // &quot;get foo&quot; descriptor.set.name // &quot;set foo&quot; 有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。 (new Function()).name // &quot;anonymous&quot; var doSomething = function() { // ... }; doSomething.bind().name // &quot;bound doSomething&quot; 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。 const key1 = Symbol(&#39;description&#39;); const key2 = Symbol(); let obj = { [key1]() {}, [key2]() {}, }; obj[key1].name // &quot;[description]&quot; obj[key2].name // &quot;&quot; 上面代码中，key1对应的 Symbol 值有描述，key2没有。 Object.is()ES5比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。 ES6提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。 Object.is(&#39;foo&#39;, &#39;foo&#39;) // true Object.is({}, {}) // false 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 +0 === -0 //true NaN === NaN // false Object.is(+0, -0) // false Object.is(NaN, NaN) // true ES5可以通过下面的代码，部署Object.is。 Object.defineProperty(Object, &#39;is&#39;, { value: function(x, y) { if (x === y) { // 针对+0 不等于 -0的情况 return x !== 0 || 1 / x === 1 / y; } // 针对NaN的情况 return x !== x &amp;&amp; y !== y; }, configurable: true, enumerable: false, writable: true }); Object.assign()基本用法Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 var target = { a: 1 }; var source1 = { b: 2 }; var source2 = { c: 3 }; Object.assign(target, source1, source2); target // {a:1, b:2, c:3} Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。 var target = { a: 1, b: 1 }; var source1 = { b: 2, c: 2 }; var source2 = { c: 3 }; Object.assign(target, source1, source2); target // {a:1, b:2, c:3} 如果只有一个参数，Object.assign会直接返回该参数。 var obj = {a: 1}; Object.assign(obj) === obj // true 如果该参数不是对象，则会先转成对象，然后返回。 typeof Object.assign(2) // &quot;object&quot; 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。 Object.assign(undefined) // 报错 Object.assign(null) // 报错 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。 let obj = {a: 1}; Object.assign(obj, undefined) === obj // true Object.assign(obj, null) === obj // true 其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。 var v1 = &#39;abc&#39;; var v2 = true; var v3 = 10; var obj = Object.assign({}, v1, v2, v3); console.log(obj); // { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; } 上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。 Object(true) // {[[PrimitiveValue]]: true} Object(10) // {[[PrimitiveValue]]: 10} Object(&#39;abc&#39;) // {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;} 上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[PrimitiveValue]]上面，这个属性是不会被Object.assign拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。 Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。 Object.assign({b: &#39;c&#39;}, Object.defineProperty({}, &#39;invisible&#39;, { enumerable: false, value: &#39;hello&#39; }) ) // { b: &#39;c&#39; } 上面代码中，Object.assign要拷贝的对象只有一个不可枚举属性invisible，这个属性并没有被拷贝进去。 属性名为Symbol值的属性，也会被Object.assign拷贝。 Object.assign({ a: &#39;b&#39; }, { [Symbol(&#39;c&#39;)]: &#39;d&#39; }) // { a: &#39;b&#39;, Symbol(c): &#39;d&#39; } 注意点Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。 var obj1 = {a: {b: 1}}; var obj2 = Object.assign({}, obj1); obj1.a.b = 2; obj2.a.b // 2 上面代码中，源对象obj1的a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。 对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。 var target = { a: { b: &#39;c&#39;, d: &#39;e&#39; } } var source = { a: { b: &#39;hello&#39; } } Object.assign(target, source) // { a: { b: &#39;hello&#39; } } 上面代码中，target对象的a属性被source对象的a属性整个替换掉了，而不会得到{ a: { b: &#39;hello&#39;, d: &#39;e&#39; } }的结果。这通常不是开发者想要的，需要特别小心。 有一些函数库提供Object.assign的定制版本（比如Lodash的_.defaultsDeep方法），可以解决浅拷贝的问题，得到深拷贝的合并。 注意，Object.assign可以用来处理数组，但是会把数组视为对象。 Object.assign([1, 2, 3], [4, 5]) // [4, 5, 3] 上面代码中，Object.assign把数组视为属性名为0、1、2的对象，因此源数组的0号属性4覆盖了目标数组的0号属性1。 常见用途Object.assign方法有很多用处。 （1）为对象添加属性 class Point { constructor(x, y) { Object.assign(this, {x, y}); } } 上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。 （2）为对象添加方法 Object.assign(SomeClass.prototype, { someMethod(arg1, arg2) { ··· }, anotherMethod() { ··· } }); // 等同于下面的写法 SomeClass.prototype.someMethod = function (arg1, arg2) { ··· }; SomeClass.prototype.anotherMethod = function () { ··· }; 上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。 （3）克隆对象 function clone(origin) { return Object.assign({}, origin); } 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。 不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。 function clone(origin) { let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin); } （4）合并多个对象 将多个对象合并到某个对象。 const merge = (target, ...sources) =&gt; Object.assign(target, ...sources); 如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。 const merge = (...sources) =&gt; Object.assign({}, ...sources); （5）为属性指定默认值 const DEFAULTS = { logLevel: 0, outputFormat: &#39;html&#39; }; function processContent(options) { options = Object.assign({}, DEFAULTS, options); } 上面代码中，DEFAULTS对象是默认值，options对象是用户提供的参数。Object.assign方法将DEFAULTS和options合并成一个新对象，如果两者有同名属性，则option的属性值会覆盖DEFAULTS的属性值。 注意，由于存在深拷贝的问题，DEFAULTS对象和options对象的所有属性的值，都只能是简单类型，而不能指向另一个对象。否则，将导致DEFAULTS对象的该属性不起作用。 属性的可枚举性对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。 let obj = { foo: 123 }; Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;) // { // value: 123, // writable: true, // enumerable: true, // configurable: true // } 描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。 ES5有三个操作会忽略enumerable为false的属性。 for...in循环：只遍历对象自身的和继承的可枚举的属性 Object.keys()：返回对象自身的所有可枚举的属性的键名 JSON.stringify()：只串行化对象自身的可枚举的属性 ES6新增了一个操作Object.assign()，会忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 这四个操作之中，只有for...in会返回继承的属性。实际上，引入enumerable的最初目的，就是让某些属性可以规避掉for...in操作。比如，对象原型的toString方法，以及数组的length属性，就通过这种手段，不会被for...in遍历到。 Object.getOwnPropertyDescriptor(Object.prototype, &#39;toString&#39;).enumerable // false Object.getOwnPropertyDescriptor([], &#39;length&#39;).enumerable // false 上面代码中，toString和length属性的enumerable都是false，因此for...in不会遍历到这两个继承自原型的属性。 另外，ES6规定，所有Class的原型的方法都是不可枚举的。 Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, &#39;foo&#39;).enumerable // false 总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for...in循环，而用Object.keys()代替。 属性的遍历ES6一共有5种方法可以遍历对象的属性。 （1）for…in for...in循环遍历对象自身的和继承的可枚举属性（不含Symbol属性）。 （2）Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含Symbol属性）。 （3）Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含Symbol属性，但是包括不可枚举属性）。 （4）Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有Symbol属性。 （5）Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名是Symbol或字符串，也不管是否可枚举。 以上的5种方法遍历对象的属性，都遵守同样的属性遍历的次序规则。 首先遍历所有属性名为数值的属性，按照数字排序。 其次遍历所有属性名为字符串的属性，按照生成时间排序。 最后遍历所有属性名为Symbol值的属性，按照生成时间排序。 Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 }) // [&#39;2&#39;, &#39;10&#39;, &#39;b&#39;, &#39;a&#39;, Symbol()] 上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是Symbol属性。 __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()（1）__proto__属性 __proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括IE11）都部署了这个属性。 // es6的写法 var obj = { method: function() { ... } }; obj.__proto__ = someOtherObj; // es5的写法 var obj = Object.create(someOtherObj); obj.method = function() { ... }; 该属性没有写入ES6的正文，而是写入了附录，原因是__proto__前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的API，只是由于浏览器广泛支持，才被加入了ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。 在实现上，__proto__调用的是Object.prototype.__proto__，具体实现如下。 Object.defineProperty(Object.prototype, &#39;__proto__&#39;, { get() { let _thisObj = Object(this); return Object.getPrototypeOf(_thisObj); }, set(proto) { if (this === undefined || this === null) { throw new TypeError(); } if (!isObject(this)) { return undefined; } if (!isObject(proto)) { return undefined; } let status = Reflect.setPrototypeOf(this, proto); if (!status) { throw new TypeError(); } }, }); function isObject(value) { return Object(value) === value; } 如果一个对象本身部署了__proto__属性，则该属性的值就是对象的原型。 Object.getPrototypeOf({ __proto__: null }) // null （2）Object.setPrototypeOf() Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象。它是ES6正式推荐的设置原型对象的方法。 // 格式 Object.setPrototypeOf(object, prototype) // 用法 var o = Object.setPrototypeOf({}, null); 该方法等同于下面的函数。 function (obj, proto) { obj.__proto__ = proto; return obj; } 下面是一个例子。 let proto = {}; let obj = { x: 10 }; Object.setPrototypeOf(obj, proto); proto.y = 20; proto.z = 40; obj.x // 10 obj.y // 20 obj.z // 40 上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。 （3）Object.getPrototypeOf() 该方法与setPrototypeOf方法配套，用于读取一个对象的prototype对象。 Object.getPrototypeOf(obj); 下面是一个例子。 function Rectangle() { } var rec = new Rectangle(); Object.getPrototypeOf(rec) === Rectangle.prototype // true Object.setPrototypeOf(rec, Object.prototype); Object.getPrototypeOf(rec) === Rectangle.prototype // false Object.keys()，Object.values()，Object.entries()Object.keys()ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。 var obj = { foo: &#39;bar&#39;, baz: 42 }; Object.keys(obj) // [&quot;foo&quot;, &quot;baz&quot;] ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段。 let {keys, values, entries} = Object; let obj = { a: 1, b: 2, c: 3 }; for (let key of keys(obj)) { console.log(key); // &#39;a&#39;, &#39;b&#39;, &#39;c&#39; } for (let value of values(obj)) { console.log(value); // 1, 2, 3 } for (let [key, value] of entries(obj)) { console.log([key, value]); // [&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3] } Object.values()Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。 var obj = { foo: &#39;bar&#39;, baz: 42 }; Object.values(obj) // [&quot;bar&quot;, 42] 返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。 var obj = { 100: &#39;a&#39;, 2: &#39;b&#39;, 7: &#39;c&#39; }; Object.values(obj) // [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;] 上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是b、c、a。 Object.values只返回对象自身的可遍历属性。 var obj = Object.create({}, {p: {value: 42}}); Object.values(obj) // [] 上面代码中，Object.create方法的第二个参数添加的对象属性（属性p），如果不显式声明，默认是不可遍历的，因为p是继承的属性，而不是对象自身的属性。Object.values不会返回这个属性。 Object.values会过滤属性名为 Symbol 值的属性。 Object.values({ [Symbol()]: 123, foo: &#39;abc&#39; }); // [&#39;abc&#39;] 如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。 Object.values(&#39;foo&#39;) // [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;] 上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，Object.values返回每个属性的键值，就是各个字符组成的一个数组。 如果参数不是对象，Object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数组。 Object.values(42) // [] Object.values(true) // [] Object.entriesObject.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。 var obj = { foo: &#39;bar&#39;, baz: 42 }; Object.entries(obj) // [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ] 除了返回值不一样，该方法的行为与Object.values基本一致。 如果原对象的属性名是一个Symbol值，该属性会被省略。 Object.entries({ [Symbol()]: 123, foo: &#39;abc&#39; }); // [ [ &#39;foo&#39;, &#39;abc&#39; ] ] 上面代码中，原对象有两个属性，Object.entries只输出属性名非Symbol值的属性。将来可能会有Reflect.ownEntries()方法，返回对象自身的所有属性。 Object.entries的基本用途是遍历对象的属性。 let obj = { one: 1, two: 2 }; for (let [k, v] of Object.entries(obj)) { console.log(`${JSON.stringify(k)}: ${JSON.stringify(v)}`); } // &quot;one&quot;: 1 // &quot;two&quot;: 2 Object.entries方法的一个用处是，将对象转为真正的Map结构。 var obj = { foo: &#39;bar&#39;, baz: 42 }; var map = new Map(Object.entries(obj)); map // Map { foo: &quot;bar&quot;, baz: 42 } 自己实现Object.entries方法，非常简单。 // Generator函数的版本 function* entries(obj) { for (let key of Object.keys(obj)) { yield [key, obj[key]]; } } // 非Generator函数的版本 function entries(obj) { let arr = []; for (let key of Object.keys(obj)) { arr.push([key, obj[key]]); } return arr; } 对象的扩展运算符目前，ES7有一个提案，将Rest运算符（解构赋值）/扩展运算符（...）引入对象。Babel转码器已经支持这项功能。 （1）解构赋值 对象的解构赋值用于从一个对象取值，相当于将所有可遍历的、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。 let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 }; x // 1 y // 2 z // { a: 3, b: 4 } 上面代码中，变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。 由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。 let { x, y, ...z } = null; // 运行时错误 let { x, y, ...z } = undefined; // 运行时错误 解构赋值必须是最后一个参数，否则会报错。 let { ...x, y, z } = obj; // 句法错误 let { x, ...y, ...z } = obj; // 句法错误 上面代码中，解构赋值不是最后一个参数，所以会报错。 注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。 let obj = { a: { b: 1 } }; let { ...x } = obj; obj.a.b = 2; x.a.b // 2 上面代码中，x是解构赋值所在的对象，拷贝了对象obj的a属性。a属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。 另外，解构赋值不会拷贝继承自原型对象的属性。 let o1 = { a: 1 }; let o2 = { b: 2 }; o2.__proto__ = o1; let o3 = { ...o2 }; o3 // { b: 2 } 上面代码中，对象o3是o2的拷贝，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。 下面是另一个例子。 var o = Object.create({ x: 1, y: 2 }); o.z = 3; let { x, ...{ y, z } } = o; x // 1 y // undefined z // 3 上面代码中，变量x是单纯的解构赋值，所以可以读取继承的属性；解构赋值产生的变量y和z，只能读取对象自身的属性，所以只有变量z可以赋值成功。 解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。 function baseFunction({ a, b }) { // ... } function wrapperFunction({ x, y, ...restConfig }) { // 使用x和y参数进行操作 // 其余参数传给原始函数 return baseFunction(restConfig); } 上面代码中，原始函数baseFunction接受a和b作为参数，函数wrapperFunction在baseFunction的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。 （2）扩展运算符 扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。 let z = { a: 3, b: 4 }; let n = { ...z }; n // { a: 3, b: 4 } 这等同于使用Object.assign方法。 let aClone = { ...a }; // 等同于 let aClone = Object.assign({}, a); 扩展运算符可以用于合并两个对象。 let ab = { ...a, ...b }; // 等同于 let ab = Object.assign({}, a, b); 如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。 let aWithOverrides = { ...a, x: 1, y: 2 }; // 等同于 let aWithOverrides = { ...a, ...{ x: 1, y: 2 } }; // 等同于 let x = 1, y = 2, aWithOverrides = { ...a, x, y }; // 等同于 let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 }); 上面代码中，a对象的x属性和y属性，拷贝到新对象后会被覆盖掉。 这用来修改现有对象部分的部分属性就很方便了。 let newVersion = { ...previousVersion, name: &#39;New Name&#39; // Override the name property }; 上面代码中，newVersion对象自定义了name属性，其他属性全部复制自previousVersion对象。 如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。 let aWithDefaults = { x: 1, y: 2, ...a }; // 等同于 let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a); // 等同于 let aWithDefaults = Object.assign({ x: 1, y: 2 }, a); 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。 // 并不会抛出错误，因为x属性只是被定义，但没执行 let aWithXGetter = { ...a, get x() { throws new Error(&#39;not thrown yet&#39;); } }; // 会抛出错误，因为x属性被执行了 let runtimeError = { ...a, ...{ get x() { throws new Error(&#39;thrown now&#39;); } } }; 如果扩展运算符的参数是null或undefined，这个两个值会被忽略，不会报错。 let emptyObject = { ...null, ...undefined }; // 不报错 Object.getOwnPropertyDescriptors()ES5有一个Object.getOwnPropertyDescriptor方法，返回某个对象属性的描述对象（descriptor）。 var obj = { p: &#39;a&#39; }; Object.getOwnPropertyDescriptor(obj, &#39;p&#39;) // Object { value: &quot;a&quot;, // writable: true, // enumerable: true, // configurable: true // } ES7有一个提案，提出了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。 const obj = { foo: 123, get bar() { return &#39;abc&#39; } }; Object.getOwnPropertyDescriptors(obj) // { foo: // { value: 123, // writable: true, // enumerable: true, // configurable: true }, // bar: // { get: [Function: bar], // set: undefined, // enumerable: true, // configurable: true } } Object.getOwnPropertyDescriptors方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。 该方法的实现非常容易。 function getOwnPropertyDescriptors(obj) { const result = {}; for (let key of Reflect.ownKeys(obj)) { result[key] = Object.getOwnPropertyDescriptor(obj, key); } return result; } 该方法的提出目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。 const source = { set foo(value) { console.log(value); } }; const target1 = {}; Object.assign(target1, source); Object.getOwnPropertyDescriptor(target1, &#39;foo&#39;) // { value: undefined, // writable: true, // enumerable: true, // configurable: true } 上面代码中，source对象的foo属性的值是一个赋值函数，Object.assign方法将这个属性拷贝给target1对象，结果该属性的值变成了undefined。这是因为Object.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。 这时，Object.getOwnPropertyDescriptors方法配合Object.defineProperties方法，就可以实现正确拷贝。 const source = { set foo(value) { console.log(value); } }; const target2 = {}; Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source)); Object.getOwnPropertyDescriptor(target2, &#39;foo&#39;) // { get: undefined, // set: [Function: foo], // enumerable: true, // configurable: true } 上面代码中，将两个对象合并的逻辑提炼出来，就是下面这样。 const shallowMerge = (target, source) =&gt; Object.defineProperties( target, Object.getOwnPropertyDescriptors(source) ); Object.getOwnPropertyDescriptors方法的另一个用处，是配合Object.create方法，将对象属性克隆到一个新对象。这属于浅拷贝。 const clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)); // 或者 const shallowClone = (obj) =&gt; Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj) ); 上面代码会克隆对象obj。 另外，Object.getOwnPropertyDescriptors方法可以实现，一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。 const obj = { __proto__: prot, foo: 123, }; ES6规定__proto__只有浏览器要部署，其他环境不用部署。如果去除__proto__，上面代码就要改成下面这样。 const obj = Object.create(prot); obj.foo = 123; // 或者 const obj = Object.assign( Object.create(prot), { foo: 123, } ); 有了Object.getOwnPropertyDescriptors，我们就有了另一种写法。 const obj = Object.create( prot, Object.getOwnPropertyDescriptors({ foo: 123, }) ); Object.getOwnPropertyDescriptors也可以用来实现Mixin（混入）模式。 let mix = (object) =&gt; ({ with: (...mixins) =&gt; mixins.reduce( (c, mixin) =&gt; Object.create( c, Object.getOwnPropertyDescriptors(mixin) ), object) }); // multiple mixins example let a = {a: &#39;a&#39;}; let b = {b: &#39;b&#39;}; let c = {c: &#39;c&#39;}; let d = mix(c).with(a, b); 上面代码中，对象a和b被混入了对象c。 出于完整性的考虑，Object.getOwnPropertyDescriptors进入标准以后，还会有Reflect.getOwnPropertyDescriptors方法。 关于内容来自阮一峰老师的《ES6标准入门》，感谢","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Object","slug":"Object","permalink":"https://microzz.com/tags/Object/"}]},{"title":"函数的扩展(Function)","date":"2016-12-10T07:45:19.000Z","path":"2016/12/10/function/","text":"函数的扩展函数参数的默认值基本用法在ES6之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 function log(x, y) { y = y || &#39;World&#39;; console.log(x, y); } log(&#39;Hello&#39;) // Hello World log(&#39;Hello&#39;, &#39;China&#39;) // Hello China log(&#39;Hello&#39;, &#39;&#39;) // Hello World 上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。 为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。 if (typeof y === &#39;undefined&#39;) { y = &#39;World&#39;; } ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。 function log(x, y = &#39;World&#39;) { console.log(x, y); } log(&#39;Hello&#39;) // Hello World log(&#39;Hello&#39;, &#39;China&#39;) // Hello China log(&#39;Hello&#39;, &#39;&#39;) // Hello 可以看到，ES6的写法比ES5简洁许多，而且非常自然。下面是另一个例子。 function Point(x = 0, y = 0) { this.x = x; this.y = y; } var p = new Point(); p // { x: 0, y: 0 } 除了简洁，ES6的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。 参数变量是默认声明的，所以不能用let或const再次声明。 function foo(x = 5) { let x = 1; // error const x = 2; // error } 上面代码中，参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。 与解构赋值默认值结合使用参数默认值可以与解构赋值的默认值，结合起来使用。 function foo({x, y = 5}) { console.log(x, y); } foo({}) // undefined, 5 foo({x: 1}) // 1, 5 foo({x: 1, y: 2}) // 1, 2 foo() // TypeError: Cannot read property &#39;x&#39; of undefined 上面代码使用了对象的解构赋值默认值，而没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值而生成。如果函数foo调用时参数不是对象，变量x和y就不会生成，从而报错。如果参数对象没有y属性，y的默认值5才会生效。 下面是另一个对象的解构赋值默认值的例子。 function fetch(url, { body = &#39;&#39;, method = &#39;GET&#39;, headers = {} }) { console.log(method); } fetch(&#39;http://example.com&#39;, {}) // &quot;GET&quot; fetch(&#39;http://example.com&#39;) // 报错 上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。 上面的写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。 function fetch(url, { method = &#39;GET&#39; } = {}) { console.log(method); } fetch(&#39;http://example.com&#39;) // &quot;GET&quot; 上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。 再请问下面两种写法有什么差别？ // 写法一 function m1({x = 0, y = 0} = {}) { return [x, y]; } // 写法二 function m2({x, y} = { x: 0, y: 0 }) { return [x, y]; } 上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。 // 函数没有参数的情况 m1() // [0, 0] m2() // [0, 0] // x和y都有值的情况 m1({x: 3, y: 8}) // [3, 8] m2({x: 3, y: 8}) // [3, 8] // x有值，y无值的情况 m1({x: 3}) // [3, 0] m2({x: 3}) // [3, undefined] // x和y都无值的情况 m1({}) // [0, 0]; m2({}) // [undefined, undefined] m1({z: 3}) // [0, 0] m2({z: 3}) // [undefined, undefined] 参数默认值的位置通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 // 例一 function f(x = 1, y) { return [x, y]; } f() // [1, undefined] f(2) // [2, undefined]) f(, 1) // 报错 f(undefined, 1) // [1, 1] // 例二 function f(x, y = 5, z) { return [x, y, z]; } f() // [undefined, 5, undefined] f(1) // [1, 5, undefined] f(1, ,2) // 报错 f(1, undefined, 2) // [1, 5, 2] 上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。 如果传入undefined，将触发该参数等于默认值，null则没有这个效果。 function foo(x = 5, y = 6) { console.log(x, y); } foo(undefined, null) // 5 null 上面代码中，x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值。 函数的length属性指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。 (function (a) {}).length // 1 (function (a = 5) {}).length // 0 (function (a, b, c = 5) {}).length // 2 上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了3个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，rest参数也不会计入length属性。 (function(...args) {}).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 (function (a = 0, b, c) {}).length // 0 (function (a, b = 1, c) {}).length // 1 作用域一个需要注意的地方是，如果参数默认值是一个变量，则该变量所处的作用域，与其他变量的作用域规则是一样的，即先是当前函数的作用域，然后才是全局作用域。 var x = 1; function f(x, y = x) { console.log(y); } f(2) // 2 上面代码中，参数y的默认值等于x。调用时，由于函数作用域内部的变量x已经生成，所以y等于参数x，而不是全局变量x。 如果调用时，函数作用域内部的变量x没有生成，结果就会不一样。 let x = 1; function f(y = x) { let x = 2; console.log(y); } f() // 1 上面代码中，函数调用时，y的默认值变量x尚未在函数内部生成，所以x指向全局变量。 如果此时，全局变量x不存在，就会报错。 function f(y = x) { let x = 2; console.log(y); } f() // ReferenceError: x is not defined 下面这样写，也会报错。 var x = 1; function foo(x = x) { // ... } foo() // ReferenceError: x is not defined 上面代码中，函数foo的参数x的默认值也是x。这时，默认值x的作用域是函数作用域，而不是全局作用域。由于在函数作用域中，存在变量x，但是默认值在x赋值之前先执行了，所以这时属于暂时性死区（参见《let和const命令》一章），任何对x的操作都会报错。 如果参数的默认值是一个函数，该函数的作用域是其声明时所在的作用域。请看下面的例子。 let foo = &#39;outer&#39;; function bar(func = x =&gt; foo) { let foo = &#39;inner&#39;; console.log(func()); // outer } bar(); 上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。这个匿名函数声明时，bar函数的作用域还没有形成，所以匿名函数里面的foo指向外层作用域的foo，输出outer。 如果写成下面这样，就会报错。 function bar(func = () =&gt; foo) { let foo = &#39;inner&#39;; console.log(func()); } bar() // ReferenceError: foo is not defined 上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明foo，所以就报错了。 下面是一个更复杂的例子。 var x = 1; function foo(x, y = function() { x = 2; }) { var x = 3; y(); console.log(x); } foo() // 3 上面代码中，函数foo的参数y的默认值是一个匿名函数。函数foo调用时，它的参数x的值为undefined，所以y函数内部的x一开始是undefined，后来被重新赋值2。但是，函数foo内部重新声明了一个x，值为3，这两个x是不一样的，互相不产生影响，因此最后输出3。 如果将var x = 3的var去除，两个x就是一样的，最后输出的就是2。 var x = 1; function foo(x, y = function() { x = 2; }) { x = 3; y(); console.log(x); } foo() // 2 应用利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。 function throwIfMissing() { throw new Error(&#39;Missing parameter&#39;); } function foo(mustBeProvided = throwIfMissing()) { return mustBeProvided; } foo() // Error: Missing parameter 上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。 从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（即函数名之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行（即如果参数已经赋值，默认值中的函数就不会运行），这与python语言不一样。 另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。 function foo(optional = undefined) { ··· } rest参数ES6引入rest参数（形式为“…变量名”），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 function add(...values) { let sum = 0; for (var val of values) { sum += val; } return sum; } add(2, 5, 3) // 10 上面代码的add函数是一个求和函数，利用rest参数，可以向该函数传入任意数目的参数。 下面是一个rest参数代替arguments变量的例子。 // arguments变量的写法 function sortNumbers() { return Array.prototype.slice.call(arguments).sort(); } // rest参数的写法 const sortNumbers = (...numbers) =&gt; numbers.sort(); 上面代码的两种写法，比较后可以发现，rest参数的写法更自然也更简洁。 rest参数中的变量代表一个数组，所以数组特有的方法都可以用于这个变量。下面是一个利用rest参数改写数组push方法的例子。 function push(array, ...items) { items.forEach(function(item) { array.push(item); console.log(item); }); } var a = []; push(a, 1, 2, 3) 注意，rest参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 // 报错 function f(a, ...b, c) { // ... } 函数的length属性，不包括rest参数。 (function(a) {}).length // 1 (function(...a) {}).length // 0 (function(a, ...b) {}).length // 1 扩展运算符含义扩展运算符（spread）是三个点（...）。它好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。 console.log(...[1, 2, 3]) // 1 2 3 console.log(1, ...[2, 3, 4], 5) // 1 2 3 4 5 [...document.querySelectorAll(&#39;div&#39;)] // [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 该运算符主要用于函数调用。 function push(array, ...items) { array.push(...items); } function add(x, y) { return x + y; } var numbers = [4, 38]; add(...numbers) // 42 上面代码中，array.push(...items)和add(...numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。 扩展运算符与正常的函数参数可以结合使用，非常灵活。 function f(v, w, x, y, z) { } var args = [0, 1]; f(-1, ...args, 2, ...[3]); 替代数组的apply方法由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。 // ES5的写法 function f(x, y, z) { // ... } var args = [0, 1, 2]; f.apply(null, args); // ES6的写法 function f(x, y, z) { // ... } var args = [0, 1, 2]; f(...args); 下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。 // ES5的写法 Math.max.apply(null, [14, 3, 77]) // ES6的写法 Math.max(...[14, 3, 77]) // 等同于 Math.max(14, 3, 77); 上面代码表示，由于JavaScript不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。 另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。 // ES5的写法 var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; Array.prototype.push.apply(arr1, arr2); // ES6的写法 var arr1 = [0, 1, 2]; var arr2 = [3, 4, 5]; arr1.push(...arr2); 上面代码的ES5写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。 下面是另外一个例子。 // ES5 new (Date.bind.apply(Date, [null, 2015, 1, 1])) // ES6 new Date(...[2015, 1, 1]); 扩展运算符的应用（1）合并数组 扩展运算符提供了数组合并的新写法。 // ES5 [1, 2].concat(more) // ES6 [1, 2, ...more] var arr1 = [&#39;a&#39;, &#39;b&#39;]; var arr2 = [&#39;c&#39;]; var arr3 = [&#39;d&#39;, &#39;e&#39;]; // ES5的合并数组 arr1.concat(arr2, arr3); // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ] // ES6的合并数组 [...arr1, ...arr2, ...arr3] // [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ] （2）与解构赋值结合 扩展运算符可以与解构赋值结合起来，用于生成数组。 // ES5 a = list[0], rest = list.slice(1) // ES6 [a, ...rest] = list 下面是另外一些例子。 const [first, ...rest] = [1, 2, 3, 4, 5]; first // 1 rest // [2, 3, 4, 5] const [first, ...rest] = []; first // undefined rest // []: const [first, ...rest] = [&quot;foo&quot;]; first // &quot;foo&quot; rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 const [...butLast, last] = [1, 2, 3, 4, 5]; // 报错 const [first, ...middle, last] = [1, 2, 3, 4, 5]; // 报错 （3）函数的返回值 JavaScript的函数只能返回一个值，如果需要返回多个值，只能返回数组或对象。扩展运算符提供了解决这个问题的一种变通方法。 var dateFields = readDateFields(database); var d = new Date(...dateFields); 上面代码从数据库取出一行数据，通过扩展运算符，直接将其传入构造函数Date。 （4）字符串 扩展运算符还可以将字符串转为真正的数组。 [...&#39;hello&#39;] // [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ] 上面的写法，有一个重要的好处，那就是能够正确识别32位的Unicode字符。 &#39;x\\uD83D\\uDE80y&#39;.length // 4 [...&#39;x\\uD83D\\uDE80y&#39;].length // 3 上面代码的第一种写法，JavaScript会将32位Unicode字符，识别为2个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。 function length(str) { return [...str].length; } length(&#39;x\\uD83D\\uDE80y&#39;) // 3 凡是涉及到操作32位Unicode字符的函数，都有这个问题。因此，最好都用扩展运算符改写。 let str = &#39;x\\uD83D\\uDE80y&#39;; str.split(&#39;&#39;).reverse().join(&#39;&#39;) // &#39;y\\uDE80\\uD83Dx&#39; [...str].reverse().join(&#39;&#39;) // &#39;y\\uD83D\\uDE80x&#39; 上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。 （5）实现了Iterator接口的对象 任何Iterator接口的对象，都可以用扩展运算符转为真正的数组。 var nodeList = document.querySelectorAll(&#39;div&#39;); var array = [...nodeList]; 上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了Iterator接口。 对于那些没有部署Iterator接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。 let arrayLike = { &#39;0&#39;: &#39;a&#39;, &#39;1&#39;: &#39;b&#39;, &#39;2&#39;: &#39;c&#39;, length: 3 }; // TypeError: Cannot spread non-iterable object. let arr = [...arrayLike]; 上面代码中，arrayLike是一个类似数组的对象，但是没有部署Iterator接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。 （6）Map和Set结构，Generator函数 扩展运算符内部调用的是数据结构的Iterator接口，因此只要具有Iterator接口的对象，都可以使用扩展运算符，比如Map结构。 let map = new Map([ [1, &#39;one&#39;], [2, &#39;two&#39;], [3, &#39;three&#39;], ]); let arr = [...map.keys()]; // [1, 2, 3] Generator函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 var go = function*(){ yield 1; yield 2; yield 3; }; [...go()] // [1, 2, 3] 上面代码中，变量go是一个Generator函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。 如果对没有iterator接口的对象，使用扩展运算符，将会报错。 var obj = {a: 1, b: 2}; let arr = [...obj]; // TypeError: Cannot spread non-iterable object 严格模式从ES5开始，函数内部可以设定为严格模式。 function doSomething(a, b) { &#39;use strict&#39;; // code } 《ECMAScript 2016标准》做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 // 报错 function doSomething(a, b = a) { &#39;use strict&#39;; // code } // 报错 const doSomething = function ({a, b}) { &#39;use strict&#39;; // code }; // 报错 const doSomething = (...a) =&gt; { &#39;use strict&#39;; // code }; const obj = { // 报错 doSomething({a, b}) { &#39;use strict&#39;; // code } }; 这样规定的原因是，函数内部的严格模式，同时适用于函数体代码和函数参数代码。但是，函数执行的时候，先执行函数参数代码，然后再执行函数体代码。这样就有一个不合理的地方，只有从函数体代码之中，才能知道参数代码是否应该以严格模式执行，但是参数代码却应该先于函数体代码执行。 // 报错 function doSomething(value = 070) { &#39;use strict&#39;; return value; } 上面代码中，参数value的默认值是八进制数070，但是严格模式下不能用前缀0表示八进制，所以应该报错。但是实际上，JavaScript引擎会先成功执行value = 070，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。 虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。 两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。 &#39;use strict&#39;; function doSomething(a, b = a) { // code } 第二种是把函数包在一个无参数的立即执行函数里面。 const doSomething = (function () { &#39;use strict&#39;; return function(value = 42) { return value; }; }()); name 属性函数的name属性，返回该函数的函数名。 function foo() {} foo.name // &quot;foo&quot; 这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。 需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。 var f = function () {}; // ES5 f.name // &quot;&quot; // ES6 f.name // &quot;f&quot; 上面代码中，变量f等于一个匿名函数，ES5 和 ES6 的name属性返回的值不一样。 如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。 const bar = function baz() {}; // ES5 bar.name // &quot;baz&quot; // ES6 bar.name // &quot;baz&quot; Function构造函数返回的函数实例，name属性的值为anonymous。 (new Function).name // &quot;anonymous&quot; bind返回的函数，name属性值会加上bound前缀。 function foo() {}; foo.bind({}).name // &quot;bound foo&quot; (function(){}).bind({}).name // &quot;bound &quot; 箭头函数基本用法ES6允许使用“箭头”（=&gt;）定义函数。 var f = v =&gt; v; 上面的箭头函数等同于： var f = function(v) { return v; }; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 var f = () =&gt; 5; // 等同于 var f = function () { return 5 }; var sum = (num1, num2) =&gt; num1 + num2; // 等同于 var sum = function(num1, num2) { return num1 + num2; }; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 var sum = (num1, num2) =&gt; { return num1 + num2; } 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号。 var getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; }); 箭头函数可以与变量解构结合使用。 const full = ({ first, last }) =&gt; first + &#39; &#39; + last; // 等同于 function full(person) { return person.first + &#39; &#39; + person.last; } 箭头函数使得表达更加简洁。 const isEven = n =&gt; n % 2 == 0; const square = n =&gt; n * n; 上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。 箭头函数的一个用处是简化回调函数。 // 正常函数写法 [1,2,3].map(function (x) { return x * x; }); // 箭头函数写法 [1,2,3].map(x =&gt; x * x); 另一个例子是 // 正常函数写法 var result = values.sort(function (a, b) { return a - b; }); // 箭头函数写法 var result = values.sort((a, b) =&gt; a - b); 下面是rest参数与箭头函数结合的例子。 const numbers = (...nums) =&gt; nums; numbers(1, 2, 3, 4, 5) // [1,2,3,4,5] const headAndTail = (head, ...tail) =&gt; [head, tail]; headAndTail(1, 2, 3, 4, 5) // [1,[2,3,4,5]] 使用注意点箭头函数有几个使用注意点。 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用Rest参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作Generator函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。 function foo() { setTimeout(() =&gt; { console.log(&#39;id:&#39;, this.id); }, 100); } var id = 21; foo.call({ id: 42 }); // id: 42 上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到100毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。 function Timer() { this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () { this.s2++; }, 1000); } var timer = new Timer(); setTimeout(() =&gt; console.log(&#39;s1: &#39;, timer.s1), 3100); setTimeout(() =&gt; console.log(&#39;s2: &#39;, timer.s2), 3100); // s1: 3 // s2: 0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100毫秒之后，timer.s1被更新了3次，而timer.s2一次都没更新。 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM事件的回调函数封装在一个对象里面。 var handler = { id: &#39;123456&#39;, init: function() { document.addEventListener(&#39;click&#39;, event =&gt; this.doSomething(event.type), false); }, doSomething: function(type) { console.log(&#39;Handling &#39; + type + &#39; for &#39; + this.id); } }; 上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 所以，箭头函数转成ES5的代码如下。 // ES6 function foo() { setTimeout(() =&gt; { console.log(&#39;id:&#39;, this.id); }, 100); } // ES5 function foo() { var _this = this; setTimeout(function () { console.log(&#39;id:&#39;, _this.id); }, 100); } 上面代码中，转换后的ES5版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。 请问下面的代码之中有几个this？ function foo() { return () =&gt; { return () =&gt; { return () =&gt; { console.log(&#39;id:&#39;, this.id); }; }; }; } var f = foo.call({id: 1}); var t1 = f.call({id: 2})()(); // id: 1 var t2 = f().call({id: 3})(); // id: 1 var t3 = f()().call({id: 4}); // id: 1 上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。 function foo() { setTimeout(() =&gt; { console.log(&#39;args:&#39;, arguments); }, 100); } foo(2, 4, 6, 8) // args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 (function() { return [ (() =&gt; this.x).bind({ x: &#39;inner&#39; })() ]; }).call({ x: &#39;outer&#39; }); // [&#39;outer&#39;] 上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。 长期以来，JavaScript语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。 嵌套的箭头函数箭头函数内部，还可以再使用箭头函数。下面是一个ES5语法的多重嵌套函数。 function insert(value) { return {into: function (array) { return {after: function (afterValue) { array.splice(array.indexOf(afterValue) + 1, 0, value); return array; }}; }}; } insert(2).into([1, 3]).after(1); //[1, 2, 3] 上面这个函数，可以使用箭头函数改写。 let insert = (value) =&gt; ({into: (array) =&gt; ({after: (afterValue) =&gt; { array.splice(array.indexOf(afterValue) + 1, 0, value); return array; }})}); insert(2).into([1, 3]).after(1); //[1, 2, 3] 下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。 const pipeline = (...funcs) =&gt; val =&gt; funcs.reduce((a, b) =&gt; b(a), val); const plus1 = a =&gt; a + 1; const mult2 = a =&gt; a * 2; const addThenMult = pipeline(plus1, mult2); addThenMult(5) // 12 如果觉得上面的写法可读性比较差，也可以采用下面的写法。 const plus1 = a =&gt; a + 1; const mult2 = a =&gt; a * 2; mult2(plus1(5)) // 12 箭头函数还有一个功能，就是可以很方便地改写λ演算。 // λ演算的写法 fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v))) // ES6的写法 var fix = f =&gt; (x =&gt; f(v =&gt; x(x)(v))) (x =&gt; f(v =&gt; x(x)(v))); 上面两种写法，几乎是一一对应的。由于λ演算对于计算机科学非常重要，这使得我们可以用ES6作为替代工具，探索计算机科学。 绑定 this箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以ES7提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。虽然该语法还是ES7的一个提案，但是Babel转码器已经支持。 函数绑定运算符是并排的两个双冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。 foo::bar; // 等同于 bar.bind(foo); foo::bar(...arguments); // 等同于 bar.apply(foo, arguments); const hasOwnProperty = Object.prototype.hasOwnProperty; function hasOwn(obj, key) { return obj::hasOwnProperty(key); } 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。 var method = obj::obj.foo; // 等同于 var method = ::obj.foo; let log = ::console.log; // 等同于 var log = console.log.bind(console); 由于双冒号运算符返回的还是原对象，因此可以采用链式写法。 // 例一 import { map, takeWhile, forEach } from &quot;iterlib&quot;; getPlayers() ::map(x =&gt; x.character()) ::takeWhile(x =&gt; x.strength &gt; 100) ::forEach(x =&gt; console.log(x)); // 例二 let { find, html } = jake; document.querySelectorAll(&quot;div.myClass&quot;) ::find(&quot;p&quot;) ::html(&quot;hahaha&quot;); 尾调用优化什么是尾调用？尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 function f(x){ return g(x); } 上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。 以下三种情况，都不属于尾调用。 // 情况一 function f(x){ let y = g(x); return y; } // 情况二 function f(x){ return g(x) + 1; } // 情况三 function f(x){ g(x); } 上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。 function f(x){ g(x); return undefined; } 尾调用不一定出现在函数尾部，只要是最后一步操作即可。 function f(x) { if (x &gt; 0) { return m(x) } return n(x); } 上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 尾调用优化尾调用之所以与其他调用不同，就在于它的特殊的调用位置。 我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 function f() { let m = 1; let n = 2; return g(m + n); } f(); // 等同于 function f() { return g(3); } f(); // 等同于 g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除 f(x) 的调用帧，只保留 g(3) 的调用帧。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 function addOne(a){ var one = 1; function inner(b){ return b + one; } return inner(a); } 上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 function factorial(n) { if (n === 1) return 1; return n * factorial(n - 1); } factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 function factorial(n, total) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5, 1) // 120 还有一个比较著名的例子，就是计算fibonacci 数列，也能充分说明尾递归优化的重要性 如果是非尾递归的fibonacci 递归方法 function Fibonacci (n) { if ( n &lt;= 1 ) {return 1}; return Fibonacci(n - 1) + Fibonacci(n - 2); } Fibonacci(10); // 89 // Fibonacci(100) // Fibonacci(500) // 堆栈溢出了 如果我们使用尾递归优化过的fibonacci 递归算法 function Fibonacci2 (n , ac1 = 1 , ac2 = 1) { if( n &lt;= 1 ) {return ac2}; return Fibonacci2 (n - 1, ac2, ac1 + ac2); } Fibonacci2(100) // 573147844013817200000 Fibonacci2(1000) // 7.0330367711422765e+208 Fibonacci2(10000) // Infinity 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6也是如此，第一次明确规定，所有ECMAScript的实现，都必须部署“尾调用优化”。这就是说，在ES6中，只要使用尾递归，就不会发生栈溢出，相对节省内存。 递归函数的改写尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量 total ，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？ 两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。 function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total); } function factorial(n) { return tailFactorial(n, 1); } factorial(5) // 120 上面代码通过一个正常形式的阶乘函数 factorial ，调用尾递归函数 tailFactorial ，看起来就正常多了。 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。 function currying(fn, n) { return function (m) { return fn.call(this, m, n); }; } function tailFactorial(n, total) { if (n === 1) return total; return tailFactorial(n - 1, n * total); } const factorial = currying(tailFactorial, 1); factorial(5) // 120 上面代码通过柯里化，将尾递归函数 tailFactorial 变为只接受1个参数的 factorial 。 第二种方法就简单多了，就是采用ES6的函数默认值。 function factorial(n, total = 1) { if (n === 1) return total; return factorial(n - 1, n * total); } factorial(5) // 120 上面代码中，参数 total 有默认值1，所以调用时不用提供这个值。 总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。 严格模式ES6的尾调用优化只在严格模式下开启，正常模式是无效的。 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。 func.arguments：返回调用时函数的参数。 func.caller：返回调用当前函数的那个函数。 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。 function restricted() { &quot;use strict&quot;; restricted.caller; // 报错 restricted.arguments; // 报错 } restricted(); 尾递归优化的实现尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。 它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。 下面是一个正常的递归函数。 function sum(x, y) { if (y &gt; 0) { return sum(x + 1, y - 1); } else { return x; } } sum(1, 100000) // Uncaught RangeError: Maximum call stack size exceeded(…) 上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归100000次，就会报错，提示超出调用栈的最大次数。 蹦床函数（trampoline）可以将递归执行转为循环执行。 function trampoline(f) { while (f &amp;&amp; f instanceof Function) { f = f(); } return f; } 上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。 function sum(x, y) { if (y &gt; 0) { return sum.bind(null, x + 1, y - 1); } else { return x; } } 上面代码中，sum函数的每次执行，都会返回自身的另一个版本。 现在，使用蹦床函数执行sum，就不会发生调用栈溢出。 trampoline(sum(1, 100000)) // 100001 蹦床函数并不是真正的尾递归优化，下面的实现才是。 function tco(f) { var value; var active = false; var accumulated = []; return function accumulator() { accumulated.push(arguments); if (!active) { active = true; while (accumulated.length) { value = f.apply(this, accumulated.shift()); } active = false; return value; } }; } var sum = tco(function(x, y) { if (y &gt; 0) { return sum(x + 1, y - 1) } else { return x } }); sum(1, 100000) // 100001 上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。 函数参数的尾逗号ECMAScript 2017将允许函数的最后一个参数有尾逗号（trailing comma）。 此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。 function clownsEverywhere( param1, param2 ) { /* ... */ } clownsEverywhere( &#39;foo&#39;, &#39;bar&#39; ); 上面代码中，如果在param2或bar后面加一个逗号，就会报错。 这样的话，如果以后修改代码，想为函数clownsEverywhere添加第三个参数，就势必要在第二个参数后面添加一个逗号。这对版本管理系统来说，就会显示，添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。 function clownsEverywhere( param1, param2, ) { /* ... */ } clownsEverywhere( &#39;foo&#39;, &#39;bar&#39;, ); 感谢阮一峰老师的原创，本分享仅供学习交流","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Function","slug":"Function","permalink":"https://microzz.com/tags/Function/"}]},{"title":"数组的扩展(Array)","date":"2016-11-30T04:45:19.000Z","path":"2016/11/30/array/","text":"数组的扩展Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括ES6新增的数据结构Set和Map）。 下面是一个类似数组的对象，Array.from将它转为真正的数组。 let arrayLike = { &#39;0&#39;: &#39;a&#39;, &#39;1&#39;: &#39;b&#39;, &#39;2&#39;: &#39;c&#39;, length: 3 }; // ES5的写法 var arr1 = [].slice.call(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] // ES6的写法 let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;] 实际应用中，常见的类似数组的对象是DOM操作返回的NodeList集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 // NodeList对象 let ps = document.querySelectorAll(&#39;p&#39;); Array.from(ps).forEach(function (p) { console.log(p); }); // arguments对象 function foo() { var args = Array.from(arguments); // ... } 上面代码中，querySelectorAll方法返回的是一个类似数组的对象，只有将这个对象转为真正的数组，才能使用forEach方法。 只要是部署了Iterator接口的数据结构，Array.from都能将其转为数组。 Array.from(&#39;hello&#39;) // [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;] let namesSet = new Set([&#39;a&#39;, &#39;b&#39;]) Array.from(namesSet) // [&#39;a&#39;, &#39;b&#39;] 上面代码中，字符串和Set结构都具有Iterator接口，因此可以被Array.from转为真正的数组。 如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。 Array.from([1, 2, 3]) // [1, 2, 3] 值得提醒的是，扩展运算符（...）也可以将某些数据结构转为数组。 // arguments对象 function foo() { var args = [...arguments]; } // NodeList对象 [...document.querySelectorAll(&#39;div&#39;)] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法则是还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 Array.from({ length: 3 }); // [ undefined, undefined, undefined ] 上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。 const toArray = (() =&gt; Array.from ? Array.from : obj =&gt; [].slice.call(obj) )(); Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 Array.from(arrayLike, x =&gt; x * x); // 等同于 Array.from(arrayLike).map(x =&gt; x * x); Array.from([1, 2, 3], (x) =&gt; x * x) // [1, 4, 9] 下面的例子是取出一组DOM节点的文本内容。 let spans = document.querySelectorAll(&#39;span.name&#39;); // map() let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent); // Array.from() let names2 = Array.from(spans, s =&gt; s.textContent) 下面的例子将数组中布尔值为false的成员转为0。 Array.from([1, , 2, , 3], (n) =&gt; n || 0) // [1, 0, 2, 0, 3] 另一个例子是返回各种数据的类型。 function typesOf () { return Array.from(arguments, value =&gt; typeof value) } typesOf(null, [], NaN) // [&#39;object&#39;, &#39;object&#39;, &#39;number&#39;] 如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。 Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。 Array.from({ length: 2 }, () =&gt; &#39;jack&#39;) // [&#39;jack&#39;, &#39;jack&#39;] 上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。 Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种Unicode字符，可以避免JavaScript将大于\\uFFFF的Unicode字符，算作两个字符的bug。 function countSymbols(string) { return Array.from(string).length; } Array.of()Array.of方法用于将一组值，转换为数组。 Array.of(3, 11, 8) // [3,11,8] Array.of(3) // [3] Array.of(3).length // 1 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 Array() // [] Array(3) // [, , ,] Array(3, 11, 8) // [3, 11, 8] 上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于2个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。 Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。 Array.of() // [] Array.of(undefined) // [undefined] Array.of(1) // [1] Array.of(1, 2) // [1, 2] Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 Array.of方法可以用下面的代码模拟实现。 function ArrayOf(){ return [].slice.call(arguments); } 数组实例的copyWithin()数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。 start（可选）：从该位置开始读取数据，默认为0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。 这三个参数都应该是数值，如果不是，会自动转为数值。 [1, 2, 3, 4, 5].copyWithin(0, 3) // [4, 5, 3, 4, 5] 上面代码表示将从3号位直到数组结束的成员（4和5），复制到从0号位开始的位置，结果覆盖了原来的1和2。 下面是更多例子。 // 将3号位复制到0号位 [1, 2, 3, 4, 5].copyWithin(0, 3, 4) // [4, 2, 3, 4, 5] // -2相当于3号位，-1相当于4号位 [1, 2, 3, 4, 5].copyWithin(0, -2, -1) // [4, 2, 3, 4, 5] // 将3号位复制到0号位 [].copyWithin.call({length: 5, 3: 1}, 0, 3) // {0: 1, 3: 1, length: 5} // 将2号位到数组结束，复制到0号位 var i32a = new Int32Array([1, 2, 3, 4, 5]); i32a.copyWithin(0, 2); // Int32Array [3, 4, 5, 4, 5] // 对于没有部署TypedArray的copyWithin方法的平台 // 需要采用下面的写法 [].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4); // Int32Array [4, 2, 3, 4, 5] 数组实例的find()和findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 [1, 4, -5, 10].find((n) =&gt; n &lt; 0) // -5 上面代码找出数组中第一个小于0的成员。 [1, 5, 10, 15].find(function(value, index, arr) { return value &gt; 9; }) // 10 上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 [1, 5, 10, 15].findIndex(function(value, index, arr) { return value &gt; 9; }) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 另外，这两个方法都可以发现NaN，弥补了数组的IndexOf方法的不足。 [NaN].indexOf(NaN) // -1 [NaN].findIndex(y =&gt; Object.is(NaN, y)) // 0 上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。 数组实例的fill()fill方法使用给定值，填充一个数组。 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7) // [7, 7, 7] new Array(3).fill(7) // [7, 7, 7] 上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。 fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2) // [&#39;a&#39;, 7, &#39;c&#39;] 上面代码表示，fill方法从1号位开始，向原数组填充7，到2号位之前结束。 数组实例的entries()，keys()和values()ES6提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for...of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) { console.log(index); } // 0 // 1 for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) { console.log(elem); } // &#39;a&#39; // &#39;b&#39; for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) { console.log(index, elem); } // 0 &quot;a&quot; // 1 &quot;b&quot; 如果不使用for...of循环，可以手动调用遍历器对象的next方法，进行遍历。 let letter = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]; let entries = letter.entries(); console.log(entries.next().value); // [0, &#39;a&#39;] console.log(entries.next().value); // [1, &#39;b&#39;] console.log(entries.next().value); // [2, &#39;c&#39;] 数组实例的includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。该方法属于ES7，但Babel转码器已经支持。 [1, 2, 3].includes(2); // true [1, 2, 3].includes(4); // false [1, 2, NaN].includes(NaN); // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。 [1, 2, 3].includes(3, 3); // false [1, 2, 3].includes(3, -1); // true 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。 if (arr.indexOf(el) !== -1) { // ... } indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相当运算符（===）进行判断，这会导致对NaN的误判。 [NaN].indexOf(NaN) // -1 includes使用的是不一样的判断算法，就没有这个问题。 [NaN].includes(NaN) // true 下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。 const contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el === value) )(); contains([&quot;foo&quot;, &quot;bar&quot;], &quot;baz&quot;); // =&gt; false 另外，Map和Set数据结构有一个has方法，需要注意与includes区分。 Map结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。 Set结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。 数组的空位数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。 Array(3) // [, , ,] 上面代码中，Array(3)返回一个具有3个空位的数组。 注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。 0 in [undefined, undefined, undefined] // true 0 in [, , ,] // false 上面代码说明，第一个数组的0号位置是有值的，第二个数组的0号位置没有值。 ES5对空位的处理，已经很不一致了，大多数情况下会忽略空位。 forEach(), filter(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 // forEach方法 [,&#39;a&#39;].forEach((x,i) =&gt; console.log(i)); // 1 // filter方法 [&#39;a&#39;,,&#39;b&#39;].filter(x =&gt; true) // [&#39;a&#39;,&#39;b&#39;] // every方法 [,&#39;a&#39;].every(x =&gt; x===&#39;a&#39;) // true // some方法 [,&#39;a&#39;].some(x =&gt; x !== &#39;a&#39;) // false // map方法 [,&#39;a&#39;].map(x =&gt; 1) // [,1] // join方法 [,&#39;a&#39;,undefined,null].join(&#39;#&#39;) // &quot;#a##&quot; // toString方法 [,&#39;a&#39;,undefined,null].toString() // &quot;,a,,&quot; ES6则是明确将空位转为undefined。 Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。 Array.from([&#39;a&#39;,,&#39;b&#39;]) // [ &quot;a&quot;, undefined, &quot;b&quot; ] 扩展运算符（...）也会将空位转为undefined。 [...[&#39;a&#39;,,&#39;b&#39;]] // [ &quot;a&quot;, undefined, &quot;b&quot; ] copyWithin()会连空位一起拷贝。 [,&#39;a&#39;,&#39;b&#39;,,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;] fill()会将空位视为正常的数组位置。 new Array(3).fill(&#39;a&#39;) // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;] for...of循环也会遍历空位。 let arr = [, ,]; for (let i of arr) { console.log(1); } // 1 // 1 上面代码中，数组arr有两个空位，for...of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。 // entries() [...[,&#39;a&#39;].entries()] // [[0,undefined], [1,&quot;a&quot;]] // keys() [...[,&#39;a&#39;].keys()] // [0,1] // values() [...[,&#39;a&#39;].values()] // [undefined,&quot;a&quot;] // find() [,&#39;a&#39;].find(x =&gt; true) // undefined // findIndex() [,&#39;a&#39;].findIndex(x =&gt; true) // 0 由于空位的处理规则非常不统一，所以建议避免出现空位。 感谢阮一峰老师的原创，本分享仅供学习交流","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Array","slug":"Array","permalink":"https://microzz.com/tags/Array/"}]},{"title":"数值的扩展","date":"2016-11-25T09:45:19.000Z","path":"2016/11/25/number/","text":"数值的扩展二进制和八进制表示法ES6提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 0b111110111 === 503 // true 0o767 === 503 // true 从ES5开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6进一步明确，要使用前缀0o表示。 // 非严格模式 (function(){ console.log(0o11 === 011); })() // true // 严格模式 (function(){ &#39;use strict&#39;; console.log(0o11 === 011); })() // Uncaught SyntaxError: Octal literals are not allowed in strict mode. 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。 Number(&#39;0b111&#39;) // 7 Number(&#39;0o10&#39;) // 8 Number.isFinite(), Number.isNaN()ES6在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。 Number.isFinite()用来检查一个数值是否为有限的（finite）。 Number.isFinite(15); // true Number.isFinite(0.8); // true Number.isFinite(NaN); // false Number.isFinite(Infinity); // false Number.isFinite(-Infinity); // false Number.isFinite(&#39;foo&#39;); // false Number.isFinite(&#39;15&#39;); // false Number.isFinite(true); // false ES5可以通过下面的代码，部署Number.isFinite方法。 (function (global) { var global_isFinite = global.isFinite; Object.defineProperty(Number, &#39;isFinite&#39;, { value: function isFinite(value) { return typeof value === &#39;number&#39; &amp;&amp; global_isFinite(value); }, configurable: true, enumerable: false, writable: true }); })(this); Number.isNaN()用来检查一个值是否为NaN。 Number.isNaN(NaN) // true Number.isNaN(15) // false Number.isNaN(&#39;15&#39;) // false Number.isNaN(true) // false Number.isNaN(9/NaN) // true Number.isNaN(&#39;true&#39;/0) // true Number.isNaN(&#39;true&#39;/&#39;true&#39;) // true ES5通过下面的代码，部署Number.isNaN()。 (function (global) { var global_isNaN = global.isNaN; Object.defineProperty(Number, &#39;isNaN&#39;, { value: function isNaN(value) { return typeof value === &#39;number&#39; &amp;&amp; global_isNaN(value); }, configurable: true, enumerable: false, writable: true }); })(this); 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，非数值一律返回false。 isFinite(25) // true isFinite(&quot;25&quot;) // true Number.isFinite(25) // true Number.isFinite(&quot;25&quot;) // false isNaN(NaN) // true isNaN(&quot;NaN&quot;) // true Number.isNaN(NaN) // true Number.isNaN(&quot;NaN&quot;) // false Number.parseInt(), Number.parseFloat()ES6将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 // ES5的写法 parseInt(&#39;12.34&#39;) // 12 parseFloat(&#39;123.45#&#39;) // 123.45 // ES6的写法 Number.parseInt(&#39;12.34&#39;) // 12 Number.parseFloat(&#39;123.45#&#39;) // 123.45 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 Number.parseInt === parseInt // true Number.parseFloat === parseFloat // true Number.isInteger()Number.isInteger()用来判断一个值是否为整数。需要注意的是，在JavaScript内部，整数和浮点数是同样的储存方法，所以3和3.0被视为同一个值。 Number.isInteger(25) // true Number.isInteger(25.0) // true Number.isInteger(25.1) // false Number.isInteger(&quot;15&quot;) // false Number.isInteger(true) // false ES5可以通过下面的代码，部署Number.isInteger()。 (function (global) { var floor = Math.floor, isFinite = global.isFinite; Object.defineProperty(Number, &#39;isInteger&#39;, { value: function isInteger(value) { return typeof value === &#39;number&#39; &amp;&amp; isFinite(value) &amp;&amp; value &gt; -9007199254740992 &amp;&amp; value &lt; 9007199254740992 &amp;&amp; floor(value) === value; }, configurable: true, enumerable: false, writable: true }); })(this); Number.EPSILONES6在Number对象上面，新增一个极小的常量Number.EPSILON。 Number.EPSILON // 2.220446049250313e-16 Number.EPSILON.toFixed(20) // &#39;0.00000000000000022204&#39; 引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。 0.1 + 0.2 // 0.30000000000000004 0.1 + 0.2 - 0.3 // 5.551115123125783e-17 5.551115123125783e-17.toFixed(20) // &#39;0.00000000000000005551&#39; 但是如果这个误差能够小于Number.EPSILON，我们就可以认为得到了正确结果。 5.551115123125783e-17 &lt; Number.EPSILON // true 因此，Number.EPSILON的实质是一个可以接受的误差范围。 function withinErrorMargin (left, right) { return Math.abs(left - right) &lt; Number.EPSILON; } withinErrorMargin(0.1 + 0.2, 0.3) // true withinErrorMargin(0.2 + 0.2, 0.3) // false 上面的代码为浮点数运算，部署了一个误差检查函数。 安全整数和Number.isSafeInteger()JavaScript能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。 Math.pow(2, 53) // 9007199254740992 9007199254740992 // 9007199254740992 9007199254740993 // 9007199254740992 Math.pow(2, 53) === Math.pow(2, 53) + 1 // true 上面代码中，超出2的53次方之后，一个数就不精确了。 ES6引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。 Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1 // true Number.MAX_SAFE_INTEGER === 9007199254740991 // true Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER // true Number.MIN_SAFE_INTEGER === -9007199254740991 // true 上面代码中，可以看到JavaScript能够精确表示的极限。 Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。 Number.isSafeInteger(&#39;a&#39;) // false Number.isSafeInteger(null) // false Number.isSafeInteger(NaN) // false Number.isSafeInteger(Infinity) // false Number.isSafeInteger(-Infinity) // false Number.isSafeInteger(3) // true Number.isSafeInteger(1.2) // false Number.isSafeInteger(9007199254740990) // true Number.isSafeInteger(9007199254740992) // false Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // false Number.isSafeInteger(Number.MIN_SAFE_INTEGER) // true Number.isSafeInteger(Number.MAX_SAFE_INTEGER) // true Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false 这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。 Number.isSafeInteger = function (n) { return (typeof n === &#39;number&#39; &amp;&amp; Math.round(n) === n &amp;&amp; Number.MIN_SAFE_INTEGER &lt;= n &amp;&amp; n &lt;= Number.MAX_SAFE_INTEGER); } 实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。 Number.isSafeInteger(9007199254740993) // false Number.isSafeInteger(990) // true Number.isSafeInteger(9007199254740993 - 990) // true 9007199254740993 - 990 // 返回结果 9007199254740002 // 正确答案应该是 9007199254740003 上面代码中，9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。 9007199254740993 === 9007199254740992 // true 所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。 function trusty (left, right, result) { if ( Number.isSafeInteger(left) &amp;&amp; Number.isSafeInteger(right) &amp;&amp; Number.isSafeInteger(result) ) { return result; } throw new RangeError(&#39;Operation cannot be trusted!&#39;); } trusty(9007199254740993, 990, 9007199254740993 - 990) // RangeError: Operation cannot be trusted! trusty(1, 2, 3) // 3 Math对象的扩展ES6在Math对象上新增了17个与数学相关的方法。所有这些方法都是静态方法，只能在Math对象上调用。 Math.trunc()Math.trunc方法用于去除一个数的小数部分，返回整数部分。 Math.trunc(4.1) // 4 Math.trunc(4.9) // 4 Math.trunc(-4.1) // -4 Math.trunc(-4.9) // -4 Math.trunc(-0.1234) // -0 对于非数值，Math.trunc内部使用Number方法将其先转为数值。 Math.trunc(&#39;123.456&#39;) // 123 对于空值和无法截取整数的值，返回NaN。 Math.trunc(NaN); // NaN Math.trunc(&#39;foo&#39;); // NaN Math.trunc(); // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 Math.trunc = Math.trunc || function(x) { return x &lt; 0 ? Math.ceil(x) : Math.floor(x); }; Math.sign()Math.sign方法用来判断一个数到底是正数、负数、还是零。 它会返回五种值。 参数为正数，返回+1； 参数为负数，返回-1； 参数为0，返回0； 参数为-0，返回-0; 其他值，返回NaN。 Math.sign(-5) // -1 Math.sign(5) // +1 Math.sign(0) // +0 Math.sign(-0) // -0 Math.sign(NaN) // NaN Math.sign(&#39;foo&#39;); // NaN Math.sign(); // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 Math.sign = Math.sign || function(x) { x = +x; // convert to a number if (x === 0 || isNaN(x)) { return x; } return x &gt; 0 ? 1 : -1; }; Math.cbrt()Math.cbrt方法用于计算一个数的立方根。 Math.cbrt(-1) // -1 Math.cbrt(0) // 0 Math.cbrt(1) // 1 Math.cbrt(2) // 1.2599210498948734 对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。 Math.cbrt(&#39;8&#39;) // 2 Math.cbrt(&#39;hello&#39;) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 Math.cbrt = Math.cbrt || function(x) { var y = Math.pow(Math.abs(x), 1/3); return x &lt; 0 ? -y : y; }; Math.clz32()JavaScript的整数使用32位二进制形式表示，Math.clz32方法返回一个数的32位无符号整数形式有多少个前导0。 Math.clz32(0) // 32 Math.clz32(1) // 31 Math.clz32(1000) // 22 Math.clz32(0b01000000000000000000000000000000) // 1 Math.clz32(0b00100000000000000000000000000000) // 2 上面代码中，0的二进制形式全为0，所以有32个前导0；1的二进制形式是0b1，只占1位，所以32位之中有31个前导0；1000的二进制形式是0b1111101000，一共有10位，所以32位之中有22个前导0。 clz32这个函数名就来自”count leading zero bits in 32-bit binary representations of a number“（计算32位整数的前导0）的缩写。 左移运算符（&lt;&lt;）与Math.clz32方法直接相关。 Math.clz32(0) // 32 Math.clz32(1) // 31 Math.clz32(1 &lt;&lt; 1) // 30 Math.clz32(1 &lt;&lt; 2) // 29 Math.clz32(1 &lt;&lt; 29) // 2 对于小数，Math.clz32方法只考虑整数部分。 Math.clz32(3.2) // 30 Math.clz32(3.9) // 30 对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。 Math.clz32() // 32 Math.clz32(NaN) // 32 Math.clz32(Infinity) // 32 Math.clz32(null) // 32 Math.clz32(&#39;foo&#39;) // 32 Math.clz32([]) // 32 Math.clz32({}) // 32 Math.clz32(true) // 31 Math.imul()Math.imul方法返回两个数以32位带符号整数形式相乘的结果，返回的也是一个32位的带符号整数。 Math.imul(2, 4) // 8 Math.imul(-1, 8) // -8 Math.imul(-2, -2) // 4 如果只考虑最后32位，大多数情况下，Math.imul(a, b)与a * b的结果是相同的，即该方法等同于(a * b)|0的效果（超过32位的部分溢出）。之所以需要部署这个方法，是因为JavaScript有精度限制，超过2的53次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。 (0x7fffffff * 0x7fffffff)|0 // 0 上面这个乘法算式，返回结果为0。但是由于这两个二进制数的最低位都是1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是1。这个错误就是因为它们的乘积超过了2的53次方，JavaScript无法保存额外的精度，就把低位的值都变成了0。Math.imul方法可以返回正确的值1。 Math.imul(0x7fffffff, 0x7fffffff) // 1 Math.fround()Math.fround方法返回一个数的单精度浮点数形式。 Math.fround(0) // 0 Math.fround(1) // 1 Math.fround(1.337) // 1.3370000123977661 Math.fround(1.5) // 1.5 Math.fround(NaN) // NaN 对于整数来说，Math.fround方法返回结果不会有任何不同，区别主要是那些无法用64个二进制位精确表示的小数。这时，Math.fround方法会返回最接近这个小数的单精度浮点数。 对于没有部署这个方法的环境，可以用下面的代码模拟。 Math.fround = Math.fround || function(x) { return new Float32Array([x])[0]; }; Math.hypot()Math.hypot方法返回所有参数的平方和的平方根。 Math.hypot(3, 4); // 5 Math.hypot(3, 4, 5); // 7.0710678118654755 Math.hypot(); // 0 Math.hypot(NaN); // NaN Math.hypot(3, 4, &#39;foo&#39;); // NaN Math.hypot(3, 4, &#39;5&#39;); // 7.0710678118654755 Math.hypot(-3); // 3 上面代码中，3的平方加上4的平方，等于5的平方。 如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回NaN。 对数方法ES6新增了4个对数相关方法。 （1） Math.expm1() Math.expm1(x)返回ex - 1，即Math.exp(x) - 1。 Math.expm1(-1) // -0.6321205588285577 Math.expm1(0) // 0 Math.expm1(1) // 1.718281828459045 对于没有部署这个方法的环境，可以用下面的代码模拟。 Math.expm1 = Math.expm1 || function(x) { return Math.exp(x) - 1; }; （2）Math.log1p() Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。 Math.log1p(1) // 0.6931471805599453 Math.log1p(0) // 0 Math.log1p(-1) // -Infinity Math.log1p(-2) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 Math.log1p = Math.log1p || function(x) { return Math.log(1 + x); }; （3）Math.log10() Math.log10(x)返回以10为底的x的对数。如果x小于0，则返回NaN。 Math.log10(2) // 0.3010299956639812 Math.log10(1) // 0 Math.log10(0) // -Infinity Math.log10(-2) // NaN Math.log10(100000) // 5 对于没有部署这个方法的环境，可以用下面的代码模拟。 Math.log10 = Math.log10 || function(x) { return Math.log(x) / Math.LN10; }; （4）Math.log2() Math.log2(x)返回以2为底的x的对数。如果x小于0，则返回NaN。 Math.log2(3) // 1.584962500721156 Math.log2(2) // 1 Math.log2(1) // 0 Math.log2(0) // -Infinity Math.log2(-2) // NaN Math.log2(1024) // 10 Math.log2(1 &lt;&lt; 29) // 29 对于没有部署这个方法的环境，可以用下面的代码模拟。 Math.log2 = Math.log2 || function(x) { return Math.log(x) / Math.LN2; }; 三角函数方法ES6新增了6个三角函数方法。 Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） 指数运算符ES7新增了一个指数运算符（**），目前Babel转码器已经支持。 2 ** 2 // 4 2 ** 3 // 8 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。 let a = 2; a **= 2; // 等同于 a = a * a; let b = 3; b **= 3; // 等同于 b = b * b * b;","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Number","slug":"Number","permalink":"https://microzz.com/tags/Number/"}]},{"title":"正则的扩展(RegExp)","date":"2016-11-20T07:57:19.000Z","path":"2016/11/20/regex/","text":"正则的扩展RegExp构造函数在ES5中，RegExp构造函数的参数有两种情况。 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 var regex = new RegExp(&#39;xyz&#39;, &#39;i&#39;); // 等价于 var regex = /xyz/i; 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 var regex = new RegExp(/xyz/i); // 等价于 var regex = /xyz/i; 但是，ES5不允许此时使用第二个参数，添加修饰符，否则会报错。 var regex = new RegExp(/xyz/, &#39;i&#39;); // Uncaught TypeError: Cannot supply flags when constructing one RegExp from another ES6改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 new RegExp(/abc/ig, &#39;i&#39;).flags // &quot;i&quot; 上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。 字符串的正则方法字符串对象共有4个方法，可以使用正则表达式：match()、replace()、search()和split()。 ES6将这4个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] u修饰符ES6对正则表达式添加了u修饰符，含义为“Unicode模式”，用来正确处理大于\\uFFFF的Unicode字符。也就是说，会正确处理四个字节的UTF-16编码。 /^\\uD83D/u.test(&#39;\\uD83D\\uDC2A&#39;) // false /^\\uD83D/.test(&#39;\\uD83D\\uDC2A&#39;) // true 上面代码中，\\uD83D\\uDC2A是一个四个字节的UTF-16编码，代表一个字符。但是，ES5不支持四个字节的UTF-16编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6就会识别其为一个字符，所以第一行代码结果为false。 一旦加上u修饰符号，就会修改下面这些正则表达式的行为。 （1）点字符 点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的Unicode字符，点字符不能识别，必须加上u修饰符。 var s = &#39;𠮷&#39;; /^.$/.test(s) // false /^.$/u.test(s) // true 上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。 （2）Unicode字符表示法 ES6新增了使用大括号表示Unicode字符，这种表示法在正则表达式中必须加上u修饰符，才能识别。 /\\u{61}/.test(&#39;a&#39;) // false /\\u{61}/u.test(&#39;a&#39;) // true /\\u{20BB7}/u.test(&#39;𠮷&#39;) // true 上面代码表示，如果不加u修饰符，正则表达式无法识别\\u{61}这种表示法，只会认为这匹配61个连续的u。 （3）量词 使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的Unicode字符。 /a{2}/.test(&#39;aa&#39;) // true /a{2}/u.test(&#39;aa&#39;) // true /𠮷{2}/.test(&#39;𠮷𠮷&#39;) // false /𠮷{2}/u.test(&#39;𠮷𠮷&#39;) // true 另外，只有在使用u修饰符的情况下，Unicode表达式当中的大括号才会被正确解读，否则会被解读为量词。 /^\\u{3}$/.test(&#39;uuu&#39;) // true 上面代码中，由于正则表达式没有u修饰符，所以大括号被解读为量词。加上u修饰符，就会被解读为Unicode表达式。 （4）预定义模式 u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的Unicode字符。 /^\\S$/.test(&#39;𠮷&#39;) // false /^\\S$/u.test(&#39;𠮷&#39;) // true 上面代码的\\S是预定义模式，匹配所有不是空格的字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的Unicode字符。 利用这一点，可以写出一个正确返回字符串长度的函数。 function codePointLength(text) { var result = text.match(/[\\s\\S]/gu); return result ? result.length : 0; } var s = &#39;𠮷𠮷&#39;; s.length // 4 codePointLength(s) // 2 （5）i修饰符 有些Unicode字符的编码不同，但是字型很相近，比如，\\u004B与\\u212A都是大写的K。 /[a-z]/i.test(&#39;\\u212A&#39;) // false /[a-z]/iu.test(&#39;\\u212A&#39;) // true 上面代码中，不加u修饰符，就无法识别非规范的K字符。 y 修饰符除了u修饰符，ES6还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。 y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 var s = &#39;aaa_aa_a&#39;; var r1 = /a+/g; var r2 = /a+/y; r1.exec(s) // [&quot;aaa&quot;] r2.exec(s) // [&quot;aaa&quot;] r1.exec(s) // [&quot;aa&quot;] r2.exec(s) // null 上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。 如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。 var s = &#39;aaa_aa_a&#39;; var r = /a+_/y; r.exec(s) // [&quot;aaa_&quot;] r.exec(s) // [&quot;aa_&quot;] 上面代码每次匹配，都是从剩余字符串的头部开始。 使用lastIndex属性，可以更好地说明y修饰符。 const REGEX = /a/g; // 指定从2号位置（y）开始匹配 REGEX.lastIndex = 2; // 匹配成功 const match = REGEX.exec(&#39;xaya&#39;); // 在3号位置匹配成功 match.index // 3 // 下一次匹配从4号位开始 REGEX.lastIndex // 4 // 4号位开始匹配失败 REGEX.exec(&#39;xaxa&#39;) // null 上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。 y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。 const REGEX = /a/y; // 指定从2号位置开始匹配 REGEX.lastIndex = 2; // 不是粘连，匹配失败 REGEX.exec(&#39;xaya&#39;) // null // 指定从3号位置开始匹配 REGEX.lastIndex = 3; // 3号位置是粘连，匹配成功 const match = REGEX.exec(&#39;xaxa&#39;); match.index // 3 REGEX.lastIndex // 4 进一步说，y修饰符号隐含了头部匹配的标志^。 /b/y.exec(&#39;aba&#39;) // null 上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。 在split方法中使用y修饰符，原字符串必须以分隔符开头。这也意味着，只要匹配成功，数组的第一个成员肯定是空字符串。 // 没有找到匹配 &#39;x##&#39;.split(/#/y) // [ &#39;x##&#39; ] // 找到两个匹配 &#39;##x&#39;.split(/#/y) // [ &#39;&#39;, &#39;&#39;, &#39;x&#39; ] 后续的分隔符只有紧跟前面的分隔符，才会被识别。 &#39;#x#&#39;.split(/#/y) // [ &#39;&#39;, &#39;x#&#39; ] &#39;##&#39;.split(/#/y) // [ &#39;&#39;, &#39;&#39;, &#39;&#39; ] 下面是字符串对象的replace方法的例子。 const REGEX = /a/gy; &#39;aaxa&#39;.replace(REGEX, &#39;-&#39;) // &#39;--xa&#39; 上面代码中，最后一个a因为不是出现下一次匹配的头部，所以不会被替换。 单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。 &#39;a1a2a3&#39;.match(/a\\d/y) // [&quot;a1&quot;] &#39;a1a2a3&#39;.match(/a\\d/gy) // [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;] y修饰符的一个应用，是从字符串提取token（词元），y修饰符确保了匹配之间不会有漏掉的字符。 const TOKEN_Y = /\\s*(\\+|[0-9]+)\\s*/y; const TOKEN_G = /\\s*(\\+|[0-9]+)\\s*/g; tokenize(TOKEN_Y, &#39;3 + 4&#39;) // [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ] tokenize(TOKEN_G, &#39;3 + 4&#39;) // [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ] function tokenize(TOKEN_REGEX, str) { let result = []; let match; while (match = TOKEN_REGEX.exec(str)) { result.push(match[1]); } return result; } 上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。 tokenize(TOKEN_Y, &#39;3x + 4&#39;) // [ &#39;3&#39; ] tokenize(TOKEN_G, &#39;3x + 4&#39;) // [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ] 上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。 sticky属性与y修饰符相匹配，ES6的正则对象多了sticky属性，表示是否设置了y修饰符。 var r = /hello\\d/y; r.sticky // true flags属性ES6为正则表达式新增了flags属性，会返回正则表达式的修饰符。 // ES5的source属性 // 返回正则表达式的正文 /abc/ig.source // &quot;abc&quot; // ES6的flags属性 // 返回正则表达式的修饰符 /abc/ig.flags // &#39;gi&#39; RegExp.escape()字符串必须转义，才能作为正则模式。 function escapeRegExp(str) { return str.replace(/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, &#39;\\\\$&amp;&#39;); } let str = &#39;/path/to/resource.html?search=query&#39;; escapeRegExp(str) // &quot;\\/path\\/to\\/resource\\.html\\?search=query&quot; 上面代码中，str是一个正常字符串，必须使用反斜杠对其中的特殊字符转义，才能用来作为一个正则匹配的模式。 已经有提议将这个需求标准化，作为RegExp对象的静态方法RegExp.escape()，放入ES7。2015年7月31日，TC39认为，这个方法有安全风险，又不愿这个方法变得过于复杂，没有同意将其列入ES7，但这不失为一个真实的需求。 RegExp.escape(&#39;The Quick Brown Fox&#39;); // &quot;The Quick Brown Fox&quot; RegExp.escape(&#39;Buy it. use it. break it. fix it.&#39;); // &quot;Buy it\\. use it\\. break it\\. fix it\\.&quot; RegExp.escape(&#39;(*.*)&#39;); // &quot;\\(\\*\\.\\*\\)&quot; 字符串转义以后，可以使用RegExp构造函数生成正则模式。 var str = &#39;hello. how are you?&#39;; var regex = new RegExp(RegExp.escape(str), &#39;g&#39;); assert.equal(String(regex), &#39;/hello\\. how are you\\?/g&#39;); 目前，该方法可以用上文的escapeRegExp函数或者垫片模块regexp.escape实现。 var escape = require(&#39;regexp.escape&#39;); escape(&#39;hi. how are you?&#39;); // &quot;hi\\\\. how are you\\\\?&quot; s 修饰符：dotAll 模式正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是行终止符（line terminator character）除外。 以下四个字符属于”行终止符“。 U+000A 换行符（\\n） U+000D 回车符（\\r） U+2028 行分隔符（line separator） U+2029 段分隔符（paragraph separator） /foo.bar/.test(&#39;foo\\nbar&#39;) // false 上面代码中，因为.不匹配\\n，所以正则表达式返回false。 但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。 /foo[^]bar/.test(&#39;foo\\nbar&#39;) // true 这种解决方案毕竟不太符合直觉，所以现在有一个提案，引入/s修饰符，使得.可以匹配任意单个字符。 /foo.bar/s.test(&#39;foo\\nbar&#39;) // true 这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。 const re = /foo.bar/s; // 另一种写法 // const re = new RegExp(&#39;foo.bar&#39;, &#39;s&#39;); re.test(&#39;foo\\nbar&#39;) // true re.dotAll // true re.flags // &#39;s&#39; /s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。 后行断言JavaScript语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。 目前，有一个提案，在ES7加入后行断言。V8引擎4.9版已经支持，Chrome浏览器49版打开”experimental JavaScript features“开关（地址栏键入about:flags），就可以使用这项功能。 ”先行断言“指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\\d+(?=%)/。”先行否定断言“指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\\d+(?!%)/。 /\\d+(?=%)/.exec(&#39;100% of US presidents have been male&#39;) // [&quot;100&quot;] /\\d+(?!%)/.exec(&#39;that’s all 44 of them&#39;) // [&quot;44&quot;] 上面两个字符串，如果互换正则表达式，就会匹配失败。另外，还可以看到，”先行断言“括号之中的部分（(?=%)），是不计入返回结果的。 “后行断言”正好与”先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\\$)\\d+/。”后行否定断言“则与”先行否定断言“相反，x只有不在y后面才匹配，必须写成/(?&lt;!y)x/。比如，只匹配不在美元符号后面的数字，要写成/(?&lt;!\\$)\\d+/。 /(?&lt;=\\$)\\d+/.exec(&#39;Benjamin Franklin is on the $100 bill&#39;) // [&quot;100&quot;] /(?&lt;!\\$)\\d+/.exec(&#39;it’s is worth about €90&#39;) // [&quot;90&quot;] 上面的例子中，”后行断言”的括号之中的部分（(?&lt;=\\$)），也是不计入返回结果。 “后行断言”的实现，需要先匹配/(?&lt;=y)x/的x，然后再回到左边，匹配y的部分。这种”先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。 首先，”后行断言“的组匹配，与正常情况下结果是不一样的。 /(?&lt;=(\\d+)(\\d+))$/.exec(&#39;1053&#39;) // [&quot;&quot;, &quot;1&quot;, &quot;053&quot;] /^(\\d+)(\\d+)$/.exec(&#39;1053&#39;) // [&quot;1053&quot;, &quot;105&quot;, &quot;3&quot;] 上面代码中，需要捕捉两个组匹配。没有”后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而”后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。 其次，”后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。 /(?&lt;=(o)d\\1)r/.exec(&#39;hodor&#39;) // null /(?&lt;=\\1d(o))r/.exec(&#39;hodor&#39;) // [&quot;r&quot;, &quot;o&quot;] 上面代码中，如果后行断言的反斜杠引用（\\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。 Unicode属性类目前，有一个提案，引入了一种新的类的写法\\p{...}和\\P{...}，允许正则表达式匹配符合Unicode某种属性的所有字符。 const regexGreekSymbol = /\\p{Script=Greek}/u; regexGreekSymbol.test(&#39;π&#39;) // u 上面代码中，\\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功。 Unicode属性类要指定属性名和属性值。 \\p{UnicodePropertyName=UnicodePropertyValue} 对于某些属性，可以只写属性名。 \\p{UnicodePropertyName} \\P{…}是\\p{…}的反向匹配，即匹配不满足条件的字符。 注意，这两种类只对Unicode有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\\p和\\P会报错，ECMAScript预留了这两个类。 由于Unicode的各种属性非常多，所以这种新的类的表达能力非常强。 const regex = /^\\p{Decimal_Number}+$/u; regex.test(&#39;𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼&#39;) // true 上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。 \\p{Number}甚至能匹配罗马数字。 // 匹配所有数字 const regex = /^\\p{Number}+$/u; regex.test(&#39;²³¹¼½¾&#39;) // true regex.test(&#39;㉛㉜㉝&#39;) // true regex.test(&#39;ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ&#39;) // true 下面是其他一些例子。 // 匹配各种文字的所有字母，等同于Unicode版的\\w [\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}] // 匹配各种文字的所有非字母的字符，等同于Unicode版的\\W [^\\p{Alphabetic}\\p{Mark}\\p{Decimal_Number}\\p{Connector_Punctuation}\\p{Join_Control}] // 匹配所有的箭头字符 const regexArrows = /^\\p{Block=Arrows}+$/u; regexArrows.test(&#39;←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩&#39;) // true","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"RegExp","slug":"RegExp","permalink":"https://microzz.com/tags/RegExp/"},{"name":"正则表达式","slug":"正则表达式","permalink":"https://microzz.com/tags/正则表达式/"}]},{"title":"字符串的扩展","date":"2016-11-15T07:45:19.000Z","path":"2016/11/15/string/","text":"字符串的扩展ES6加强了对Unicode的支持，并且扩展了字符串对象。 字符的Unicode表示法JavaScript允许采用\\uxxxx形式表示一个字符，其中“xxxx”表示字符的码点。 &quot;\\u0061&quot; // &quot;a&quot; 但是，这种表示法只限于\\u0000——\\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表达。 &quot;\\uD842\\uDFB7&quot; // &quot;𠮷&quot; &quot;\\u20BB7&quot; // &quot; 7&quot; 上面代码表示，如果直接在\\u后面跟上超过0xFFFF的数值（比如\\u20BB7），JavaScript会理解成\\u20BB+7。由于\\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。 ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 &quot;\\u{20BB7}&quot; // &quot;𠮷&quot; &quot;\\u{41}\\u{42}\\u{43}&quot; // &quot;ABC&quot; let hello = 123; hell\\u{6F} // 123 &#39;\\u{1F680}&#39; === &#39;\\uD83D\\uDE80&#39; // true 上面代码中，最后一个例子表明，大括号表示法与四字节的UTF-16编码是等价的。 有了这种表示法之后，JavaScript共有6种方法可以表示一个字符。 &#39;\\z&#39; === &#39;z&#39; // true &#39;\\172&#39; === &#39;z&#39; // true &#39;\\x7A&#39; === &#39;z&#39; // true &#39;\\u007A&#39; === &#39;z&#39; // true &#39;\\u{7A}&#39; === &#39;z&#39; // true codePointAt()JavaScript内部，字符以UTF-16的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode码点大于0xFFFF的字符），JavaScript会认为它们是两个字符。 var s = &quot;𠮷&quot;; s.length // 2 s.charAt(0) // &#39;&#39; s.charAt(1) // &#39;&#39; s.charCodeAt(0) // 55362 s.charCodeAt(1) // 57271 上面代码中，汉字“𠮷”（注意，这个字不是”吉祥“的”吉“）的码点是0x20BB7，UTF-16编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript不能正确处理，字符串长度会误判为2，而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。 ES6提供了codePointAt方法，能够正确处理4个字节储存的字符，返回一个字符的码点。 var s = &#39;𠮷a&#39;; s.codePointAt(0) // 134071 s.codePointAt(1) // 57271 s.codePointAt(2) // 97 codePointAt方法的参数，是字符在字符串中的位置（从0开始）。上面代码中，JavaScript将“𠮷a”视为三个字符，codePointAt方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同。 总之，codePointAt方法会正确返回32位的UTF-16字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。 codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下。 var s = &#39;𠮷a&#39;; s.codePointAt(0).toString(16) // &quot;20bb7&quot; s.codePointAt(2).toString(16) // &quot;61&quot; 你可能注意到了，codePointAt方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是1，但是必须向codePointAt方法传入2。解决这个问题的一个办法是使用for...of循环，因为它会正确识别32位的UTF-16字符。 var s = &#39;𠮷a&#39;; for (let ch of s) { console.log(ch.codePointAt(0).toString(16)); } // 20bb7 // 61 codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。 function is32Bit(c) { return c.codePointAt(0) &gt; 0xFFFF; } is32Bit(&quot;𠮷&quot;) // true is32Bit(&quot;a&quot;) // false String.fromCodePoint()ES5提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别32位的UTF-16字符（Unicode编号大于0xFFFF）。 String.fromCharCode(0x20BB7) // &quot;ஷ&quot; 上面代码中，String.fromCharCode不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。 ES6提供了String.fromCodePoint方法，可以识别0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。 String.fromCodePoint(0x20BB7) // &quot;𠮷&quot; String.fromCodePoint(0x78, 0x1f680, 0x79) === &#39;x\\uD83D\\uDE80y&#39; // true 上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。 注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。 字符串的遍历器接口ES6为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for...of循环遍历。 for (let codePoint of &#39;foo&#39;) { console.log(codePoint) } // &quot;f&quot; // &quot;o&quot; // &quot;o&quot; 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 var text = String.fromCodePoint(0x20BB7); for (let i = 0; i &lt; text.length; i++) { console.log(text[i]); } // &quot; &quot; // &quot; &quot; for (let i of text) { console.log(i); } // &quot;𠮷&quot; 上面代码中，字符串text只有一个字符，但是for循环会认为它包含两个字符（都不可打印），而for...of循环会正确识别出这一个字符。 at()ES5对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。 &#39;abc&#39;.charAt(0) // &quot;a&quot; &#39;𠮷&#39;.charAt(0) // &quot;\\uD842&quot; 上面代码中，charAt方法返回的是UTF-16编码的第一个字节，实际上是无法显示的。 目前，有一个提案，提出字符串实例的at方法，可以识别Unicode编号大于0xFFFF的字符，返回正确的字符。 &#39;abc&#39;.at(0) // &quot;a&quot; &#39;𠮷&#39;.at(0) // &quot;𠮷&quot; 这个方法可以通过垫片库实现。 normalize()许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\\u004F）和ˇ（\\u030C）合成Ǒ（\\u004F\\u030C）。 这两种表示方法，在视觉和语义上都等价，但是JavaScript不能识别。 &#39;\\u01D1&#39;===&#39;\\u004F\\u030C&#39; //false &#39;\\u01D1&#39;.length // 1 &#39;\\u004F\\u030C&#39;.length // 2 上面代码表示，JavaScript将合成字符视为两个字符，导致两种表示方法不相等。 ES6提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为Unicode正规化。 &#39;\\u01D1&#39;.normalize() === &#39;\\u004F\\u030C&#39;.normalize() // true normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。 NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。 &#39;\\u004F\\u030C&#39;.normalize(&#39;NFC&#39;).length // 1 &#39;\\u004F\\u030C&#39;.normalize(&#39;NFD&#39;).length // 2 上面代码表示，NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。 不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过Unicode编号区间判断。 includes(), startsWith(), endsWith()传统上，JavaScript只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在源字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在源字符串的尾部。 var s = &#39;Hello world!&#39;; s.startsWith(&#39;Hello&#39;) // true s.endsWith(&#39;!&#39;) // true s.includes(&#39;o&#39;) // true 这三个方法都支持第二个参数，表示开始搜索的位置。 var s = &#39;Hello world!&#39;; s.startsWith(&#39;world&#39;, 6) // true s.endsWith(&#39;Hello&#39;, 5) // true s.includes(&#39;Hello&#39;, 6) // false 上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。 &#39;x&#39;.repeat(3) // &quot;xxx&quot; &#39;hello&#39;.repeat(2) // &quot;hellohello&quot; &#39;na&#39;.repeat(0) // &quot;&quot; 参数如果是小数，会被取整。 &#39;na&#39;.repeat(2.9) // &quot;nana&quot; 如果repeat的参数是负数或者Infinity，会报错。 &#39;na&#39;.repeat(Infinity) // RangeError &#39;na&#39;.repeat(-1) // RangeError 但是，如果参数是0到-1之间的小数，则等同于0，这是因为会先进行取整运算。0到-1之间的小数，取整以后等于-0，repeat视同为0。 &#39;na&#39;.repeat(-0.9) // &quot;&quot; 参数NaN等同于0。 &#39;na&#39;.repeat(NaN) // &quot;&quot; 如果repeat的参数是字符串，则会先转换成数字。 &#39;na&#39;.repeat(&#39;na&#39;) // &quot;&quot; &#39;na&#39;.repeat(&#39;3&#39;) // &quot;nanana&quot; padStart()，padEnd()ES7推出了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart用于头部补全，padEnd用于尾部补全。 &#39;x&#39;.padStart(5, &#39;ab&#39;) // &#39;ababx&#39; &#39;x&#39;.padStart(4, &#39;ab&#39;) // &#39;abax&#39; &#39;x&#39;.padEnd(5, &#39;ab&#39;) // &#39;xabab&#39; &#39;x&#39;.padEnd(4, &#39;ab&#39;) // &#39;xaba&#39; 上面代码中，padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。 &#39;xxx&#39;.padStart(2, &#39;ab&#39;) // &#39;xxx&#39; &#39;xxx&#39;.padEnd(2, &#39;ab&#39;) // &#39;xxx&#39; 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。 &#39;abc&#39;.padStart(10, &#39;0123456789&#39;) // &#39;0123456abc&#39; 如果省略第二个参数，则会用空格补全长度。 &#39;x&#39;.padStart(4) // &#39; x&#39; &#39;x&#39;.padEnd(4) // &#39;x &#39; padStart的常见用途是为数值补全指定位数。下面代码生成10位的数值字符串。 &#39;1&#39;.padStart(10, &#39;0&#39;) // &quot;0000000001&quot; &#39;12&#39;.padStart(10, &#39;0&#39;) // &quot;0000000012&quot; &#39;123456&#39;.padStart(10, &#39;0&#39;) // &quot;0000123456&quot; 另一个用途是提示字符串格式。 &#39;12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-MM-12&quot; &#39;09-12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-09-12&quot; 模板字符串传统的JavaScript语言，输出模板通常是这样写的。 $(&#39;#result&#39;).append( &#39;There are &lt;b&gt;&#39; + basket.count + &#39;&lt;/b&gt; &#39; + &#39;items in your basket, &#39; + &#39;&lt;em&gt;&#39; + basket.onSale + &#39;&lt;/em&gt; are on sale!&#39; ); 上面这种写法相当繁琐不方便，ES6引入了模板字符串解决这个问题。 $(&#39;#result&#39;).append(` There are &lt;b&gt;${basket.count}&lt;/b&gt; items in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt; are on sale! `); 模板字符串（template string）是增强版的字符串，用反引号（&#96;）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 // 普通字符串 `In JavaScript &#39;\\n&#39; is a line-feed.` // 多行字符串 `In JavaScript this is not legal.` console.log(`string text line 1 string text line 2`); // 字符串中嵌入变量 var name = &quot;Bob&quot;, time = &quot;today&quot;; `Hello ${name}, how are you ${time}?` 上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 var greeting = `\\`Yo\\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 $(&#39;#list&#39;).html(` &lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;/ul&gt; `); 上面代码中，所有模板字符串的空格和换行，都是被保留的，比如&lt;ul&gt;标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。 $(&#39;#list&#39;).html(` &lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt; &lt;/ul&gt; `.trim()); 模板字符串中嵌入变量，需要将变量名写在${}之中。 function authorize(user, action) { if (!user.hasPrivilege(action)) { throw new Error( // 传统写法为 // &#39;User &#39; // + user.name // + &#39; is not authorized to do &#39; // + action // + &#39;.&#39; `User ${user.name} is not authorized to do ${action}.`); } } 大括号内部可以放入任意的JavaScript表达式，可以进行运算，以及引用对象属性。 var x = 1; var y = 2; `${x} + ${y} = ${x + y}` // &quot;1 + 2 = 3&quot; `${x} + ${y * 2} = ${x + y * 2}` // &quot;1 + 4 = 5&quot; var obj = {x: 1, y: 2}; `${obj.x + obj.y}` // 3 模板字符串之中还能调用函数。 function fn() { return &quot;Hello World&quot;; } `foo ${fn()} bar` // foo Hello World bar 如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。 如果模板字符串中的变量没有声明，将报错。 // 变量place没有声明 var msg = `Hello, ${place}`; // 报错 由于模板字符串的大括号内部，就是执行JavaScript代码，因此如果大括号内部是一个字符串，将会原样输出。 `Hello ${&#39;World&#39;}` // &quot;Hello World&quot; 模板字符串甚至还能嵌套。 const tmpl = addrs =&gt; ` &lt;table&gt; ${addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt; `).join(&#39;&#39;)} &lt;/table&gt; `; 上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。 const data = [ { first: &#39;&lt;Jane&gt;&#39;, last: &#39;Bond&#39; }, { first: &#39;Lars&#39;, last: &#39;&lt;Croft&gt;&#39; }, ]; console.log(tmpl(data)); // &lt;table&gt; // // &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt; // &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt; // // &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt; // &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt; // // &lt;/table&gt; 如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。 // 写法一 let str = &#39;return &#39; + &#39;`Hello ${name}!`&#39;; let func = new Function(&#39;name&#39;, str); func(&#39;Jack&#39;) // &quot;Hello Jack!&quot; // 写法二 let str = &#39;(name) =&gt; `Hello ${name}!`&#39;; let func = eval.call(null, str); func(&#39;Jack&#39;) // &quot;Hello Jack!&quot; 实例：模板编译下面，我们来看一个通过模板字符串，生成正式模板的实例。 var template = ` &lt;ul&gt; &lt;% for(var i=0; i &lt; data.supplies.length; i++) { %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% } %&gt; &lt;/ul&gt; `; 上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%...%&gt;放置JavaScript代码，使用&lt;%= ... %&gt;输出JavaScript表达式。 怎么编译这个模板字符串呢？ 一种思路是将其转换为JavaScript表达式字符串。 echo(&#39;&lt;ul&gt;&#39;); for(var i=0; i &lt; data.supplies.length; i++) { echo(&#39;&lt;li&gt;&#39;); echo(data.supplies[i]); echo(&#39;&lt;/li&gt;&#39;); }; echo(&#39;&lt;/ul&gt;&#39;); 这个转换使用正则表达式就行了。 var evalExpr = /&lt;%=(.+?)%&gt;/g; var expr = /&lt;%([\\s\\S]+?)%&gt;/g; template = template .replace(evalExpr, &#39;`); \\n echo( $1 ); \\n echo(`&#39;) .replace(expr, &#39;`); \\n $1 \\n echo(`&#39;); template = &#39;echo(`&#39; + template + &#39;`);&#39;; 然后，将template封装在一个函数里面返回，就可以了。 var script = `(function parse(data){ var output = &quot;&quot;; function echo(html){ output += html; } ${ template } return output; })`; return script; 将上面的内容拼装成一个模板编译函数compile。 function compile(template){ var evalExpr = /&lt;%=(.+?)%&gt;/g; var expr = /&lt;%([\\s\\S]+?)%&gt;/g; template = template .replace(evalExpr, &#39;`); \\n echo( $1 ); \\n echo(`&#39;) .replace(expr, &#39;`); \\n $1 \\n echo(`&#39;); template = &#39;echo(`&#39; + template + &#39;`);&#39;; var script = `(function parse(data){ var output = &quot;&quot;; function echo(html){ output += html; } ${ template } return output; })`; return script; } compile函数的用法如下。 var parse = eval(compile(template)); div.innerHTML = parse({ supplies: [ &quot;broom&quot;, &quot;mop&quot;, &quot;cleaner&quot; ] }); // &lt;ul&gt; // &lt;li&gt;broom&lt;/li&gt; // &lt;li&gt;mop&lt;/li&gt; // &lt;li&gt;cleaner&lt;/li&gt; // &lt;/ul&gt; 标签模板模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 alert`123` // 等同于 alert(123) 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 var a = 5; var b = 10; tag`Hello ${ a + b } world ${ a * b }`; // 等同于 tag([&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;], 15, 50); 上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。 函数tag依次会接收到多个参数。 function tag(stringArr, value1, value2){ // ... } // 等同于 function tag(stringArr, ...values){ // ... } tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。 tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。 tag函数所有参数的实际值如下。 第一个参数：[&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;] 第二个参数: 15 第三个参数：50 也就是说，tag函数实际上以下面的形式调用。 tag([&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;], 15, 50) 我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。 var a = 5; var b = 10; function tag(s, v1, v2) { console.log(s[0]); console.log(s[1]); console.log(s[2]); console.log(v1); console.log(v2); return &quot;OK&quot;; } tag`Hello ${ a + b } world ${ a * b}`; // &quot;Hello &quot; // &quot; world &quot; // &quot;&quot; // 15 // 50 // &quot;OK&quot; 下面是一个更复杂的例子。 var total = 30; var msg = passthru`The total is ${total} (${total*1.05} with tax)`; function passthru(literals) { var result = &#39;&#39;; var i = 0; while (i &lt; literals.length) { result += literals[i++]; if (i &lt; arguments.length) { result += arguments[i]; } } return result; } msg // &quot;The total is 30 (31.5 with tax)&quot; 上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。 passthru函数采用rest参数的写法如下。 function passthru(literals, ...values) { var output = &quot;&quot;; for (var index = 0; index &lt; values.length; index++) { output += literals[index] + values[index]; } output += literals[index] return output; } “标签模板”的一个重要应用，就是过滤HTML字符串，防止用户输入恶意内容。 var message = SaferHTML`&lt;p&gt;${sender} has sent you a message.&lt;/p&gt;`; function SaferHTML(templateData) { var s = templateData[0]; for (var i = 1; i &lt; arguments.length; i++) { var arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;) .replace(/&lt;/g, &quot;&amp;lt;&quot;) .replace(/&gt;/g, &quot;&amp;gt;&quot;); // Don&#39;t escape special characters in the template. s += templateData[i]; } return s; } 上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。 var sender = &#39;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#39;; // 恶意代码 var message = SaferHTML`&lt;p&gt;${sender} has sent you a message.&lt;/p&gt;`; message // &lt;p&gt;&amp;lt;script&amp;gt;alert(&quot;abc&quot;)&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt; 标签模板的另一个应用，就是多语言转换（国际化处理）。 i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!` // &quot;欢迎访问xxx，您是第xxxx位访问者！&quot; 模板字符串本身并不能取代Mustache之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。 // 下面的hashTemplate函数 // 是一个自定义的模板处理函数 var libraryHtml = hashTemplate` &lt;ul&gt; #for book in ${myBooks} &lt;li&gt;&lt;i&gt;#{book.title}&lt;/i&gt; by #{book.author}&lt;/li&gt; #end &lt;/ul&gt; `; 除此之外，你甚至可以使用标签模板，在JavaScript语言之中嵌入其他语言。 jsx` &lt;div&gt; &lt;input ref=&#39;input&#39; onChange=&#39;${this.handleChange}&#39; defaultValue=&#39;${this.state.value}&#39; /&gt; ${this.state.value} &lt;/div&gt; ` 上面的代码通过jsx函数，将一个DOM字符串转为React对象。你可以在Github找到jsx函数的具体实现。 下面则是一个假想的例子，通过java函数，在JavaScript代码之中运行Java代码。 java` class HelloWorldApp { public static void main(String[] args) { System.out.println(“Hello World!”); // Display the string. } } ` HelloWorldApp.main(); 模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。 console.log`123` // [&quot;123&quot;, raw: Array[1]] 上面代码中，console.log接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。 请看下面的例子。 tag`First line\\nSecond line` function tag(strings) { console.log(strings.raw[0]); // &quot;First line\\\\nSecond line&quot; } 上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[&quot;First line\\nSecond line&quot;]，那么strings.raw数组就是[&quot;First line\\\\nSecond line&quot;]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw数组会将\\n视为\\\\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。 String.raw()ES6还为原生的String对象，提供了一个raw方法。 String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。 String.raw`Hi\\n${2+3}!`; // &quot;Hi\\\\n5!&quot; String.raw`Hi\\u000A!`; // &#39;Hi\\\\u000A!&#39; 如果原字符串的斜杠已经转义，那么String.raw不会做任何处理。 String.raw`Hi\\\\n` // &quot;Hi\\\\n&quot; String.raw的代码基本如下。 String.raw = function (strings, ...values) { var output = &quot;&quot;; for (var index = 0; index &lt; values.length; index++) { output += strings.raw[index] + values[index]; } output += strings.raw[index] return output; } String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。 String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。 String.raw({ raw: &#39;test&#39; }, 0, 1, 2); // &#39;t0e1s2t&#39; // 等同于 String.raw({ raw: [&#39;t&#39;,&#39;e&#39;,&#39;s&#39;,&#39;t&#39;] }, 0, 1, 2); 模板字符串的限制前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，因此导致了无法嵌入其他语言。 举例来说，在标签模板里面可以嵌入Latex语言。 function latex(strings) { // ... } let document = latex` \\newcommand{\\fun}{\\textbf{Fun!}} // 正常工作 \\newcommand{\\unicode}{\\textbf{Unicode!}} // 报错 \\newcommand{\\xerxes}{\\textbf{King!}} // 报错 Breve over the h goes \\u{h}ere // 报错 ` 上面代码中，变量document内嵌的模板字符串，对于Latex语言来说完全是合法的，但是JavaScript引擎会报错。原因就在于字符串的转义。 模板字符串会将\\u00FF和\\u{42}当作Unicode字符进行转义，所以\\unicode解析时报错；而\\x56会被当作十六进制字符串转义，所以\\xerxes会报错。 为了解决这个问题，现在有一个提案，放松对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。 function tag(strs) { strs[0] === undefined strs.raw[0] === &quot;\\\\unicode and \\\\u{55}&quot;; } tag`\\unicode and \\u{55}` 上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript引擎将第一个字符设置为undefined，但是raw属性依然可以得到原始字符串，因此tag函数还是可以对原字符串进行处理。 注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。 let bad = `bad escape sequence: \\unicode`; // 报错","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Unicode","slug":"Unicode","permalink":"https://microzz.com/tags/Unicode/"}]},{"title":"变量的解构赋值(Destructuring)","date":"2016-11-13T07:16:19.000Z","path":"2016/11/13/destructuring/","text":"变量的解构赋值数组的解构赋值基本用法ES6允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。 var a = 1; var b = 2; var c = 3; ES6允许写成下面这样。 var [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。 let [foo, [[bar], baz]] = [1, [[2], 3]]; foo // 1 bar // 2 baz // 3 let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;]; third // &quot;baz&quot; let [x, , y] = [1, 2, 3]; x // 1 y // 3 let [head, ...tail] = [1, 2, 3, 4]; head // 1 tail // [2, 3, 4] let [x, y, ...z] = [&#39;a&#39;]; x // &quot;a&quot; y // undefined z // [] 如果解构不成功，变量的值就等于undefined。 var [foo] = []; var [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 let [x, y] = [1, 2, 3]; x // 1 y // 2 let [a, [b], d] = [1, [2, 3], 4]; a // 1 b // 2 d // 4 上面两个例子，都属于不完全解构，但是可以成功。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。 // 报错 let [foo] = 1; let [foo] = false; let [foo] = NaN; let [foo] = undefined; let [foo] = null; let [foo] = {}; 上面的表达式都会报错，因为等号右边的值，要么转为对象以后不具备Iterator接口（前五个表达式），要么本身就不具备Iterator接口（最后一个表达式）。 解构赋值不仅适用于var命令，也适用于let和const命令。 var [v1, v2, ..., vN ] = array; let [v1, v2, ..., vN ] = array; const [v1, v2, ..., vN ] = array; 对于Set结构，也可以使用数组的解构赋值。 let [x, y, z] = new Set([&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]); x // &quot;a&quot; 事实上，只要某种数据结构具有Iterator接口，都可以采用数组形式的解构赋值。 function* fibs() { var a = 0; var b = 1; while (true) { yield a; [a, b] = [b, a + b]; } } var [first, second, third, fourth, fifth, sixth] = fibs(); sixth // 5 上面代码中，fibs是一个Generator函数，原生具有Iterator接口。解构赋值会依次从这个接口获取值。 默认值解构赋值允许指定默认值。 var [foo = true] = []; foo // true [x, y = &#39;b&#39;] = [&#39;a&#39;]; // x=&#39;a&#39;, y=&#39;b&#39; [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // x=&#39;a&#39;, y=&#39;b&#39; 注意，ES6内部使用严格相等运算符（===），判断一个位置是否有值。所以，如果一个数组成员不严格等于undefined，默认值是不会生效的。 var [x = 1] = [undefined]; x // 1 var [x = 1] = [null]; x // null 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 function f() { console.log(&#39;aaa&#39;); } let [x = f()] = [1]; 上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。 let x; if ([1][0] === undefined) { x = f(); } else { x = [1][0]; } 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 let [x = 1, y = x] = []; // x=1; y=1 let [x = 1, y = x] = [2]; // x=2; y=2 let [x = 1, y = x] = [1, 2]; // x=1; y=2 let [x = y, y = 1] = []; // ReferenceError 上面最后一个表达式之所以会报错，是因为x用到默认值y时，y还没有声明。 对象的解构赋值解构不仅可以用于数组，还可以用于对象。 var { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; foo // &quot;aaa&quot; bar // &quot;bbb&quot; 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 var { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; foo // &quot;aaa&quot; bar // &quot;bbb&quot; var { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; baz // undefined 上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。 如果变量名与属性名不一致，必须写成下面这样。 var { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; }; baz // &quot;aaa&quot; let obj = { first: &#39;hello&#39;, last: &#39;world&#39; }; let { first: f, last: l } = obj; f // &#39;hello&#39; l // &#39;world&#39; 这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。 var { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 var { foo: baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; }; baz // &quot;aaa&quot; foo // error: foo is not defined 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 注意，采用这种写法时，变量的声明和赋值是一体的。对于let和const来说，变量不能重新声明，所以一旦赋值的变量以前声明过，就会报错。 let foo; let {foo} = {foo: 1}; // SyntaxError: Duplicate declaration &quot;foo&quot; let baz; let {bar: baz} = {bar: 1}; // SyntaxError: Duplicate declaration &quot;baz&quot; 上面代码中，解构赋值的变量都会重新声明，所以报错了。不过，因为var命令允许重新声明，所以这个错误只会在使用let和const命令时出现。如果没有第二个let命令，上面的代码就不会报错。 let foo; ({foo} = {foo: 1}); // 成功 let baz; ({bar: baz} = {bar: 1}); // 成功 上面代码中，let命令下面一行的圆括号是必须的，否则会报错。因为解析器会将起首的大括号，理解成一个代码块，而不是赋值语句。 和数组一样，解构也可以用于嵌套结构的对象。 var obj = { p: [ &#39;Hello&#39;, { y: &#39;World&#39; } ] }; var { p: [x, { y }] } = obj; x // &quot;Hello&quot; y // &quot;World&quot; 注意，这时p是模式，不是变量，因此不会被赋值。 var node = { loc: { start: { line: 1, column: 5 } } }; var { loc: { start: { line }} } = node; line // 1 loc // error: loc is undefined start // error: start is undefined 上面代码中，只有line是变量，loc和start都是模式，不会被赋值。 下面是嵌套赋值的例子。 let obj = {}; let arr = []; ({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true }); obj // {prop:123} arr // [true] 对象的解构也可以指定默认值。 var {x = 3} = {}; x // 3 var {x, y = 5} = {x: 1}; x // 1 y // 5 var {x:y = 3} = {}; y // 3 var {x:y = 3} = {x: 5}; y // 5 var { message: msg = &#39;Something went wrong&#39; } = {}; msg // &quot;Something went wrong&quot; 默认值生效的条件是，对象的属性值严格等于undefined。 var {x = 3} = {x: undefined}; x // 3 var {x = 3} = {x: null}; x // null 上面代码中，如果x属性等于null，就不严格相等于undefined，导致默认值不会生效。 如果解构失败，变量的值等于undefined。 var {foo} = {bar: &#39;baz&#39;}; foo // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 // 报错 var {foo: {bar}} = {baz: &#39;baz&#39;}; 上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。 var _tmp = {baz: &#39;baz&#39;}; _tmp.foo.bar // 报错 如果要将一个已经声明的变量用于解构赋值，必须非常小心。 // 错误的写法 var x; {x} = {x: 1}; // SyntaxError: syntax error 上面代码的写法会报错，因为JavaScript引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免JavaScript将其解释为代码块，才能解决这个问题。 // 正确的写法 ({x} = {x: 1}); 上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。 解构赋值允许，等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。 ({} = [true, false]); ({} = &#39;abc&#39;); ({} = []); 上面的表达式虽然毫无意义，但是语法是合法的，可以执行。 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。 let { log, sin, cos } = Math; 上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 var arr = [1, 2, 3]; var {0 : first, [arr.length - 1] : last} = arr; first // 1 last // 3 上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”，参见《对象的扩展》一章。 字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 const [a, b, c, d, e] = &#39;hello&#39;; a // &quot;h&quot; b // &quot;e&quot; c // &quot;l&quot; d // &quot;l&quot; e // &quot;o&quot; 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 let {length : len} = &#39;hello&#39;; len // 5 数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 let {toString: s} = 123; s === Number.prototype.toString // true let {toString: s} = true; s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 let { prop: x } = undefined; // TypeError let { prop: y } = null; // TypeError 函数参数的解构赋值函数的参数也可以使用解构赋值。 function add([x, y]){ return x + y; } add([1, 2]); // 3 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。 下面是另一个例子。 [[1, 2], [3, 4]].map(([a, b]) =&gt; a + b); // [ 3, 7 ] 函数参数的解构也可以使用默认值。 function move({x = 0, y = 0} = {}) { return [x, y]; } move({x: 3, y: 8}); // [3, 8] move({x: 3}); // [3, 0] move({}); // [0, 0] move(); // [0, 0] 上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。 注意，下面的写法会得到不一样的结果。 function move({x, y} = { x: 0, y: 0 }) { return [x, y]; } move({x: 3, y: 8}); // [3, 8] move({x: 3}); // [3, undefined] move({}); // [undefined, undefined] move(); // [0, 0] 上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 undefined就会触发函数参数的默认值。 [1, undefined, 3].map((x = &#39;yes&#39;) =&gt; x); // [ 1, &#39;yes&#39;, 3 ] 圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 不能使用圆括号的情况以下三种解构赋值不得使用圆括号。 （1）变量声明语句中，不能带有圆括号。 // 全部报错 var [(a)] = [1]; var {x: (c)} = {}; var ({x: c}) = {}; var {(x: c)} = {}; var {(x): c} = {}; var { o: ({ p: p }) } = { o: { p: 2 } }; 上面三个语句都会报错，因为它们都是变量声明语句，模式不能使用圆括号。 （2）函数参数中，模式不能带有圆括号。 函数参数也属于变量声明，因此不能带有圆括号。 // 报错 function f([(z)]) { return z; } （3）赋值语句中，不能将整个模式，或嵌套模式中的一层，放在圆括号之中。 // 全部报错 ({ p: a }) = { p: 42 }; ([a]) = [5]; 上面代码将整个模式放在圆括号之中，导致报错。 // 报错 [({ p: a }), { x: c }] = [{}, {}]; 上面代码将嵌套模式的一层，放在圆括号之中，导致报错。 可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。 [(b)] = [3]; // 正确 ({ p: (d) } = {}); // 正确 [(parseInt.prop)] = [3]; // 正确 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 用途变量的解构赋值用途很多。 （1）交换变量的值 [x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 （2）从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 // 返回一个数组 function example() { return [1, 2, 3]; } var [a, b, c] = example(); // 返回一个对象 function example() { return { foo: 1, bar: 2 }; } var { foo, bar } = example(); （3）函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。 // 参数是一组有次序的值 function f([x, y, z]) { ... } f([1, 2, 3]); // 参数是一组无次序的值 function f({x, y, z}) { ... } f({z: 3, y: 2, x: 1}); （4）提取JSON数据 解构赋值对提取JSON对象中的数据，尤其有用。 var jsonData = { id: 42, status: &quot;OK&quot;, data: [867, 5309] }; let { id, status, data: number } = jsonData; console.log(id, status, number); // 42, &quot;OK&quot;, [867, 5309] 上面代码可以快速提取JSON数据的值。 （5）函数参数的默认值 jQuery.ajax = function (url, { async = true, beforeSend = function () {}, cache = true, complete = function () {}, crossDomain = false, global = true, // ... more config }) { // ... do stuff }; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || &#39;default foo&#39;;这样的语句。 （6）遍历Map结构 任何部署了Iterator接口的对象，都可以用for...of循环遍历。Map结构原生支持Iterator接口，配合变量的解构赋值，获取键名和键值就非常方便。 var map = new Map(); map.set(&#39;first&#39;, &#39;hello&#39;); map.set(&#39;second&#39;, &#39;world&#39;); for (let [key, value] of map) { console.log(key + &quot; is &quot; + value); } // first is hello // second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 // 获取键名 for (let [key] of map) { // ... } // 获取键值 for (let [,value] of map) { // ... } （7）输入模块的指定方法 加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰。 const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;); 感谢阮一峰老师的原创，本分享仅供学习交流","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"Destructuring","slug":"Destructuring","permalink":"https://microzz.com/tags/Destructuring/"}]},{"title":"let和const命令","date":"2016-11-12T07:16:19.000Z","path":"2016/11/12/let/","text":"let和const命令let命令基本用法ES6新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 { let a = 10; var b = 1; } a // ReferenceError: a is not defined. b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 for循环的计数器，就很合适使用let命令。 for (let i = 0; i &lt; 10; i++) {} console.log(i); //ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 var a = []; for (var i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 10 上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是6。 var a = []; for (let i = 0; i &lt; 10; i++) { a[i] = function () { console.log(i); }; } a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 不存在变量提升let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。 // var 的情况 console.log(foo); // 输出undefined var foo = 2; // let 的情况 console.log(bar); // 报错ReferenceError let bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 var tmp = 123; if (true) { tmp = &#39;abc&#39;; // ReferenceError let tmp; } 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 if (true) { // TDZ开始 tmp = &#39;abc&#39;; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123 } 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 typeof x; // ReferenceError let x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 typeof undeclared_variable // &quot;undefined&quot; 上面代码中，undeclared_variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 有些“死区”比较隐蔽，不太容易发现。 function bar(x = y, y = 2) { return [x, y]; } bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。 function bar(x = 2, y = x) { return [x, y]; } bar(); // [2, 2] ES6规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在ES5是很常见的，现在有了这种规定，避免此类错误就很容易了。 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 // 报错 function () { let a = 10; var a = 1; } // 报错 function () { let a = 10; let a = 1; } 因此，不能在函数内部重新声明参数。 function func(arg) { let arg; // 报错 } function func(arg) { { let arg; // 不报错 } } 块级作用域为什么需要块级作用域？ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。 var tmp = new Date(); function f() { console.log(tmp); if (false) { var tmp = &quot;hello world&quot;; } } f(); // undefined 上面代码中，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。 var s = &#39;hello&#39;; for (var i = 0; i &lt; s.length; i++) { console.log(s[i]); } console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6的块级作用域let实际上为JavaScript新增了块级作用域。 function f1() { let n = 5; if (true) { let n = 10; } console.log(n); // 5 } 上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响。如果使用var定义变量n，最后输出的值就是10。 ES6允许块级作用域的任意嵌套。 {{{{{let insane = 'Hello World'}}}}}; 上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。 {{{{ {let insane = 'Hello World'} console.log(insane); // 报错 }}}}; 内层作用域可以定义外层作用域的同名变量。 {{{{ let insane = 'Hello World'; {let insane = 'Hello World'} }}}}; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。 // IIFE 写法 (function () { var tmp = ...; ... }()); // 块级作用域写法 { let tmp = ...; ... } 块级作用域与函数声明函数能不能在块级作用域之中声明，是一个相当令人混淆的问题。 ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 // 情况一 if (true) { function f() {} } // 情况二 try { function f() {} } catch(e) { } 上面代码的两种函数声明，根据ES5的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。不过，“严格模式”下还是会报错。 // ES5严格模式 &#39;use strict&#39;; if (true) { function f() {} } // 报错 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。 // ES6严格模式 &#39;use strict&#39;; if (true) { function f() {} } // 不报错 ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 function f() { console.log(&#39;I am outside!&#39;); } (function () { if (false) { // 重复声明一次函数f function f() { console.log(&#39;I am inside!&#39;); } } f(); }()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。 // ES5版本 function f() { console.log(&#39;I am outside!&#39;); } (function () { function f() { console.log(&#39;I am inside!&#39;); } if (false) { } f(); }()); ES6 的运行结果就完全不一样了，会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响，实际运行的代码如下。 // ES6版本 function f() { console.log(&#39;I am outside!&#39;); } (function () { f(); }()); 很显然，这种行为差异会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 注意，上面三条规则只对ES6的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 前面那段代码，在 Chrome 环境下运行会报错。 // ES6的浏览器环境 function f() { console.log(&#39;I am outside!&#39;); } (function () { if (false) { // 重复声明一次函数f function f() { console.log(&#39;I am inside!&#39;); } } f(); }()); // Uncaught TypeError: f is not a function 上面的代码报错，是因为实际运行的是下面的代码。 // ES6的浏览器环境 function f() { console.log(&#39;I am outside!&#39;); } (function () { var f = undefined; if (false) { function f() { console.log(&#39;I am inside!&#39;); } } f(); }()); // Uncaught TypeError: f is not a function 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 // 函数声明语句 { let a = &#39;secret&#39;; function f() { return a; } } // 函数表达式 { let a = &#39;secret&#39;; let f = function () { return a; }; } 另外，还有一个需要注意的地方。ES6的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。 // 不报错 &#39;use strict&#39;; if (true) { function f() {} } // 报错 &#39;use strict&#39;; if (true) function f() {} do 表达式本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。 { let t = f(); t = t * t + 1; } 上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到t的值，因为块级作用域不返回值，除非t是全局变量。 现在有一个提案，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上do，使它变为do表达式。 let x = do { let t = f(); t * t + 1; }; 上面代码中，变量x会得到整个块级作用域的返回值。 const命令const声明一个只读的常量。一旦声明，常量的值就不能改变。 const PI = 3.1415; PI // 3.1415 PI = 3; // TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 const foo; // SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 if (true) { const MAX = 5; } MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 if (true) { console.log(MAX); // ReferenceError const MAX = 5; } 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。 var message = &quot;Hello!&quot;; let age = 25; // 以下两行都会报错 const message = &quot;Goodbye!&quot;; const age = 30; 对于复合类型的变量，变量名不指向数据，而是指向数据所在的地址。const命令只是保证变量名指向的地址不变，并不保证该地址的数据不变，所以将一个对象声明为常量必须非常小心。 const foo = {}; foo.prop = 123; foo.prop // 123 foo = {}; // TypeError: &quot;foo&quot; is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。 const a = []; a.push(&#39;Hello&#39;); // 可执行 a.length = 0; // 可执行 a = [&#39;Dave&#39;]; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。 如果真的想将对象冻结，应该使用Object.freeze方法。 const foo = Object.freeze({}); // 常规模式时，下面一行不起作用； // 严格模式时，该行会报错 foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。 var constantize = (obj) =&gt; { Object.freeze(obj); Object.keys(obj).forEach( (key, value) =&gt; { if ( typeof obj[key] === &#39;object&#39; ) { constantize( obj[key] ); } }); }; ES5只有两种声明变量的方法：var命令和function命令。ES6除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6一共有6种声明变量的方法。 顶层对象的属性顶层对象，在浏览器环境指的是window对象，在Node指的是global对象。ES5之中，顶层对象的属性与全局变量是等价的。 window.a = 1; a // 1 a = 2; window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是JavaScript语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从ES6开始，全局变量将逐步与顶层对象的属性脱钩。 var a = 1; // 如果在Node的REPL环境，可以写成global.a // 或者采用通用方法，写成this.a window.a // 1 let b = 1; window.b // undefined 上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 global 对象ES5的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是Node没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node模块和ES6模块中，this返回的是当前模块。 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function(&#39;return this&#39;)()，总是会返回全局对象。但是，如果浏览器用了CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。 综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。 // 方法一 (typeof window !== &#39;undefined&#39; ? window : (typeof process === &#39;object&#39; &amp;&amp; typeof require === &#39;function&#39; &amp;&amp; typeof global === &#39;object&#39;) ? global : this); // 方法二 var getGlobal = function () { if (typeof self !== &#39;undefined&#39;) { return self; } if (typeof window !== &#39;undefined&#39;) { return window; } if (typeof global !== &#39;undefined&#39;) { return global; } throw new Error(&#39;unable to locate global object&#39;); }; 现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。 垫片库system.global模拟了这个提案，可以在所有环境拿到global。 // CommonJS的写法 require(&#39;system.global/shim&#39;)(); // ES6模块的写法 import shim from &#39;system.global/shim&#39;; shim(); 上面代码可以保证各种环境里面，global对象都是存在的。 // CommonJS的写法 var global = require(&#39;system.global&#39;)(); // ES6模块的写法 import getGlobal from &#39;system.global&#39;; const global = getGlobal(); 上面代码将顶层对象放入变量global。 关于内容来自阮一峰老师的《ES6标准入门》，感谢","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"ES6","slug":"ES6","permalink":"https://microzz.com/tags/ES6/"},{"name":"ECMAScript6","slug":"ECMAScript6","permalink":"https://microzz.com/tags/ECMAScript6/"},{"name":"const","slug":"const","permalink":"https://microzz.com/tags/const/"},{"name":"let","slug":"let","permalink":"https://microzz.com/tags/let/"}]},{"title":"JavaScript编码规范指南","date":"2016-10-01T01:26:09.000Z","path":"2016/10/01/javascript-code-style/","text":"Airbnb的JavaScript编码规范指南=====================常用的一些javascript规范 数据类型 原始类型(Primitives)：当你给一个原始类型赋值时，返回的是这个值的本身。 string number boolean null undefined var foo = 1, bar = foo; bar = 9; console.log(foo, bar); // =&gt; 1, 9 对象类型:当你给一个对象类型赋值时，返回的是这个值的引用。 object array function var foo = [1, 2], bar = foo; bar[0] = 9; console.log(foo[0], bar[0]); // =&gt; 9, 9 对象 新建一个对象的语法 //不推荐 var item = new Object(); //推荐 var item = {}; 不要使用保留字作为键值，否则在IE8下面会出现问题(详情)。 //不推荐 var superman = { default: { clark: &#39;kent&#39;}, private: true }; //推荐 var superman ={ defaults: { clark: &#39;kent&#39;}, hidden: true }; 使用可读性强的同义词代替保留字 //不推荐 var superman = { class: &#39;alien&#39; }; //不推荐 var superman = { klass: &#39;alien&#39; }; //推荐 var superman = { type: &#39;alien&#39; }; 数组 新建一个数组的语法 //不推荐 var items = new Array(); //推荐 var items = []; 如果你不知道数组的长度可以使用push将元素加入。 var someStack = []; //不推荐 someStack[someStack.length] = &#39;something&#39;; //推荐 someStack.push(&#39;something&#39;); 当你需要复制一个数组的时候使用slice。jsPerf var len = items.length, itemsCopy = [], i; //不推荐 for (i = 0; i &lt; len; i++){ itemsCopy[i] = items[i]; } //推荐 itemsCopy = items.slice(); 用slice转换伪数组对象到数组 function trigger() { var args = Array.prototype.slice.call(arguments); ... } String类型 使用单引号&#39;&#39; //不推荐 var name = &quot;Bob Parr&quot;; //推荐 var name = &#39;Bob Parr&#39;; //不推荐 var fullName - &quot;Bob &quot; + this.lastName; //推荐 var fullName = &#39;Bob &#39; + this.lastName; 当字符串长度超过80个时，应该通过字符串连接多行显示。 注意：过度使用字符串连接将会影响性能。jsPerf&amp;Discussion //不推荐 var errorMessage = &#39;This is a super long error that was thrown because of Batman. When you stop to think about how Batman had anything to do with this, you would get nowhere fast.&#39;; //不推荐 var errorMessage = &#39;This is a super long error that \\ was thrown because of Batman. \\ When you stop to think about \\ how Batman had anything to do \\ with this, you would get nowhere \\ fast.&#39;; //推荐 var errorMessage = &#39;This is a super long error that &#39; + &#39;was thrown because of Batman.&#39; + &#39;When you stop to think about &#39; + &#39;how Batman had anything to do &#39; + &#39;with this, you would get nowhere &#39; + &#39;fast.&#39;; 当程序建立一个字符串时， 使用join代替字符串连接。特别是在IE下：jsPerf var items, messages, length, i; messages = [{ state: &#39;success&#39;, message: &#39;This one worked.&#39; },{ state: &#39;success&#39;, message: &#39;This one worked as well.&#39; },{ state: &#39;error&#39;, message: &#39;This one did not work.&#39; }]; length = messages.length; // 不推荐 function inbox(messages) { items = &#39;&lt;ul&gt;&#39;; for (i = 0; i &lt; length; i++) { items += &#39;&lt;li&gt;&#39; + messages[i].message + &#39;&lt;/li&gt;&#39;; } return items + &#39;&lt;/ul&gt;&#39;; } // 推荐 function inbox(messages) { items = []; for (i = 0; i &lt; length; i++) { items[i] = messages[i].message; } return &#39;&lt;ul&gt;&lt;li&gt;&#39; + items.join(&#39;&lt;/li&gt;&lt;li&gt;&#39;) + &#39;&lt;/li&gt;&lt;/ul&gt;&#39;; } 函数 函数表达式： // 匿名函数表达式 var anonymous = function(){ return true; } // 命名函数表达式 var named = function named() { return true; }; // 立即执行的函数表达式（IIFE） (function(){ console.log(&#39;Welcome to the Internet. Please follow me.&#39;); })(); 不要将函数声明放在如if/while循环或其他任何语句中。但可以用函数表达式来替代函数声明这么做。一些浏览器可能的确可以在语句中使用函数声明。但是在解析方面的处理各不相同，各种浏览器下兼容性很不好。 注意: ECMA-262定义了一系列的语句，但是函数声明并没有被归类为真正的语句。关于这点可查看ECMA-262的文档 //不推荐 if (currentUser){ function test() { console.log(&#39;Nope.&#39;); } } //推荐 if (currentUser){ var test = function test() { console.log(&#39;Yup.&#39;); } } arguments 不能作为一个参数的名字， 因为这会覆盖每一个函数内的arguments对象。 //不推荐 function nope(name, options, arguments) { // ...stuff... } //推荐 function yup(name, options, args) { // ...stuff... } 属性 访问一个属性时，使用点的形式取值。 var luke = { jedi: true, age: 28 }; // 不推荐 var isJedi = luke[&#39;jedi&#39;]; // 推荐 var isJedi = luke.jedi; 需要一个变量访问一个属性时，使用“[]”来取值。 var luke = { jedi: true, age: 28 }; function getProp(prop) { return luke[prop]; } var isJedi = getProp(&#39;jedi&#39;); 变量 总是使用 var 来定义变量。如果不这么做将定义一个全局变量出来。我们希望避免全局命名空间的污染。 // 不推荐 superPower = new SuperPower(); // 推荐 var superPower = new SuperPower(); 使用一个var 声明多个变量，并且每声明一个变量就换一行。 // 不推荐 var items = getItems(); var goSportsTeam = true; var dragonball = &#39;z&#39;; // 推荐 var items = getItems(), goSportsTeam = true, dragonball = &#39;z&#39;; 声明多个变量时，把不赋值的变量放在后面。这样做是有好处的，如果日后你想给未赋值变量赋值的时候，可能要引用到上面已经赋值的变量。 // 不推荐 var i, len, dragonball, items = getItems(), goSportsTeam = true; // 不推荐 var i, items = getItems(), dragonball, goSportsTeam = true, len; // 推荐 var items = getItems(), goSportsTeam = true, dragonball, length, i; 在一个作用域的顶部给一个变量赋值。这样有助于避开，变量声明和声明提前的分配问题。 // 不推荐 function() { test(); console.log(&#39;doing stuff..&#39;); //..other stuff.. var name = getName(); if (name === &#39;test&#39;) { return false; } return name; } // 推荐 function() { var name = getName(); test(); console.log(&#39;doing stuff..&#39;); //..other stuff.. if (name === &#39;test&#39;) { return false; } return name; } // 不推荐 function() { var name = getName(); if (!arguments.length) { return false; } return true; } // 推荐 function() { if (!arguments.length) { return false; } var name = getName(); return true; } 声明提前 不管你在何处给一个变量声明或赋值，javascript解析器都会事先在作用域的顶端做声明提前（Hoisting）。 // 我们知道下面将不能正常运行（假设没有全局变量） function example() { console.log(notDefined); // =&gt; 抛出一个引用错误 } // 在引用这个变量之后，给这个变量赋值将不会抛异常，这是因为javascript解析器有声明提前。 // 注意：赋的“true”值，不会被提前。 function example() { console.log(declaredButNotAssigned); // =&gt; undefined var declaredButNotAssigned = true; } // javascript解析器,会在作用域的顶部提前声明变量。 // 用代码描述出来，其实就等同于下面这种情况。 function example() { var declaredButNotAssigned; console.log(declaredButNotAssigned); // =&gt; undefined declaredButNotAssigned = true; } 匿名函数表达式将该变量名做了提前声明，没有给该变量赋值函数。 function example() { console.log(anonymous); // =&gt; undefined anonymous(); // =&gt; 抛出异常，anonymous 不是一个函数 var anonymous = function() { console.log(&#39;anonymous function expression&#39;); }; } 和匿名一样，有名函数表达式将该变量名做了提前声明，没有给该变量赋值函数名和函数体。 function example() { console.log(named); // =&gt; undefined named(); // =&gt; 抛出异常， named 不是一个函数 superPower(); // =&gt; 抛出异常， superPower 没定义 var named = function superPower() { console.log(&#39;Flying&#39;); }; } // 把函数名改成和变量名一样，也得出同样的结果。 function example() { console.log(named); // =&gt; undefined named(); // =&gt; 抛出异常， named 不是一个函数 var named = function named() { console.log(&#39;named&#39;); }; } 函数声明会将函数名和函数体声明提前。 function example() { superPower(); // =&gt; Flying function superPower() { console.log(&#39;Flying&#39;); } } 更多信息请参照 Ben Cherry 的 JavaScript Scoping &amp; Hoisting 条件表达式与等式 使用 === 和 !== 代替 == 和 !=。 条件表达式 会通过 ToBoolean 来进行强制转化，而且遵循以下的规则： 对象被转化为true Undefined被转化为false Null被转化为false 布尔值被转化为相应的布尔值 数字当值为+0,-0或NaN时转化为false，其他的转化为true Strings类型如果为空时转化为false,否则转化为true if ([0]) { // true // 因为数组是对象，对象会被转化为 true } 使用快捷方式 // 不推荐 if (name !== &#39;&#39;) { // ...stuff... } // 推荐 if (name) { // ...stuff... } // 不推荐 if (collection.length &gt; 0) { // ...stuff... } // 推荐 if (collection.length) { // ...stuff... } 更多的信息 请看 Angus Croll 的 Truth Equality and JavaScript 块 给多行的块，使用大括号 // 不推荐 if (test) return false; // 推荐 if (test) return false; // 推荐 if (test) { return false; } // 不推荐 function() { return false; } // 推荐 function() { return false; } 注释 使用 /**...*/ 进行多行注释。注释要包括描述、指定类型、参数值和返回值。 // 不推荐 // make() returns a new element // based on the passed in tag name // // @param &lt;String&gt; tag // @return &lt;Element&gt; element function make(tag) { // ...stuff... return element; } // 推荐 /** * make() returns a new element * based on the passed in tag name * * @param &lt;String&gt; tag * @return &lt;Element&gt; element */ function make(tag) { // ...stuff... return element; } 使用 // 进行单行注释。注释单独占一行，并写在需要注释对象的上面。在注释的上面留一个空行。 // 不推荐 var active = true; // is current tab // 推荐 // is current tab var active = true; // 不推荐 function getType() { console.log(&#39;fetching type...&#39;); // set the default type to &#39;no type&#39; var type = this._type || &#39;no type&#39;; return type; } // 推荐 function getType() { console.log(&#39;fetching type...&#39;); // set the default type to &#39;no type&#39; var type = this._type || &#39;no type&#39;; return type; } 给你的代码加前缀，比如FIXME或TODO，这样有助于其他开发者可以迅速理解你指出的需要被处理的问题。如果想更清晰一点你还可以在后面加上描述，比如: FIXME -- need to figure this out或TODO -- need to implement. 使用 // FIXME: 去注释问题 function Calculator() { // FIXME: shouldn&#39;t use a global here total = 0; return this; } 使用 // TODO: 来注释解决方法 function Calculator() { // TODO: total should be configurable by an options param this.total = 0; return this; } 空格 将tab键设成2个空格 // 不推荐 function() { ∙∙∙∙var name; } // 不推荐 function() { ∙var name; } // 推荐 function() { ∙∙var name; } 逗号/冒号/小括号后面留一个空格 // 不推荐 function test(){ console.log(&#39;test&#39;); } // 推荐 function test() { console.log(&#39;test&#39;); } // 不推荐 dog.set(&#39;attr&#39;,{ age: &#39;1 year&#39;, breed: &#39;Bernese Mountain Dog&#39; }); // 推荐 dog.set(&#39;attr&#39;, { age: &#39;1 year&#39;, breed: &#39;Bernese Mountain Dog&#39; }); 在文件的最后留一个空行 // 不推荐 (function(global) { // ...stuff... })(this); // 推荐 (function(global) { // ...stuff... })(this); 逗号 逗号不要前置 // 不推荐 var once , upon , aTime; // 推荐 var once, upon, aTime; // 不推荐 var hero = { firstName: &#39;Bob&#39; , lastName: &#39;Parr&#39; , heroName: &#39;Mr. Incredible&#39; , superPower: &#39;strength&#39; }; // 推荐 var hero = { firstName: &#39;Bob&#39;, lastName: &#39;Parr&#39;, heroName: &#39;Mr. Incredible&#39;, superPower: &#39;strength&#39; }; 最后一个元素不可以加逗号。这在IE6和IE7还有IE9的怪异模式下出错。 感谢阮一峰老师的原创，本分享仅供学习交流 ## 关于 GitHub: 👉https://github.com/microzz","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://microzz.com/tags/JavaScript/"},{"name":"JS","slug":"JS","permalink":"https://microzz.com/tags/JS/"},{"name":"编码规范","slug":"编码规范","permalink":"https://microzz.com/tags/编码规范/"},{"name":"Airbnb","slug":"Airbnb","permalink":"https://microzz.com/tags/Airbnb/"}]}]